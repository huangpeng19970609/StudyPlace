###       疑问

1. 可以new 一个 函数？
2. 

### 一、寻路

> 参考文章： http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/
>
> 参考代码： https://github.com/vuejs/vue
>
> <span style='color: red;'>看庞大的代码应先关注于宏观</span>

### 1 寻找Vue构造函数



1.  检出 官方的vue项目， 使用 `npm run dev`命令 

   【既然是通过 npm run dev】来启动项目， 那看看此命令做了些什么？

   此处是由关于 roll的打包过程, 了解即可，最终目标是发现vue的构造函数在哪里
   
   ````json
"dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev",
   ````

   查询对应文件的对应目标如下
   
   ![j](images/vue-1.png)

````js
if (process.env.TARGET) {
  module.exports = genConfig(builds[process.env.TARGET])
} else {
  exports.getBuild = name => genConfig(builds[name])
  exports.getAllBuilds = () => Object.keys(builds).map(name => genConfig(builds[name]))
}

// 此处等价于
module.exports = genConfig({
 	entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
})
````

2. 入口文件

    > 这条线路上，经历了很多次的处理，未来
    
    ```js
entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),
   ```

   在入口文件中,  故我们应看此文件， 此文件暂时略。

- 第一次： 在`entry-runtime-with-compiler.js`中
  
   ![images/vue-2.png](images/vue-2.png)

````js
# 这是最终的入口Vue
1、 Vue.prototype.$mount
2、 Vue.compile
````

- 第二次：`runtime/index` 在```中我们又可以看到如下的一句话，故

````js
import Vue from 'core/index'

看一看在【runtime/index】中做了什么?
    
#1 install platform specific utils
Vue.config.mustUseProp = mustUseProp
Vue.config.isReservedTag = isReservedTag
Vue.config.isReservedAttr = isReservedAttr
Vue.config.getTagNamespace = getTagNamespace
Vue.config.isUnknownElement = isUnknownElement

#2  又一次处理了 mount
Vue.prototype.$mount // public mount method
````

- 第三次，在其`core/index`中

  > 此时

````js
import Vue from './instance/index'

在【core/index】中做了什么呢？
Object.defineProperty(Vue.prototype, '$isServer', {
  // 设置其get的返回值
  get: isServerRendering
})
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  // 设置其值
  value: FunctionalRenderContext
})
````

- 第四次，在`instance/index`

  作用： Vue的构造函数上被添加了一些原型方法

六处文件构成了 Vue的构造函数的核心内容。

<img src="images/vue-3.png" style="zoom: 80%;" />



````js
# 1	initMixin(Vue) 		
=> './init' 提供了 initMixin方法 （mixin 的含义为 混合）
	Vue.prototype._init = function (options?: Object)

#2	stateMixin(Vue) 	
=> './state' 提供了 stateMixin

	Object.defineProperty(Vue.prototype, '$data', dataDef)	 # this.$data
	Object.defineProperty(Vue.prototype, '$props', propsDef) # this.$props为谁服务？
	Vue.prototype.$set = set		# 看到了老朋友 this.$set 原来是在这里声明的！
	Vue.prototype.$delete = del
	Vue.prototype.$watch

#3
eventsMixin(Vue)	=>  './events'
	Vue.prototype.$on
	Vue.prototype.$once
	Vue.prototype.$off
	Vue.prototype.$emit # 看到了老朋友 this.$set！ 
#4
lifecycleMixin(Vue)	=> 	'./lifecycle'
	Vue.prototype._update
	Vue.prototype.$forceUpdate # 倒是见过，不过不知道具体作用 this.$forceUpdate
	Vue.prototype.$destroy
#5
renderMixin(Vue)	=>  './render'
	Vue.prototype.$nextTick
	Vue.prototype._render
	installRenderHelpers 函数在原型上挂载了好多_o, _f, _k这类方法
````

※`Vue` 在经过 `initGlobalAPI` 之后，会变成这样：

```js
// src/core/index.js / src/core/global-api/index.js
Vue.config
Vue.util = util
Vue.set = set
Vue.delete = del
Vue.nextTick = util.nextTick
Vue.options = {
    components: {
        KeepAlive
    },
    directives: {},
    filters: {},
    _base: Vue
}
Vue.use
Vue.mixin
Vue.cid = 0
Vue.extend
Vue.component = function(){}
Vue.directive = function(){}
Vue.filter = function(){}

Vue.prototype.$isServer
Vue.version = '__VERSION__'
```



### 2、构造函数的执行

⭐ 我们只要关心我们想要的顺序！既要笼统也应该细致！

```js
#1 init.js

初始化 _uid 与 _isVue
=> 是否存在 _isComponent (此为内部组件使用，开发中无此参数)
=> 不存在 => vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor) )
```

#### 1、 使用策略对象合并参数选项

PS: 此处仍旧只是Vue的构造函数的一系列处理，这些真正处理后传入的参数则是另外的

```js
# resolveConstructorOptions
传参为: vm.constructor， 即是 vue的构造函数本身 ES语法
```



### 3、instance/index

````js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'

import { warn } from '../util/index'
````

#### 1、 关于 warn函数

是一处打印错误的语句提示，当this的指向并非是 Vue实例的时 且非生产环境时会如此报错。

````js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
````

跟着 warn的引入文件`util/index`

````js
export * from './debug'
````

在 debug文件中

````js
// noop的由来， 默认noop是一个空的函数
import { noop } from 'shared/util'

export let warn = noop; // 默认的 noop 来自 

# 若你位于的是开发环境， 不过他用的是 flow/vite 具体不清楚
且会根据你config中对应的配置来进行判断
1、存在自定义的错误warn函数 => config中的 warnHandler
2、默认
	console.error(`[Vue warn]: ${msg}${trace}`)
3、追踪路径
	此外还可以帮助我们追踪组件的错误信息
    export let generateComponentTrace = (noop: any) // work around flow check
````

#### 2、initMixin(Vue)

vm 即 vue的实例

> - Vue.prototype._init

1. initInternalComponent

   若其又内部的组件，则会特别处理内部的组件。

   - 充分利用内部组件的实例化,由于动态的options的合并是十分慢的.故动态的组件需要特别的处理

2. resolveConstructorOptions

   处理 构造函数的options

3. 一系列挂载

   ```js
   
   
   ```

   

