## 一、寻路

> 参考文章： http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/
>
> 参考代码： https://github.com/vuejs/vue
>
> <span style='color: red;'>看庞大的代码应先关注于宏观</span>

### 1 寻找Vue构造函数



1.  检出 官方的vue项目， 使用 `npm run dev`命令 

   【既然是通过 npm run dev】来启动项目， 那看看此命令做了些什么？

   此处是由关于 roll的打包过程, 了解即可，最终目标是发现vue的构造函数在哪里
   
   ````json
   "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev",
   ````

   查询对应文件的对应目标如下
   
   ![j](images/vue-1.png)

````js
if (process.env.TARGET) {
  module.exports = genConfig(builds[process.env.TARGET])
} else {
  exports.getBuild = name => genConfig(builds[name])
  exports.getAllBuilds = () => Object.keys(builds).map(name => genConfig(builds[name]))
}

// 此处等价于
module.exports = genConfig({
 	entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
})
````

2. 入口文件

    > 这条线路上，经历了很多次的处理，未来
    
    ```js
   entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),
   ```

   在入口文件中,  故我们应看此文件， 此文件暂时略。

- 第一次： 在`entry-runtime-with-compiler.js`中
  
   ![images/vue-2.png](images/vue-2.png)

````js
# 这是最终的入口Vue
1、 Vue.prototype.$mount
2、 Vue.compile
````

- 第二次：`runtime/index` 在```中我们又可以看到如下的一句话，故

````js
import Vue from 'core/index'

看一看在【runtime/index】中做了什么?
    
#1 install platform specific utils
Vue.config.mustUseProp = mustUseProp
Vue.config.isReservedTag = isReservedTag
Vue.config.isReservedAttr = isReservedAttr
Vue.config.getTagNamespace = getTagNamespace
Vue.config.isUnknownElement = isUnknownElement

#2  又一次处理了 mount
Vue.prototype.$mount // public mount method
````

- 第三次，在其`core/index`中

  > 此时

````js
import Vue from './instance/index'

在【core/index】中做了什么呢？
Object.defineProperty(Vue.prototype, '$isServer', {
  // 设置其get的返回值
  get: isServerRendering
})
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  // 设置其值
  value: FunctionalRenderContext
})
````

- 第四次，在`instance/index`

  作用： Vue的构造函数上被添加了一些原型方法

六处文件构成了 Vue的构造函数的核心内容。

<img src="images/vue-3.png" style="zoom: 80%;" />



````js
# 1	initMixin(Vue) 		
=> './init' 提供了 initMixin方法 （mixin 的含义为 混合）
	Vue.prototype._init = function (options?: Object)

#2	stateMixin(Vue) 	
=> './state' 提供了 stateMixin

	Object.defineProperty(Vue.prototype, '$data', dataDef)	 # this.$data
	Object.defineProperty(Vue.prototype, '$props', propsDef) # this.$props为谁服务？
	Vue.prototype.$set = set		# 看到了老朋友 this.$set 原来是在这里声明的！
	Vue.prototype.$delete = del
	Vue.prototype.$watch

#3
eventsMixin(Vue)	=>  './events'
	Vue.prototype.$on
	Vue.prototype.$once
	Vue.prototype.$off
	Vue.prototype.$emit # 看到了老朋友 this.$set！ 
#4
lifecycleMixin(Vue)	=> 	'./lifecycle'
	Vue.prototype._update
	Vue.prototype.$forceUpdate # 倒是见过，不过不知道具体作用 this.$forceUpdate
	Vue.prototype.$destroy
#5
renderMixin(Vue)	=>  './render'
	Vue.prototype.$nextTick
	Vue.prototype._render
	installRenderHelpers 函数在原型上挂载了好多_o, _f, _k这类方法
````

※`Vue` 在经过 `initGlobalAPI` 之后，会变成这样：

```js
// src/core/index.js / src/core/global-api/index.js
Vue.config
Vue.util = util
Vue.set = set
Vue.delete = del
Vue.nextTick = util.nextTick
Vue.options = {
    components: {
        KeepAlive
    },
    directives: {},
    filters: {},
    _base: Vue
}
Vue.use
Vue.mixin
Vue.cid = 0
Vue.extend
Vue.component = function(){}
Vue.directive = function(){}
Vue.filter = function(){}

Vue.prototype.$isServer
Vue.version = '__VERSION__'
```



### 2、构造函数的执行

⭐ 我们只要关心我们想要的顺序！既要笼统也应该细致！

```js
#1 init.js

初始化 _uid 与 _isVue
=> 是否存在 _isComponent (此为内部组件使用，开发中无此参数)
=> 不存在 => vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor) )
```

#### 1、 使用策略对象合并参数选项

PS: 此处仍旧只是Vue的构造函数的一系列处理，这些真正处理后传入的参数则是另外的

```js
# resolveConstructorOptions
传参为: vm.constructor， 即是 vue的构造函数本身 ES语法
```



### 3、instance/index

````js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'

import { warn } from '../util/index'
````

#### 1、 关于 warn函数

是一处打印错误的语句提示，当this的指向并非是 Vue实例的时 且非生产环境时会如此报错。

````js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
````

跟着 warn的引入文件`util/index`

````js
export * from './debug'
````

在 debug文件中

````js
// noop的由来， 默认noop是一个空的函数
import { noop } from 'shared/util'

export let warn = noop; // 默认的 noop 来自 

# 若你位于的是开发环境， 不过他用的是 flow/vite 具体不清楚
且会根据你config中对应的配置来进行判断
1、存在自定义的错误warn函数 => config中的 warnHandler
2、默认
	console.error(`[Vue warn]: ${msg}${trace}`)
3、追踪路径
	此外还可以帮助我们追踪组件的错误信息
    export let generateComponentTrace = (noop: any) // work around flow check
````

#### 2、initMixin(Vue)

vm 即 vue的实例

> - Vue.prototype._init

1. initInternalComponent

   若其又内部的组件，则会特别处理内部的组件。

   - 充分利用内部组件的实例化,由于动态的options的合并是十分慢的.故动态的组件需要特别的处理

2. resolveConstructorOptions

   处理 构造函数的options

3. 一系列挂载

   



## vue的双向绑定

![](images/Snipaste_2021-09-23_17-34-21.png)

> 参考文档： https://segmentfault.com/a/1190000006599500
>
> 这是一个更好的参考文档： https://zhuanlan.zhihu.com/p/27111918
>
> sf是yyds！

- 关于vue： ``数据劫持` +  `发布者-订阅者模式`的方式

1. 数据劫持

   `Object.defineProperty()`来实现对属性的劫持，达到监听数据变动的目的

2. 发布者-订阅者模式

### 1 实现 Observe

- 对数据进行数据的劫持

  这里只是初步的实现，暂时不考虑数组一类数据

  ```js
  function observe (data) {
  	if (!data || typeof data !== 'object') return;
      Object.keys(data).forEach( key => {
         defineReactive(data, key, data[key]);
      });
  }
  # 此处存疑问， 我们进行的set修改真的成功了吗？ val毕竟可能不是引用类型吧？
  # 答: 经过解答, 闭包了形参， val 相当于常驻内存的常量，我们一直来维护这个形参变量
  function defineReactive(data, key, val) {
  	observe(val);
      Object.defineProperty(data, key, {
         configurable: false,
         enumerable: true,
          get:function() {
          	return val;
          }
          set:function(newVal) {
          	val = newVal
      	}
      });
  }
  ```

- 基础的数据劫持已经实现了，目前来实现通知订阅者。 发布者-订阅者模式

  ````js
  function observe(data) {}
  function defineReactive(data, key, val) {
      # 每一个属性都应该有一个
      var dep = new Dep();
  	observe(val); // 令其本身响应
  	Object.defineProperty(data, key, {
          ·······
          set: function(newVal) {
              val = newVal
              #   通知所有订阅者
              dep.notify();
          },
      });
  }
  
  # Dep是订阅者Watcher对应的数据依赖
  function Dep() {
      this.subs = [];
  }
  Dep.prototype = {
      addSub(sub) {
          this.subs.push(sub);
      }
      notify() {
          this.subs.forEach(function(sub) {
              sub.update();
          });
      },
  }
  ````

- 谁是订阅者？怎么往订阅器添加订阅者？

  订阅者应该是Watche

  ````js
  // Observer.js
  Object.defineProperty(data, key, {
      get: function() {
          // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，
          // 暂存watcher, 添加完移除
          Dep.target && dep.addSub(Dep.target);
          return val;
      }
  });
  
  // Watcher.js
  Watcher.prototype = {
      get: function(key) {
          Dep.target = this;
          this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者
          Dep.target = null;			
      }
  }
  ````

### 2 实现 Compile

- 简而言之， 编译为数据

- 对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数

  1. 遍历所有节点及其子节点, 调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定
  2. 所谓的编译的流程就是读取了不同节点类型中的属性
  3. 这个例子只尝试实现v-model及{{}},
     - 若是元素节点，生成一个watcher，加一个监听，监听input输入值同时改变vm上的对应属性值
     - 若是文本节点，生成一个watcher，当vm的值大赛变化时改变文本节点的值

  ```js
  function compile (node, vm) {
  	let reg = /\{\{(.*)\}\}/
  	if (node.nodeType === 1) {
  		let attr = [].slice.call(node.attributes)
  		attr.map((i) => {
  			if (i.nodeName === 'v-model') {
  				let name = i.nodeValue
  				node.addEventListener('input', (e) => {
  					vm[name] = e.target.value
  				})
  				node.removeAttribute('v-model')
  				new Watcher(vm, node, name, 'input')
  			}
  		})
  	}
  	if (node.nodeType === 3) {
  		if (reg.test(node.nodeValue)) {
  			let name = RegExp.$1
  			name = name.trim()
  			new Watcher(vm, node, name, 'text')
  		}
  	}
  }
  ```

### 3 实现 Watcher

- Watcher订阅者作为`Observer和Compile`之间通信的桥梁

- Observer和Compile的桥梁, 能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

  ```js
  
  function Watcher(vm, exp, cb) {
      this.cb = cb;
      this.vm = vm;
      this.exp = exp;
      // // 此处为了触发属性的getter => 目的是 添加subs
      this.value = this.get(); 
  }
  	
  Watcher.prototype = {
      get: function() {
          //  将当前订阅者指向自己
          Dep.target = this;
          //  触发getter，添加自己到属性订阅器中 => Dep.target && dep.addSub(Dep.target);
          var value = this.vm[exp] 
          // 添加完毕重置
          Dep.target = null;			
      	return value;
      },
      update: function() {
          this.run();    // 属性值变化收到通知
      },
      run: function() {
          var value = this.get(); // 取到最新值
          var oldVal = this.value;
          if (value !== oldVal) {
              this.value = value;
              this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图
          }
      },
      
  }
  ```

### 4 MVVM实现

````js
function MVVM(options) {
    this.$options = options;
    var data = this._data = this.$options.data, me = this;
    // 属性代理，实现 vm.xxx -> vm._data.xxx
    Object.keys(data).forEach(function(key) {
        me._proxy(key);
    });
    observe(data, this);
    this.$compile = new Compile(options.el || document.body, this)
}

// 属性代理
MVVM.prototype = {
    _proxy: function(key) {
        var me = this;
        Object.defineProperty(me, key, {
            configurable: false,
            enumerable: true,
            get: function proxyGetter() {
                return me._data[key];
            },
            set: function proxySetter(newVal) {
                me._data[key] = newVal;
            }
        });
    }
};
````



