#### 掘金面试题
#### 一 JS数据类型
1. 有哪些基本类型
2. 基本类型与引用类型的区别
3. symbol 与 bigint的应用场景

```js
  1 有哪些基本类型
  ES5时为6种， Number String Boolean undefined object null

  2 基本类型与引用类型的区别
   存储的内容：基本类型存的便是值， 引用类型会存的是内存地址（但引用类型同时也会开辟新的内存） 
   真存储区间不同：基本类型存值于栈；引用类型存指针于栈，存内容于堆。
   PS： 为什么存在堆中。因为其引用类型的值是不能预估其所占的存储空间的大小的。而基本类型是可以估计的。同时也引出来了为什么 String 是只能被销毁的然后重建创建的这一概念。

   3 symbol 与bigInt
    symbol此类型的对象用不相等，其出现的意义：便是希望有独一无二的标识。
    例如
    // 传参目的只是起名字而已,也可不传
    Symbol('key') !== Symbol('key')

    场景： 作为对象的属性名
    PS: 过去symbol不存在时候，对象的属性名只会是 String
    例如: 
    const PROP_NAME = Symbol();
    let obj = {
      [PROP_NAME]: 'hello',
    }
    或
    let obj = {
      Symbol('name')： 'hello',
    }
    当出现了这类型以后，怎么处理？
    Object.keys 遍历不出来
    for key in obj 遍历不出来
    Object.getOwnPropertyNames(obj) 遍历不出来
    目的： 不要动我这个属性！即便你起名与我一样，也动不了我属性，所以你也遍历不出来
    当然也可以有获取Symbol的方法。略。百度。

    第二个场景，定义常量名
    第三个场景 定义类的私有属性。
    class Login {
      constructor (password) {
        this.[PASSWORD] = password;
      }
    }
    目的: 外部永远不能再访问这个，因为没有一个属性名与我相同。

    PS： 强调一下 赋值 拷贝 Object.assign(obj1, obj2) {...obj1, ...obj2}
    不管是哪一种赋值，其赋值永远都是拷贝的是栈的内容。
    但若是对象是二级层次， 比如说对象里面有对象，对象里面有数组，那么此等拷贝还是一种浅拷贝。我们拷贝的只是每一个属性的栈内容，仅此而已！
```


#### 二数据类型的判断
1. 判断类型
2. instanceof原理
3. 判断一个空对象
4. typeof null
5. typeof NaN
   

```js
1. 判断类型
  typeof
  arr instanceof Array
  Object.prototype.toString.call(xxx);
  根据constructor属性判断
  例如 
    ''.constructor == String
    new Number(1) == 1
2. instanceof原理
  如例:
    function Person(){}
    let p1 = new Person();

  p1 instanceof Person
  检查 Person.prototype 指向的原型对象是否在p1的原型链上.

3. 判断空对象
  办法一: JSON.stringfy(obj) === '{}'
  办法二: 
    Object.keys(obj).length === 0 
    PS: 此处只是针对可枚举属性
  办法三:
    Object.getOwnPropertyNams(obj).length === 0; 
    PS： 包括不可枚举属性

4. typeof Null
  typeof Null 返回的是object 为ES BUG，后续不在修复
  typeof undefined 返回的是undefined

5 typeof NaN
  返回的number 此时一处专门的判断，记住就可以
```

#### 三 var let const区别 块级作用域与执行环境



#### 六 call apply bind

#### 七 闭包

1. 闭包概念
2. 闭包场景

```js
  什么是闭包？
  (function test() {
    let local = '';
    function foo() {
      console.log(local);
    }
    console.dir(foo);
  })();
  
  三要素：
    他应在一个立刻执行的函数里面
    其内部还有函数
    内部函数引用了外部的临时变量
  如上的便是有了一个闭包， 你会发现其作用域中已经产生了一个闭包函数 test
```
  若从一个广的角度来说: JS所有的函数都可以算得上是闭包

因为都是访问了全局变量，来维护同一份私有变量，这些函数便是 维护私有域的接口.

 ` 闭包作用：`
    形成私有域， 保护变量不受外界干扰。
    提供暴露的接口，这也是为什么闭包总是返回一个函数的原因！通过返回的接口来维护这份的私有变量.

  比如 用定时器来实现的节流。

  #### ES5的那些继承

  ```js
  
  console.log(SuperType)
  先看一看 SuperType 与 SubType
  SubType.protoType = new SuperType();
  请打印出来此实例
  

  ```