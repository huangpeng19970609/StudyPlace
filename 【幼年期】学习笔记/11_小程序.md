

### 1、准备工作

1. 微信公告平台 注册账号，申请一个AppID
2. 下载工具，使用 web开发工具

### 2、文件结构

​	一个APP由很多的page组成，一个page下有很多的	组件

1. ​	APP

   app.js : App实例代码

   app.json : 全局配置

   app.wxss 全局样式

2. Page

   page.js：   创建page实例的代码以及页面相关内容
   page.json: 业务单独的配置

   page.wxml: 页面wxml布局 => 类似html

   page.wxss: 页面样式配置

3. Component(同理)

   ​	component.js：	组件内部n内容

   ​	component.json: 组件内部配置，比如当前组件使用了别的组件

   ​	component.wxml

   ​	components.wxss

![](D:\WEB Study\前端笔记\images\app_01.png)



### 3、HelloWorld!

- 便捷的创建方式： 在app.json中帮我们注册好我们取得Page名称 
- app.json放置的属性顺序是以 我们先后新建page的顺序的

保留 project.config.json 与 site.json 

```css
1、我们应在目录下 创建 app.js、app.json、app.wxss
	其中app.json是我们小程序的入口文件
	{
		"pages": []
	}
2、若我们想拥有 一个主页
	2.1我们需要创建 home.js \ home.json \ home.wxss \ home.wxml
	2.2创建好后我们需要对其进行注册：
		{
			"pages": [
            	// 因为在根目录，所以直接写
            	"home"
            ]
		}
	2.3但是 home.json也是需要对象的,home.js也是需要页面对象的
		home.js下
        Page({
			
        })
```

- 实际开发当中，我们会先建pages，pages下建立各个页面的子文件。子文件下放置四个文件。

### 4、git管理项目-tag

右键 在对应目录初始化空的仓库

```css
git add .
git commit -m '知识点1'
git tag 01_知识1
git tag 查看是否有tag
--------------
git push --tags
-----
我们要拿代码
git clone 对应的地址
```

### 5、初体验

我们可以 使用预编译，填加编译模式，添加分类界面，则每一次编译以后不会再在首页，先进入到分类界面。这个有利于我们编程更加方便。

```js
home.js下
Page({
	data: {
		name: "CodeWhy",
        student: [
            { name: "123", age: "18"}
            { name: "456", age: "20" }
        ]
	}
})
------------------
<view> 1 {{name}} 2  </view>
<view wx:for="student">   {{item}}  </view>  => 打印 s t u d e n t
<view wx:for="{{students}">   {{item.name}}-{{item.age}}  </view>
-----------------
    
点击按钮 使得对应的值＋1
<view> {{counter}} <view>
<button	bindtap='handlerBtnClick'>＋1</button>

在对应的home.js下，与data同级
handlerBtnClick() {
  	//  this.data.couter += 1 //这样是触发的，但是页面不会同时变化
  	this.setData({
        counter: this.data.counter + 1
    })
    console.log('1')
}

```

- MVVM思想

- ViewModel由Vue提供，View由DOM，Model即JavaScript提供。

  Vue中 ViewModel可以作为View与Model之间的通信桥梁。

  对于Model。ViewModel通过Data Bindings将数据绑定到View，从而呈现。

  对于View，ViewModel通过DOM Lisenter将其事件变化更改model，从而变化。

  <img src="D:\WEB Study\前端笔记\images\chrome_KMAFjHOgYa.png" style="zoom: 200%;" />

- 对于小程序，

View、Model、ViewModel是同样的原理。

​		View   ===>   Dom Listener   =>  Model

​		Model  =>>>> Data Binding ===> View

而ViewModel由MINA框架实现。

### 6、声明式编程与命令式

原生DOM就是命令式编程

Vue这种开发模式就是声明式编程

### 7、小程序配置

小程序中有很多开发需求都被放进去了配置文件，这样可以增加我们的开发效率，保证开发的风格一致。

- app.json 全局配置

- page.json 每一个页面都有自己的json配置，这是局部配置

- project.config.json: 项目配置文件

  一般我们不在文件直接修改，而是 通过 “详情”更改

- sitemap.json: 

  sitemap是用于微信搜索的。

------



- 全局配置

```json
app.json 有大量的配置，详情可以见文档。但有三个必用的。
-----------
pages: 指定小程序由哪些页面组成，每一项对应一个页面。小程序所有页面都必须在pages里注册
window： 用户指定窗口如何显示。
tabBar： 底部tab栏的展示

---------------------------

winodw里设置：
navigationBarBackgroundColor： "#ff5777",
navigationBarTextSyle:	"black"  或是white
navigationBarTitleText： "标题"
backgroundColor： "blue" // 是可以进行下拉，然后又背景色
enablePullDownRefresh: true // 就可以下拉看到这个蓝色
---------------------------

"tabBar": {
    // tabBar的list至少两项
    "list": [{
     	"pagePath": "pagePath",	// 对应的路径
        "text": "text",			
        iconPath: "iconPath",	//默认图片 assets/tabbar/home_active.png
       	selectedColor: XXXX
        "selectedIconPath": "selectedIconPath" //被点击以后的图标
    }]
}
```

- 局部配置

```json
只有全局情况下需要写winodw
{
    "usingComponents": {},
    "navigationBarTitleText": "商品分类"，
    enablePullDownRefresh: true
}
```

### 8、小程序的双模型

- **渲染层:  WebView线程**

​			 	使用WebBiew线程渲染。多个页面就会使用多个WEbView线程进行渲染。

​				wxml => 布局文件，wxss => 样式文件 这两个都是运行在渲染层的。

- **逻辑层:   JsCore线程**

​				逻辑层使用JsCore运行JS脚本。

这两个线程都会经由  微信客户端 进行中转与交换

- 我们写的view代码会变成树结构

比如 <view>  <view>123</view> </view> 这种代码，会变成 树结构，通过树结构我们将其转换为JS对象（与HTML的DOM树相似）.虚拟DOM

```html
<view> {{name}} </viewv> 此时这种代码，仅通过WebView线程是完成不了的，需要借助JS对象才可以。
<view> {{name}} </viewv> wxml =>  JS Object => DOM树
```

- [ ] 界面渲染过程

  首先，渲染层宿主环境会将WXML 转为 对应的JS对象

  再将JS对象再次转换为真实DOM树，交给渲染层的 线程进行渲染。

  一旦我们通过setData把msg的数据从 "hello" 变为 "bye"的时候，

  1. 产生的JS对象对应的节点就会发生变化
  2. 此时会比较两个JS对象，并得到变化的部分(过程: diff算法)(虚拟DOM的算法)
  3. 然后把这个差异化应用的原来的DOM树上，从而达到更新UI。而这便是“数据驱动”的原理。

### 9、小程序的启动过程

在app.js中注册APP(),在App（）中有生命周期函数

<img src="D:\WEB Study\前端笔记\images\chrome_YrS0a8nd11.png" style="zoom:150%;" />



### 10、小程序的生命周期(app.js)

1. onLauch

   ```js
   APP({
       onLaunch: function() {
           wx.getUserInfo({
               // getUserInfo是一个异步方法，故可能会在onShow之后再调用
               success: function(res) {
                   console.log(res)
               }
           })
       }
   })
   ```

2. onShow（options） 为 界面显示出来会执行的函数

3. onHide 为界面隐藏时调用。 这个小程序会在后台保存5分钟。

4. onError（msg） 当小程序出现错误时候，

### 11、注册APP

- **判断小程序的进入场景是如何**

右上角 有一个模拟器，当我们点击“X”这个按钮会出来一系列的小程序场景值,并进入对应的场景。

```js
onShow: function(options) {
	console.log(options)
    // 判断进入场景
	switch(options.scene) {
		case 1001: 
			break;
		case 1004：
			break;
	}
    // 获取用户信息,
    wx.getUserInfo({
        success: function(result) {
            console.log(result)
        }
    })
}
```

- **监听生命周期函数**

  对应生命周期内执行对应的业务逻辑，比如在某个生命周期中获取微信用户的信息。

  

- App（）该实例在小程序中仅有一个，并且是**全局共享的单例对象**，故可用于共享数据

  ```js
  如果我们在 app.js下定义一个对象
  	globalData: {
          name: 'age',
          age: 18
      }
  以home.js为例子
  const app = getApp()
  console.log(app.globalData.name)
  ```

  

### 12、wx.getUserinfo()的替代

- 微信提示可能会废弃接口.

但这种需要一个步骤： 用户必须点击这个按钮，才可以获取用户信息

```vue
button 组件中 将open-type更改为getUserInfo，并绑定binggetuserinfo事件获取

<button size="mini" bindtap='hanldeGetUserInfo' open-type='getUsefInfo'>获取授权</button>
---------------------------------
对应的home.js中
page({
	hanldeGetUserInfo(event) {
		console.log(event)
	}
})
```

- open-data组件 => 具体查看api文档（通过设置type）

  ```vue
  <open-data type="userNickName"><open-data> 则会自动展示我们微信的名称
  ```

### 13、注册页面

- [ ] 小程序中每一个页面都有一个对应的JS文件，其中会调用Page方法来注册页面示例,

- [ ] 调用App方法为注册APP，调用page方法为注册页面

  在注册时候，绑定初始化数据、生命周期调用、事件处理函数

1. 第一步，监听页面生命函数。比如在生命周期发送请求函数

   页面的常见生命周期有五个

   - onload : 页面被加载出来
   - onShow 页面显示出来
   - onReady ： 页面首次渲染出来时候（再进入该页面不会渲染）
   - onHide： 页面隐藏时候
   - onUnload ： 当一个页面销毁的时候

   onLoad => onShow => onReady => 

   ```js
   					比如 onLoad\onReady\onShow\onHide\onUnload
   Page({
   	onLoad: function() {} // 传统的函数写法
       // 这是ES6提供的增强语法
   	onload() { 
   		wx.request({
               // 注意下会报错，要打开详情，点击“不校验url”
               url: 'XXX',
               // 增强写法、箭头函数、普通函数写法
               success: function(result){
                   console.log(result)
                   const dat = res.data.data.list;
                   this.setData({
                       list: data
                   })
                   //home.js中，取得list数据以后
                   打开AppData查看
                  
               }
           })
   	}  
   })
   ====================
   <view wx:for="{{list}}">{{item.title}}</view>
   ```

2. 初始化数据

   ```js
   data: {
   	message: "哈哈哈"
   }
   ```

3. 监听wxmld的事件

   ```js
   handleGetUserInfo(event) {
       console.log('hahaha')
   }
   ----
   <view bindtap='handleGetUserInfo'></view>
   ```

4. 监听其他的事件

   ```js
   比如监听事件的滚动
   onPageScroll(obj) {
   	console.log(obj)
   }
   ------
   // 监听是否拉到底部
   onReachBottom() {
   	console.log('页面是否滚动到了底部呢？')
   }
   // 监听下拉刷新
   	需要在home.json文件，
   		配置 "enablePullDownRefresh": true
   	接下来们就可以监听这个生命函数
       onPullDownRefresh() {
           console.log('我下拉刷新了！')
       }	
   ```

### 14、页面双线程生命周期

在AppService Thread的进程下，的常见生命周期有五个

- onload : 页面被加载出来
- onShow 页面显示出来
- onReady ： 页面首次渲染出来时候（再进入该页面不会渲染）
- onHide： 页面隐藏时候
- onUnload ： 当一个页面销毁的时候

但是在ViewThread的线程下，会先

```js
Start => inited 
	视图层在inited时候，
    	比如 {{msg}} 便会 notify 通知逻辑层， 视图线程发过去以后，自身也进入 阻塞状态。
        而逻辑层在进行statt => created以后便会进入
	-----------------------------------
	逻辑层onLoad 与 onShow中
		之后便进入waiting notify这样的阻塞状态，。
       	当 逻辑层将 msg类数据发送过去以后，代表 进入Ready生命周期
        ------------------------
    Reqdy:	
		此时会向逻辑层发信息，逻辑中便是onReady状态
    逻辑便处于onReady：
    	此时页面已经被渲染出来
    逻辑层一旦有新的数据，Active状态
    	便会在视图层进行重新渲染reRender。以此反复。
    -----------------------
     一旦我们退至后台，页面隐藏。即onHide。
	---------------------
     一旦我们回到前台，便是onShow
		便页面视图重新 reRender
     ----------------
	退出系统，便是onload，即End！
```

### 15、常见组件

这些组件的属性非常多，查看API文档就好

#### 1、text

- ​	text 是一个行内元素

- **selecttable**属性，

  true需要插值表达式，否则赋值的便是一个字符串 selecttable='{{true}}'

  如果直接添加 selecttable 那么默认就是 true了！

  ​	<text selecttable='{{true}}'>你好！</text>	

  ​	<text selecttable>我是 \n </text>

- **space属性**

  nbsp为默认

  emsp是一个中文大小

  ensp是个半个中文

  ​	<text space='nbsp'>小 李</text>
  ​	<text space='emsp'>小 李</text>
  ​	<text space='ensp'>小 李</text>

- **decode**属性

  否则就是一个字符串

  ​	<text decode> 5 &gt 3 </text>

#### 2、button

<button/> 块级元素，独占一行

- size

  设置size="mini"以后，会将块级元素变成行内块元素，一行可放多个

  ```html
  <button size="mini" type="primary">按钮</button>
  ```

- plain 设置 plain="true" 或者 plain ，plain镂空效果，去除背景

- disable

- loading 按钮左侧一直都有一个加载 

  <text loading="{{isloading}}">

- hover-class

  <button hover-class='pressed'>

  我们在对应的wxss中写

  ```css
  .pressed {
  	backgound: red;
  }
  ```

#### 3、view

view类似div，view便是一个容器，独占一行

<view>嘎哈哈哈</view>

- class 添加wxss样式

  <view class="myRed">嘎哈哈哈</view>

- hover-class

  当用户"点击"以后，该view出现的状态

  <view hover-class="myRed"/>

- hover-stay-time 设置用户点击以后，延迟多少时间才触发 ，默认为400ms

- hover-start-time 按住多久以后才会触发

- hover-stop-propogation 阻止祖先节点出现  点击态 

#### 4、imgae

1. Image是媒体标签,  	Image 是有自己的默认大小的！320px * 240px,	是一个行内块元素
2. 相对路径：<image src='../../asset/test/XXX.jpeg'/>
3. 绝对路径：<image src='/asset/test'/>
4. 手机获得图片:

```js
比如我点击按钮，触发了一个事件，该事件里面有如下内容，则我底部出弹出 选择图片的提示。
	data({
        imagePath: '',
    })
	wx.chooseImage({
        // 注意这里必须箭头函数
		success: res => {
			console.log(res)
			// 1、取出路径
			const path = res.tempFilePath[0]
            this.setData({
                imagePath: path
            })
		}
	})
```

- mode 设置图片的拉伸模式

  

- lazy-load 懒加载, 用到该图片的时候再加载

  当图片进入到上下三屏时候，便进入加载状态.

- bindload 加载图片是否被加载完成

  <image src='/asset/test' bindload="对应方法名" lazy-load/>

- show-menu-by-longpress 长按图片以后出现图片识别菜单

- binderror 绑定一个函数，监听错误

- scaleToFill 使得图片自己适应默认的图片大小，图片会被拉伸，这也是我们图片的默认拉伸

- aspectFit 保持原来图片的宽高比,但是图片大小依旧跟随我们的设置，会有空白区域出现

- aspectFill 保持原来宽高比，并尽量占据Image,我们的图片不会变形。

- top 仅显示top部分 同理 left、right、bottom、 top left 等

- widthFix 高度不变，宽度自适应！ 我们常常使用这个 widthFi

  

#### 5、input

​	<input/> 默认背景颜色是透明的，且没有边框，可以用来 元素标签设置border

- value属性为input的默认值，

  ​	<input value='hahaha'/>

- type决定 弹出来的键盘类型(模拟器不弹出键盘)

  text  |  number | digit  | 

  <input type='number'/>

- password让其为暗文

  <input password> 

- placeholder 占位符    palaceholder-style

- disabled

- maxlength

- input绑定的事件

  1. bindinput 键盘输入时候触发

  2. bindfocus 聚焦时候

  3. bindblur 失去焦点时候

  4. bindconfirm 点击完成按钮的时候

     ```css
     <input bindinput="hanlderInput"
     	   bindfocus="handlerFocus"
     	   bindblur="handlerBlur"
     	   bindconfirm="handlerFirm"
     > 
     对应的 js文件
     Page({
         // 模拟器可能有bug，点击以后会直接获得焦点，失去焦点
         // 这是es6提供的增强写法
         hanlderInput(event): {
             console.log('用户输入内容', event.detail)
         }
     })
     ```

#### 6、scroll-view 

一般 我们来做 X水平滚动  |  Y滚动，我们通过scroll-view来设置滚动区域大小

<scroll-view>

​	<view wx:for="{{10}}">    {{item}}   </view>

</scropp-view>

- X滚动 scroll-x

  设置 父盒子 为 white-space: nowrap;

  设置 view 为 display: inline-block;

  <scroll-view scroll-x>

- Y垂直滚动 scroll-y

  <scroll-view scroll-y>

- bindscroll

```js
<scroll-view scroll-y  bindscroll="hanlderScroll">
 
 hanlderScroll(event) {
     console.log("123",event)
   	 console.log(event.detail.scrollTop)
 }
```

- bindscrolltoupper 监听滚动到顶端/ 左端 时，触发

  <scroll-view bindscrolltoupper upper-threshold='50'> upper 顶部与左端 

  <scroll-view bindscrolltoupper lower-threshold='50'> lower 底部与右端

### 16、组件共同属性

1. id属性，所有组件都可以设置

2. class属性

3. style 设置组件内联样式

4. hidden 

   <view hidden>哈哈</view>

5. data-* 涉及事件

6. bind* / catch* 涉及事件

### WXSS + WXML + WXS

### 17、WXSS 

行内样式 | 页面样式 | 全局样式

@import '../'  在一个样式里引入别的样式

权重： 行内样式 > 页面样式  > 权重样式 

1. 行内样式

   style中 是以键值对出现的.

   <view style='color:red; font-size: 16px'>哈哈</view>

2. 页面样式

   通过选择器渲染样式。

3. 全局样式

   我们在app.wxss中书写全局样式，

   <view class='container'>哈哈</view>
   
4. 官方有提供一个样式库

   可以在github下下载，在example文件夹下，有对应组件的样式与JS文件

   在style文件夹下有对应的wxss样式

### 18、WXML语法

- 要有严格的闭合，大小写敏感，比如class与Class是两种完全不同的属性

- Mustache语法

  ```css
  <view>{{name + '' + name}}</view>
  <view>{{ age >=18 ? '成年人' : '未成年人'  }}</view>
  <button bindtap="switchColorHandler" >控制box的颜色变化！</button>
  <view class="box {{ isActive ? 'active' : ''}}">box</view>
  --------
  .active: {
      bgcolor: red;
  }
  --------
  page({
      dta: {
          name: '小明',
          age: 20,
          nowTime: new Data().toLocalString(),
          isActive: false
      },
      switchColorHandler() {
          this.setData({
          	isActive = !this.data.Active
          })
      }
      onload() {
          setInterval( ()=> {
              this.setData({
              	nowTime: new.Data().toLocalString()  
              })
          },1000)
      }
  })
  =================
  小程序里是不可以进行DOM的操作的！
  ```

1. 条件判断属性  wx:if |  wx:elif  

   该组件在wxml没有渲染

   <view wx:if='{{isShow}}'></view>  // isShow为布兰值

   <view wx:elif='{{score >= 90}}'></view>

2. hidden属性

   该组件在wxml存在，但视觉上看不到，适用于切换频率高情况下

   <view hidden='{{true}}'></view>

3. 列表渲染属性 wx:for

   <view wx:for='{{ ["a", "b", "c", "d"] }}'>{{item}} {{index}} </view>

   - 给item起别名、index起别名，当多层遍历的时候

     <block wx:for='{{movies}}' wx:for-item='movie' wx:for-index='i'></block>

     则现在 {{ movie }}    {{ i }}

   - key的作用,底层也是diff算法

     <view wx:for='{{ ["a", "b", "c", "d"] }}' wx:key='index'>{{item}} {{index}} </view>

4. block标签！很重要

   block有些类似 template，

   试想一下：我们希望设置父的遍历与判断，往往外面都是要用view，但其实这个view仅是包裹作用

   <block><blcok/>并非是一个组件，不会被渲染，只会接收控制属性，比如遍历与判断。

   ```xml
   <block wx:for="numbs" wx:for-item="inner_nums">
       <block wx:for="{{inner_nums}}">
           <view>  {{item}}  </view>
       </block>
   </block>
   ```

5. 关于绑定key的differ原理

   <view class='container'>

   ​	<view wx:for="letters">{{ item}}</view>   // ;letters:为数组。放着a，b,  c

   </view>

   此时 .container 生成了 三个分支 : a  b  c

   若是 letters中插入一个新值 , letters: [   ]

   ```js
   letters: ['a', 'x', 'b', 'c']
   此时若没有绑定key，a依旧是a，b会变成x，c变成b，c变成d。 变成了四个。这样的性能不高，极其生硬
   若是绑定了key,a、b、c不变，新建一个x，直接将x插入。
   differ算法： 先比较ID，将其直接插入。
   ```

6. 模板语法

   注意模板的内容在使用之前是不会继续进行任何的渲染

   ```js
   ======================模板的定义
   <template name="contentItem">
   	<button>{{buttonText}}</button>
   	<view>{{ViewText}}</view>
   </template>>
   
   ======================使用is来渲染
   <tempate is="contentItem" data="{{buttonText: '按钮'，ViewText：'内容'}}"/>
   ```

7. wxml 的引入

   - import导入模板 template，不可以递归导入

   ```html
   单独放在一个wxml文件当中
   <template name="contentItem">
   	<button>{{buttonText}}</button>
   	<view>{{ViewText}}</view>
   </template>>
   ```

   -----

   ```html
   <import src="/wxml/tempalte.wxml"> 
   ======================使用is来渲染
   <tempate is="contentItem" data="{{buttonText: '按钮'，ViewText：'内容'}}"/>
   ```

   - include导入模板

     允许循环导入

     include是可以将目标文件中除了<template/><wxs/>外的整个代码引入，相当于拷贝到include位置

     ```
     <include src="XXXX"/>
     ```

### 19、WXS模块

WeiXin Script 是小程序的一套脚本语言，结合WXML可以构建页面结构。

WXS并不和JS一致，不过基本一致。

- 为什么要设计WXS语言呢？

  因为在WXML中是不能直接调用Page/Component中定义函数的

  但是某些时候我们希望使用函数处理WXML中的数据（类似Vue的过滤器） ====>  WXS 

<view>25.6666666666</view>

```css
// 下面这个方式是不可以的。因为WXML中无法调用我们在Page中的函数
<view>   {{numberFixed(25.666666)}}  </view>
```

- WXS的运行环境是与JS隔离的。WXS不能调用JS文件中定义的函数，也不可以调用小程序API

- WXS函数不能作为组件的事件回调

- IOS设备上的WXS会比JS快2到20倍

  ---

```css
第一种方法: 直接在wxml中定义
<wxs module="info">

​	var message= "helloWorld!"
​	var name = "coderwhy"
​	var sum = function(num1,, num2) {
​		return num1 + num2
​	}

moudle.exports = {   
​	message: message
  }

</wxs>

<view>{{  info.message }}</view>
```

注意下： 使用wxs时候，需要定义 moudle=“XXX”，通过XXX.属性的方式获取。

并且要使用coomonJS的方式将其导出。

```css
第二种方法: 从另一个单独wwxs文件中引入
<wxs src="../../wxs/info.wxs" module="info" /> 这里仅允许相对路径！ 
<view>{{  info.message }}</view>
```

wxs的应用1

```css
wxs的应用1
-----------------------
format.wxs文件下
function priceFormat(privce , number) {
    var number = number || 2;
    var f_price = ParseFloat(price)
    return f_price.toFixed(number)
}
module.exports = {
    priceFormat: priceFormat
}
--------price是来自对应的js文件的data数据----------------------
<wxs src="../../wxs/format.wxs" module="fomart"></wxs>
<view>{{ format.priceForamt(price, 3) }}</view>
```

wxs的应用2

```js
wxs的应用2
function dataFormat(timestamp, format) {
    return '2019-10-10'
}
module.exports = {
    priceFormat: priceFormat
    dataFormat: dataFormat
}
================================
    <wxs src="../../wxs/format.wxs" module="fomart"></wxs>
<view>
    {{format.dataFormat(time, 'yyyy-mm-dd hh:mm:ss')}}
</view>
```

### 20、事件

#### 1、通用事件

- bindtap 
- bind:tap
- catch:tap

```js
<button bindtap="handleBtnClick" size="mini"></button>
<button bind:tap="handleBtnClick" size="mini"></button>
<button catch:tap="handleBtnClick" size="mini"></button>
```

- input有自己的事件  bindinput          /bindblur          /bindfocus
- scroll-view也有自己的事件
- 以下事件所有组件皆有

```js
touchstart
touchmove
touchcancel 操作被打断时候触发
touchend	
tap		// tap与 longpress只会触发一个
longpress //长按
```

<view bind:touchstart=			"handleTouchStart"/>         Test              </View>

<view bind:touchend=			"handleTouchStart"/>         Test              </View>

<view bind:touchmove=			"handleTouchStart"/>         Test              </View>

<view bind:tap=					"handleTouchStart"/>         Test              </View>

<view bind:longpress=			"handleTouchStart"/>         Test              </View>

---

#### 2、事件对象

​	<button size="mini" bind:tap="handleClcik"/>

```js
handleClcik(event) {
    console.log(event)
}
type 								=> 事件类型
target 								=> 事件对象,触发该事件的button的相关属性	
currentTarget 						=>
detail							    => 当前我们点击的地方，距离页面底部的距离
touches 						    => 记录当前触摸点的地址，他是一个数组，可以记录多个手指地址。
changedTouches					    => 
timeStamp						    => 从页面打开至触发该事件经历的时间
```

touches与changedTouches的区别在于change

一个手指点击某处，触发touches。此时touches与changedTouches无区别。

接下来 增加一个手指。 则touches变为[2]，而changedTouches为增加的那根手指

- 在touchend中不同，手指离开时候，touches[0]，而changetouches[1]. 离开时候是不同的。
- 在多个手指触摸时候是不同的。

target 与currentTarget的区别

​	<view id="outer" bind:tap="handlerOuter">

​			外层

​			<view id="inner" bind:tap="handerInner">内层</view>

​	</view>

currentTarget 产生事件的View

target 触发事件的View

#### 3、事件参数传递

需求：  有头部栏，点击对应tad-item，事件可以监听到对应名称

```html
<view class='container'>
    <block wx:for={{"titles"}} wx:key="{{index}}">
		<view class="item" bind:tap="handleItemClick" 
		data-index="{{index}}" data-item="{{item}}">
			{{item}}
		</view>
	</block>
</view>
====

```

```js
handleItemClick(event) {
    // 重要属性键！data-index="{{index}}" data-item="{{item}}">
    // 这里写event.currentTarget.dataset.属性值就可以了
	const dataset =	event.target.database 
	const title = dataset.item
	const index = dataset.index
	console.log(title, index)
}
```

#### 4、事件冒泡与捕获

bind： 会一层一层的传递

capture-bind:tap 会触发捕获

catch: 阻止事件的进一步传递

<view capture-bind:tap='handleCapture' bind:tap='handleCapture'> </view>

<view capture-catch:tap='handleCapture' bind:tap='handleCapture'> </view>

### 21、组件化开发

#### 1、第一次使用组件开发

- 自定义组件： 仅允许 小写字母、中划线、下划线
- 先新建一个 普通的页面。

如果我们在home中需要使用该组件，那么在其hhome.json

```json
{
    // 开启组件
    "component": true,
	"usingComponents": {
        "待会自定义组件的标签名": "value"，比如
        "my-cpn": "/components/my-cpn/my-cpn"
    }
}
```

在home.wxml中,<cpn><cpn/>这样便显示了

- 注意实现：

1. 以第一步同样的套路就可以实现 组件套组件
2. 尽量不要以wx为自定义组件的前缀
3. 同理在app.json中我们进行注册，那么便是全局的组件

#### 2、组件内的样式

- 以第一步同样的套路就可以实现 组件套组件

- 外部与内部样式是互不影响的。

  组件内的class样式仅对组件内的wxl有用，对于引用组件的Page无效（style scoped）

  组件的wxml中不能使用 ID、属性、标签选择器

- 但如果我们希望相互影响怎么办？

  注意在自定义组件中 ，JS会调用Component方法。

```JS
Component({
    options: {
        // 默认隔离
        stylesolation: "isolated"
        // 我们想让home.wxss的样式改变我们的组件，将其改为shared就可以控制
        stylesolation: "shared"
    }
})
```

#### 3、组件与页面通信

页面向组件传样式   =>  externalClasses

页面向组件传数据  => properties

页面向组件传标签 => slot

- 传递数据

<my-prop title="1111"></my-prop>

<my-prop title="22222"></my-prop>

<my-prop title="33333"></my-prop>

```js
子组件 my-prop.wxml中
	<view class="title">  {{title}}  </view>
my-prop.js中
	Component({
        properties: {
           //  titile: String
            title: {
                type: String,
                value: "默认值",
                observer: function(newVal, oldVal){
                    console.log(newVal, oldVal)
                    // 打印 默认值 然后 1111
                }
                
            }
        }
    })
```

- 传递样式(三个地方需要用)

<my-prop title="1111"  titleclass="red"></my-prop>

red是指在当前页面的样式

```js
子组件 my-prop.wxml中
	<view class="title titleclass">  {{title}}  </view>
Component({
        properties: {},
    	externalClasses: ['titleclass']
    })

```

- 组件向外传递事件。

