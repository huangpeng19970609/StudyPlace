## 1、全局注册与局部注册

```javascript
##   1.1、全局注册的两种方式
            //普通注册的声明，还没有进行注册，此时我们还不知道是局部注册还是全局注册：
            // 这个myson是是我们的组件声明,实现了全局注册
            const myson = Vue.extend({
                template: '
                <div>123</div>
            })
Vue.component('myson',myson)
   1.2、语法糖形式
            但上述有了更好的写法，
            // 语法糖形式
            //2、直接我们写，这种写法是最常见全局注册写法,并且直接帮我们注册好了，并且是一个全局注册
            const my = Vue.component('myson',{
                template: `<div>123</div>`

            });
-------------------------------------------------

2、局部注册的形式
 2.1 普通形式
            // 先声明
            const myson = Vue.extend({
                template: '

                <div>123</div>
            })
           // 再注册，在对应的实例中注册
           var app = new Vue({
           el: '.app',
           components: {
                'myson': my  
            }
 2.2 语法糖形式
      var app = new Vue({
           el: '.app',
            components: {
                'myson': {
                    template: `<div>123</div>`
                }  
           }
// 省略了Vue.extend的声明!!!!!
总结： 可以看得出来，语法糖形式省略了Vue.extend的声明（在内部还是运行了），将其对应的注册方式变成了声明+注册的统一。即一步到位了。
```

```javascript
局部注册与全局注册的区别（不使用语法糖的形式）：
	//关键点!!!!!： 看谁注册这个组件的实例对象是谁，Vue即全局，在我们创建的Vue中即使局部
    //这是全局注册，使用Vue这个实例对象进行全局注册！
	Vue.component('son',son)
	
	// 局部注册，在对应绑定过的Vue实例中进行注册，即局部注册
	var app = new Vue({
    el: '.app',
    components: {
    	'myson': my  
    }
})
```

要记住：

- ​	 语法糖形式和普通形式的区别，实际中我们多使用语法糖形式，省略掉注册时候的extend过程
- ​     一个自定义组件要明白局部与全局的区别在于 注册时候绑定的实例对象！

## 2、组件分离的写法

1、第一个通过script来分离，要记住类型，

```html
<body>
    <div class="app">
      <son-1></son-1>
    </div>
    <!-- 注意这里的script必须要有一个type为text/x-template id要对应其template里的 -->
    <script type="text/x-template" id="son1">
      <div>123456</div>
    </script>
    
    <script>
        //全局引用
       app.component('son1', {
        	template: '#son1'
        });
        // 局域引用
      const app = new Vue({
        el: '.app',
        components: {
          'son-1' : {
            // template会自动来引动这个script里面的文件！
            template: '#son1'
          }
        }
      })
    </script>
</body>
```

2、使用最为广泛的template标签，几乎没什么区别

```html
<div class="app">
      <son-1></son-1>
</div>
<!-- 这个template的用法几乎与JavaScript的引用一模一样！ -->
<template id="son1"> 
      <div>
        123456
      </div>
</template>
    <script>
      // app.component('son1', son1);
      const app = new Vue({
        el: '.app',
        components: {
          'son-1' : {
            template: '#son1'
          }
        }
      })
    </script>
```

总结： 记住 组件与模板！ template属性与template标签！

## 3、组件与Vue实例内容

- 组件里面不可以访问Vue实例的内容，Vue组件应有自己保存数据的地方
- 在注册组件的时候，组件有自己的data、methods属性（其原型是指向Vue的，暂不累述）
- 其组件的data跟Vue实例的不同处在于 其data一定是一个函数！

```javascript
const app = new Vue({
        el: '.app',
        components: {
          'son-1' : {
            template: '#son1',
            // 其data必须是一个函数！而且还要必须有返回对象
            data() {
              return {
                title: 'This is a title'
              }
            }
          } 
        }
      })
```

### 3.1为什么data必须是一个有返回对象的 函数？？

实例化 组件对象的时候会调用这个data函数，其data函数会return相关的数据。

其data函数会在栈空间对应创建，有自己的内存地址，每一个实例组件都是相互独立的！！

为了实现实例组件的独立，故必须这样利用函数返回对象来创建！

保证组件的复用性！防止互相影响！

------



## 4、父子组件的通信

实际开发中，大组件向服务器请求数据，得到数据。其大组件中的小组件需要获得其大组件的信息来渲染页面，即父传子。

- [ ] Vue实例也可以看做是一个父组件！

### 4.1 父组件向子组件传递     props

props有两种写法，一种是数组（比较少使用），一个是对象（k可以定义type、default、required）

type有内置的封装对象这些选项，String，Number，Boolean、Array、Object、Function、Date

若类型是对象或者数组时，其default应是一个有return的函数

**要注意 先用是子组件props声明，然后再自定义标签中绑定！**

```javascript
1、数组形式
var app = new Vue({
      el: '#app',
      components: {
        'my-button': {
          template: '#myButton',
        //第一步，在对应的子数组中使用props属性来声明（很类似于告诉子组件，接下来是son要来接收父组件的值了）
          props: ['son']
        },
      },
      data: {
        myfather: 'father',
      }
 })
// 第二步， 在对应的body中，将声明过的props属性来绑定父元素的属性！只有绑定以后模板里的数据才是真正接收到了！！
// 因为隶属于 父节点之下的位置！故是可接触到父元素的属性位置！！！是中间站！
<div id="app">
   <my-button :son="myfather"></my-button>
</div>
```

使用对象方式传递，最常使用的是这个方法

```javascript
components: {
        'my-button': {
          template: '#myButton',
          props: {
            son: {
              // type代表父组件传过来的值必须是String，若没有值则使用default
              type: String，
              default: '没有此值！',
    	      required: true,
            } 
          }
        },
      },
```



### 4.2 子组件向父组件传递    $emit

​	总而言之！就是传递函数！只不过子组件需要借助$emit与函数的帮助才可以实现传递操作！

​	注意区分pops与data，prps即properties属性的意思，单纯的用来声明并接收父元素传递的值而已！

​	$emit 发射一个自定义的事件

```javascript
<div class="app">
    <p>这里是根元素的父！{{father}}</p>
	// 第三步！对应子组件的标签中我们需要来使用一个函数去监听我们自定义的函数！一旦改变即赋值就完成传值工作啦！
    <my-tempalate @goemit="getemit"></my-tempalate>
  </div>
  <template id="myTemplate">
    <div>
      // 第一步！ 既然是子组件传值！需要在子组件中寻找一个触发$emit事件的函数！
      <input type="text" :value="son" @input="emit($event)">
      <p>{{son}}</p>
    </div>
  </template>
  <script>
    const app = new Vue({
      el: '.app',
      data:{
        father: '123465799',
      },
      methods: {
        getemit(son) {
          console.log(son);
          this.father = son
        }
      },
      components: {
        'my-tempalate': {
          template: '#myTemplate',
          data() {
            return {
              son : '测试使用son！'
            }
          },
          methods: {
              // 第二步！
              //这个函数会被触发，并且会$emit一个自定义的函数！并要传参的值放后面就好啦
            emit(event) {
              this.son = event.target.value
              this.$emit('goemit',this.son)
            }
          }
        }
      }
    })
```

回顾双向绑定的原理：

```javascript
 <input type="text" :value="dnumber1" @input="num1Input($event)">
 // 双向绑定的原理，绑定值，并监听元素
 methods: {
            num1Input(event) {
              this.dnumber1 = event.target.value 
          }
 }   
```

## 5、父子直接访问对象通信

### 4.1  $ref\children 父发送给子

```javascript
/ 要注意一下，既然是父发给子的，那么操作（比如说console.log）这种的方法应该在父方法中
// 拿到对应的子组件对象，但一般不常用（如果添加组件，这里下标会改变）
console.log(this.$children[0].name);

/常用的方法是$ref ,第一步创建对应组件标签的ref属性，则该组件对象会加入$ref的全家桶！
<my-component ref="a"></my-component>
console.log(this.$refs.a) // 使用前需要给对应的组件标签上加上ref="XXX"
// 返回对应的VueComponent实例的属性名
```

### 4.2 子发送给父($parent,$root)

实际使用的时候，不建议这种方式，因为可能其父元素一些属性是不存在的，或者父元素不一样

```javascript
/ 既然是 子 传给父的对象，其操作方法应写在子
console.log(this.$parent)// 如果父为Vue实例，打印出来一个Vue！
						  //对于父为VueComponent，则打印VueComponent对象	
console.log(this.$root)//也比较少使用
```

## 6、插槽

插槽让组件更有拓展性！！

### 6.1 普通插槽的使用，使用默认值 或者  模板标签覆盖

```html
<div class="app">
    <my-component></my-component>
	<!-- 直接在模板标签里写 会将slot的默认值替换掉！ -->
    <my-component><button>覆盖slot默认值</button></my-component>
</div>
  <template id="myComponent" >
    <div>
      <h3>子组件的data值:-----{{son}}</h3>
        <!-- 在模板里的书写slot标签，每一个组件都会有这个slot里的内容，相当于默认值 -->
      <slot><button>我是默认值！</button></slot>
      <br>
    </div>
  </template>
```

### 6.2具名插槽

没有名字的插槽 可能会被 模板标签里的内容替换掉！但是具名插槽不会被替换！

总而言之： 在模板标签的内容，给哪个具名插槽起名字就可以替换掉哪一个具名插槽！

```html
 <div class="app">
     <!-- name为one的插槽会被该覆盖掉，其余的依次显示 -->
    <my-component><div slot="one">123</div></my-component>
     <!-- name为two的会被该模板标签的内容替换掉！ -->
    <my-component><button slot="two">覆盖slot默认值</button></my-component>
     <!-- 如果在这里写，没有任何变化，456依旧会覆盖slot默认值 “我是没有名字的插槽”-->
    <my-component slot=three>456</my-component>
  </div>
  <template id="myComponent" >
    <div>
      <slot name="one"><button>我是一！</button></slot>
      <slot name="two"><button>我是二！</button></slot>
      <slot name="three">我是三</slot>
      <slot>我是没有名字的插槽</slot>
      <p></p>
      <br>
    </div>
```

### 6.3作用域插槽

首先区分一下作用域：

// 父级作用域（Vue实例下），子级模板作用域（Template）

现在 slot的插槽上 绑定你想要传入的 子组件的 对象,比如：data，而我们在其对应的 插槽标签中多加一行template标签并使用slot-scope="slot"就可以引用对应的那个插槽对象！我们使用的时候 直接slot.data就可以使用这个值了！！

```javascript
/ 有这样一个Vue实例，其子组件里存放着fruits数组，我们希望用插槽的方式将其展示出来
const app = new Vue({
    el: '.app',
    components: {
      'my-test': {
        template: '#myTest',
        data () {
          return {
            fruits: ['1','2','3','4']
          }
        }
      }
    }
  })  
```

插槽展示：

```html
<template id="myTest">
  <div>
    <slot :data="fruits">
      <ul>
        <li v-for="(item, index) in fruits" :key="index">{{item}}</li>
      </ul>
    </slot>
  </div>
</template>
```

正常来说，我们使用这样便可以

```html
 <my-test></my-test>  但这样我们写死了，我们不希望这里的模板始终是这样展示的
```

如果我们想更改模板的内容，

首先第一个问题，如何获得模板的数据？他是在子组件里才存在的，而子组件对应的模板也仅有一个，我们到底该如何更改？这时候 作用域插槽就出现了！

**解决办法**：     我们需要使用插槽来增加扩展性，同时我们借助作用域将数据传输过去

```html
<my-test></my-test>  但这样我们写死了，我们不希望这里的模板始终是这样展示的
<my-test>
    注意一下这里！一定要写template来接收模板里的参数！！
    <template slot-scope="slot">
      <div>
          <ul>
            <li v-for="(item ,index) in slot.data">@@{{item}}</li>
          </ul>
      </div>
    </template>
  </my-test>
<!-- 注意一下写法！模板标签里 -->
在这模板中，要记得写slot，它并不会影响大局，因为他只是一个默认的slot插槽，可能会被覆盖。特别强调的原因是 我们要在这个子组件插槽中 绑定参数来帮我们向 my-test标签里的solt来传递 子组件的值！
毕竟模板标签无法访问到 子组件的值的！
<template id="myTest">
  <div>
    <slot :data="fruits">
      <ul>
        <li v-for="(item, index) in fruits" :key="index">{{item}}</li>
      </ul>
    </slot>
  </div>
```

**总结：**

- [ ] `****父组件替换插槽的标签！但内容还是子组件的内容****`

模板里要写插槽并且要绑定对应的值！     <slot :data="fruits">



 <template slot-scope="slot">

































































































