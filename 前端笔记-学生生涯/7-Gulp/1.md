[TOC]



# 一、Gulp 简介

### **1、gulp作用：**

​	项目上线使用：    让HTML、CSS、JS文件压缩与合并

​	语法转换使用：	es6、less

​	公共文件抽离：	顾名思义

​	浏览器自动刷新：顾名思义

2、第一次使用gulp：

```javascript
1、下载好node以后，使用命令行工具 npm install gulp变下载好了gulp文件
2、对应项目的根目录文件上建gulpfile.js
3、src放源文件，而dis放构建后的文件
4、使用时候要在gulpfile.js中文件中编写。
```

![1](D:\WEB Study\前端笔记\7-Gulp\images\1.png)

**3、相关的命令**

```css
gulp.src();获取任务要处理的源文件
gulp.dest();输出文件
gulp.task();建立gulp任务
gulp.watch();监控文件的变化
```

### **4、第一个gulp测试！**

```javascript
const gulp = require('gulp');
gulp.task('first', () => {
    console.log("第一个golp任务");
    gulp.src('./src/css/base.css')
        .pipe(gulp.dest('dist/css'));
})
```

因为我们只需要执行该  名为 first的任务，故我们安装了 gulp-cli 插件 

安装过程：命令行输入 :  gulp -cli -g  注意-g是全局安装，这样我们便可以使用gulp这个命令了

![](D:\WEB Study\前端笔记\7-Gulp\images\2.png)

**5、Gulp一些常用的插件* https://www.npmjs.com**

| **gulp-htmlmin**      | html文件压缩     |
| :-------------------- | ---------------- |
| **gulp-csso**         | **压缩CSS**      |
| **gulp-babel**        | **JS语法转换**   |
| **gulp-less**         | **less语法转换** |
| **gulp-uglify**       | **压缩混淆JS**   |
| **gulp=file-include** | **公共文件包含** |
| **browsersync**       | **浏览器同步**   |
|                       |                  |
|                       |                  |

## **6、第二个gulp测试**

**①在src源文件之下common下存放着一片公共代码，名为header.html**

<img src="D:\WEB Study\前端笔记\7-Gulp\images\3.png" style="zoom:67%;" />

在其src文件夹之下，有着article.html与default.html两个html文件共有这同一片头部文件

![](D:\WEB Study\前端笔记\7-Gulp\images\4.png)

![](D:\WEB Study\前端笔记\7-Gulp\images\5.png)

```javascript
const gulp = require('gulp');
const htmlmin = require('gulp-htmlmin');
const fileinclude = require('gulp-file-include');
gulp.task('first', () => {
    console.log("第一个golp任务");
    gulp.src('./src/css/base.css')
        .pipe(gulp.dest('dist/css'));
})

gulp.task('htmlmin', () => {
    console.log("第二个gulp任务！");
    gulp.src('./src/*.html')
        .pipe(fileinclude())
        .pipe(htmlmin({ collapseWhitespace: true }))
        .pipe(gulp.dest('dist'));
})
```

![](D:\WEB Study\前端笔记\7-Gulp\images\6.png)

## 7、小总结：

​	三个代码块代表三个任务！

```javascript
1、html文件压缩并输出
//第一步！引用相对应的模块
const gulp = require('gulp');						
const htmlmin = require('gulp-htmlmin');
const fileinclude = require('gulp-file-include');
//第二步！使用gulp来创建任务
gulp.task('first', () => {
    console.log("第一个golp任务");
    gulp.src('./src/css/base.css') 	//先获得要处理的任务，src获得
        .pipe(gulp.dest('dist/css'));//再去处理任务 pipe是处理，dest是输出
})

gulp.task('htmlmin', () => {
    console.log("第二个gulp任务！");
    gulp.src('./src/*.html') 	//先获得源文件
        .pipe(fileinclude())	//将公共文件返回给他们，但要记得写 @@include（----）
        .pipe(htmlmin({ collapseWhitespace: true }))//将其html文件压缩
        .pipe(gulp.dest('dist'));//将其输出
})
//注意：
	/*
		我们在使用这些插件语句的时候，仅需要记住插件的名称便好，因为插件太多了
	*/
```

```javascript
2、less语法转换(gulp-less)，css代码压缩(gulp-csso)
const gulp = require('gulp');
const less = require('gulp-less');
const csso = require('gulp-csso');
gulp.task('cssmin', () => {
    gulp.src(['./src/css/*.less', './src/css/*.css'])
        .pipe(less()) //将less语法转为css语法
        .pipe(csso()) //将css进行压缩
        .pipe(gulp.dest('dist/css')) //输出结果
});
```

```javascript
3、es6代码转换，代码压缩
//使用插件！ gulb-babel
//babel将se6转为s5 uglify 压缩
const gulp = require('gulp'); 
const babel = require('gulp-babel');
const uglify = require('gulp-uglify');
gulp.task('jsmin', () => {
    gulp.src('./js/test.js')
        .pipe(babel({
            presets: ['@babel/env']
        }))
        .pipe(uglify())
        .pipe(gulp.dest('./dist/js'))
});
```



# 二、依赖关系

![](D:\WEB Study\前端笔记\7-Gulp\images\7.png)

对于node_modules文件夹其内部有大量我们下载的插件

​	其内部文件夹过多，拷贝传输时会很慢

​	复杂的模块依赖关系需要被记住，故要确保模块的版本和当前要保持一致，否则报错

## 1、package.json的使用

### 	**1、项目的描述文件，使用npm init -y命令生成**

​	-y代表全部使用默认值，对于当前项目的信息（项目名称、版本、作者、依赖第三模块）

```json
{
  "name": "description", 项目名称
  "version": "1.0.0",项目版本
  "description": "",项目描述
  "main": "index.js",项目的主模块名字，以后再说
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1" 该对象存储着命令的别名，简化操作
  },
  "keywords": [],关键字
  "author": "",项目作者
  "license": "ISC"项目遵循的协议，开放源代码协议
}

```

### **2、依赖的关系**

第一步：使用安装一些插件，查看该文件下的package.json有无变化

![](D:\WEB Study\前端笔记\7-Gulp\images\8.png)

第二步：其json会出现相对应的依赖关系

![](D:\WEB Study\前端笔记\7-Gulp\images\9.png)

这样的好处：

![](D:\WEB Study\前端笔记\7-Gulp\images\10.png)

​	若我们不把node_modules里面复杂的文件传给别人，但我们 输入npm install这个命令 会根据 package.json会自动下载该各种依赖的插件，故 我们不需要node_modules传输给别人。

### **3、依赖**

**项目依赖：**

​	项目开发时候需要依赖的第三方包，即为项目依赖

​	使用 npm install命令下的下载文件会自动添加到package.json下的dependencies字段当中

**开发依赖：**

​	辅助项目开发所依赖的第三方包，比如我们使用的gulp

​	使用 npm install 包 --save-dev 命令会将该包添加到package.json下的devDependencies字段当中

![](D:\WEB Study\前端笔记\7-Gulp\images\11.png)

注意：使用npm install ，会下载所有的依赖

npm install --production则只会下载我们需要的dependencies依赖，即所谓的项目依赖。

![](D:\WEB Study\前端笔记\7-Gulp\images\12.png)

------

关于package-lock.json文件：锁定了包的文件，加载下载速度，记录下载地址。

### 4、node，js模块的加载机制

```javascript
第一种方式：省略后缀名
	require('./find.js');
	//若省略后缀名，则会去寻找同名的js文件，
	//若依旧没有，则会寻找同名JS文件夹
		//找到了同名文件夹以后，会认为其index.js文件是的
		//若无index.js则	寻找当前文件夹的package.js文件的main选项的入口文件，若无入口文件则报错。
	require('./find');
```

```javascript
第二种方式：省略前缀与后缀
/*
	若省略前缀与后缀，则Node.js假设其为系统模块
		去node_module文件夹寻找看是否有同名文件夹
			Yes，看是否有index.js
			No,查看package.json里的main选项
				否则报错。

*/
```

# 三、Web服务器

## 1、创建第一个服务器

```javascript
const http = require('http');//引用http模块
const app = http.createServer();//使用http协议创建服务器
app.on('request', (req, res) => {//给服务绑定一个方法名为 request，其参数req、res
    res.end('<h1>123</h1>');
})
app.listen(3000);//该服务器时刻监听着3000这个端口
console.log('3000已经启动');
```

------

接下来 在CMD中输入 node app.js（该js文件名称）便可以运行，建议使用nodemon插件，可以实时变化

nodemon app.js,在浏览器中输入localhost：3000，若想退出，在cmd中crtl+c连续输入两次就可以退出。

------

## 2、HTTP协议

超文本协议

```
超文本协议是客户端与服务器端 request与response之间的标准
```

报文：

​		请求报文

​		响应报文

**HTTP状态码**

​	200成功，404找不到，500服务器错误，400客户端语法错误

### **2.1、get请求参数**

| **req.method 获得请求方式**                                  |
| ------------------------------------------------------------ |
| **req.url 获得请求地址**                                     |
| **req.headers 获得请求报文**                                 |
| **url.parse(req.url,true).query;获取写在地址上的值**localhost：3000/?name=zhangsan&age=20; |

```javascript
const http = require('http');//引用http模块
const app = http.createServer();//使用http协议创建服务器
app.on('request', (req, res) => {//给服务绑定一个方法名为 request，其参数req、res
  
    //第一个参数是要解析的地址，第二个参数是将其转为对象
   let  {query,pathname} = url.parse(req.url,true).query;
   console.log(req.url);
    
   if(pathname == '/index' || pathname== "/"){//即 url上是: localhost:3000/index或是 localhost:3000
       res.end('欢迎来到inex！');//     
   	   console.log(params.name);//localhost：3000/?name=zhangsan&age=20;
   }
})
app.listen(3000);//该服务器时刻监听着3000这个端口
console.log('3000已经启动');

```

------

### 2.2post请求参数

​	post参数是通过事件的方式接受的，data 当请求参数传递的时候发送data事件，end是参数传递结束时候

data当请求参数传递时，end当参数传递成功时候

```html
<form method="post" action="http://localhost:3000">
        <input type="text" name="username">
        <input type="text" name="password">
        <input type="submit" />
 </form>
```

```javascript
const http = require('http');
const app = http.createServer();
//专门的请求处理参数块内置模块帮助我们
const querystring = require('querystring');

app.on('request', (req, res) => {
    let postParams = '';

    req.on('data', params => {
        postParams += params;
    });
    req.on('end', () => {
        console.log(querystring.parse(postParams));
        console.log(postParams);
    });
    res.end('ok');
});
app.listen(3000);
console.log('3000已经启动');
```

------

### 3、路由总结

1. 路由简单说就是请求什么响应什么，即请求地址和服务器端程序的代码关系。

```javascript
const http = require('http');
const url = require('url');
const app = http.createServer();
app.on('request', (req, res) => {
    //获取请求方式，并将其变为小写
    const method = req.method.toLowerCase();
    //获取请求地址,需要引入模块（req.url是整个url，我们需要请求参数）
    const pathname = url.parse(req.url).pathname; //获取请求地址

    //
    res.writeHead(200, { //则客户端不是乱码
        'content-type': 'text/html;charset=utf8'
    });
    if (method == 'get') {
        if (pathname == '/' || pathname == '/index') {
            res.end('欢迎index！');
        } else if (pathname == '/list') {
            res.end('欢迎list！');
        }

    } else if (method == 'post') {

    }
});
//没有监听端口，便没有外界服务
app.listen(3000);
console.log('服务器启动成功')
```

## 4\静态资源访问:

```javascript
const http = require('http');
const app = http.createServer();
const url = require('url');
const path = require('path');
const fs = require('fs');
const mine = require('mine');
app.on('request', (req, res) => {
    let pathname = url.parse(req.url).pathname;
    let realPath = path.join(__dirname, 'public' + pathname);
    let type = mine.getType(realPath);
    pathname = pathname == '/' ? '/defalut.html' : pathname; //让用户输入'/'也可进入

    fs.readFile(realPath, (error, result) => {
        if (error != null) {
            res.writeHead(404, {
                'content-type': 'text/html;charset=utf8'
            })
            res.end('文件读取失败');
            return;
        }
        res.writeHead(200, {
            //如何根据 请求路径 分析资源路径，通过返回值返回给我？
            'content-type': type
        })
        res.end(result);
    });

});
//没有监听端口，便没有外界服务
app.listen(3000);
console.log('服务器启动成功')

```

















































