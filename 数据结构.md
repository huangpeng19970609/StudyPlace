> 算法面试是什么？
>
> 算法优秀 不等同于 技术优秀
>
> ⭐ 算法面试： 并不是要给出一个正确答案， 而是展示探讨一个问题的解决方案
>
> - 分类练习
>
> - ### 定期回顾和总结
>
> - `数据结构`与`算法` => 明白数据结构才可算法





### 时间复杂度

- 常数操作

  1. 常数操作： 跟数据量无关系，每次都是固定时间完成的操作，称呼常数操作。

     比如 从数组从取值。进行加减乘除便是常数操作

  2. 非 常数操作： 获取链表的某一个值， 只能从前往后，跟数据量有关系。

- 时间复杂度

  1. 比如 有 aN²  + bN + C， 仅取高阶项，且不需要系数， 可称呼为其 O(N²)的复杂度。
  2. 评价算法好坏，先看【时间复杂度】再看【常数项时间】
  
- n 表示数据规模

  O ( f(n) ) 即表示 所表示的执行次数。

  

### 数据结构

#### 1 栈

> 先进后出, 可将数组的尾巴视作栈顶。
>
> 用数组模拟栈，我们仅对栈顶进行操作。故如此如此。

```js
class Stack {
    constructor() {
        this._items = [];
    }
    push(item) {
        this._items.push(item);
    }
    pop(item) {
        return this._items.pop(item)
    }
    peek () { return this._item[this._item.length - 1] }
    size () { return this._item.length }
    clear() { this._item = [] }
}
```

#### 2 队列

> 先进先出
>
> 

```js
class Queue {
    constructor {
        this._items = []
    }
	enqueue (item) {
        this._items.push(item)
    }
	dequeue () {
        return this._items.shift();
    }
	head () {
        return this._items[0]
    }
	tail() {
        return this._items[this._items.length - 1]
    }
	
}
```

#### 3 链表

节点基类

```js
class Node {
    constructor (data) {
        this.data = data;
        this.next = null;
    }
}
```

单链表一般有以下方法

- `append` 在链表尾部添加一个元素
- `insert` 在指定位置插入元素
- `removeAt` 在指定位置删除元素
- `getNode` 获取指定位置的元素
- `print` 打印整个链表
- `indexOf` 查找链表中是否有某个元素，有则返回索引，没有则返回-1

```js
class LinkedList {
    constructor {
        this._head = null;
        this._tail = null;
        this._length = 0;
    }
}
```

此外我们要实现链表的方法

1. append

   - 若链表空节点，则head、tail皆是此节点
   - 若其已由，则更新tail即可

   ```js
   append (data) {
       const newNode = new Node(data);
       // 
       if (this._length === 0) {
           this._head = newNode;
       	this._tail = newNode;
       }
       else {
           this._tail.next = newNode;
           this._tail = newNode;
       }
       this._length += 1;
   }
   ```

2. insert

   - 插入首部
   - 插入尾部
   - 插入中间

   ```js
   insert(index, data) {
       
       if (index === 0) {
           const newNode = new Node(data);
           newNode.next = this._head; 
       	this._head = newNode;
       }
       else if (index === this_.length - 1) {
           this.append(data);
       }
       else {
           const newNode = new Node(data);
           let preTargetNode = this.getNode(index - 1);
           let target = preTargetNode.next;
           preTargetNode.next = newNode;
           newNode.next = target;
       }
       
       this._length++;
   }
   ```

3. getNode

   - 根据指定位置获取节点

   ```js
   getNode (index) {
       let i = 0;
   	let node = this._head;
       while ( i++ < index ) {
      		node = node.next();
       }
       return node;
   }
   ```

4. removeAt

   - 删除头部
   - 删除尾部
   - 其他

   ```js
   removeAt (index) {
       this._head.next;
       if (index === 0) {
           this.head = this._head.next;
       }
       else if (index === this._length - 1) {
       	let preNode = this.getNode(index - 1);
           preNode.next = null;
           this._tail = preNode.next.;
       }
       else {
           let preNode = this.getNode(index - 1);
           let nextNode = this.preNode.next.next;
           if (!nextNode) this._tail = nextNode;
           preNode.next = nextNode;
       }
       this._length -= 1;
   }
   ```

5. indexOf

   - 判断数据是否存在链表中

     ```js
     indexOf (data) {
         let i = 0;
         let node = this._head;
         while (node) {
             if (node.data === data) {
                 return index;
             }
             index+=1;
             node = node.next;
         }
     }
     ```

     

#### 4 集合 Set

> 1. 集合成员是无序的
> 2. 集合表示一组互不相同的元素(不重复的元素)
> 3. 集合以`值-值对`的形式存储元素

```js
class Set {
    constructor {
        this._items = {};
        this._length = 0;
    }
	add (value) {
      if ( this.has(value) ) return false;
      this._items[value] = value;
      this._length += 1;
      return true;
    }
	remove (value) {
        if ( !this.has(value) ) return false;
        delete this._items[value];
        this._length -= 1;
        return true;
    }
	value () { return Object.values(this._items) }
	has () { return Object.hasOwnProperty(value) }
	clear () { this._items = {}; this._lentgh = 0 }
	size() { return this._length }
}
```

##### 4.1 并集

将两个集合中的元素依次添加至新的集合中，并返回改集合

```js
union ( Set ) {
  	const unionSet = new Set();
  	const values = this.values();
  	values.forEach(item => unionSet.add(item));
  	const otherValues = otherSet.values();
  	otherValues.forEach(item => unionSet.add(item));
  	return unionSet;
}
```

##### 4.2 交集

- 以集合A作为参考，遍历集合B依次对比成员，B中的成员存在A中则添加至新集合C中，最后返回C

```js
intersection (otherSet) {
    const intersection = new Set();
    const values = otherSet.values;
	values.forEach(item => {
       if ( this.has(item) ) {
           intersection.add(item);
       } 
    });
    return intersection    
}
```

##### 4.3 差集

```js
// 差集
difference(otherSet) {
  const differenceSet = new Set();

  const values = this.values();
  values.forEach(item => {
    if (!otherSet.has(item)) {
      differenceSet.add(item);
    }
  })

  return differenceSet;
}
```

##### 4.4 子集

- 若其元素皆存在于本集合中代表子集

```js
isSubsetOf (Set) {
    const values = Set.values();
    for (let i = 0; i < values.length; i++) {
        if (  !this.has(values[i]) ) return false;
    }
    return true;
}
```

##### 4.5 ES6的Set

- ES6提供了我们Set，其成员值皆是唯一。

  ```js
  add(value) 添加某个值，返回Set结构本身
  delete(value) 删除某个值，返回一个布尔值，表示删除是否成功
  has(value) 返回一个布尔值，表示该值是否为Set的成员
  clear() 清除所有成员，没有返回值
  size 属性，返回成员总数
  ```

- 使用方式

  ```js
  直接通过数组创建：new Set([1,2,3,4])
  先实例再添加：const set = new Set(); set.add(1);
  ```

- 方法

  ```js
  keys() 返回键名的遍历器
  values() 返回键值的遍历器
  entries() 返回键值对的遍历器
  forEach()/for-of 使用回调函数遍历每个成员
  ```

#### 5 字典 Dictionary

> 1. 在字典中，存储的是`键-值对`，其中键名是用来查询特定元素的
> 2. 字典也称作`映射`

##### 5.1 Dictionary

```js
// 虽然很简单，但也要明白基本的封装思想
class Dictionary {
    construtor () {
        this._table = {}
        this._length = 0;
    }
    set(key, value) {
        if ( !this._has(key) ) this._length++;
        this._tabls[key]  = value;
    }
    has(key) { return this._table.hasOwnProperty(key) }
    remove (key) {
       if (this._table.has(key) {
       		delete this._table[key];
        	this._length--;
        	return true;
       })
       return false;
    }
    keys() { return Object.keys(this._table) }
	values() { return Object.values(this._table) }
    get (key) { return  this._table[key]}
	clear () { this._table = {}; this._length = 0 }
}
```

##### 5.2 ES6的Map

若想希望使用对象作为key，建议直接使用Map结构

```js
set(key, value) // set方法设置键名key对应的键值为value，然后返回整个Map结构
get(key) 		// get方法读取key对应的键值，如果找不到key，返回undefined
delete(value)   // 删除某个值，返回一个布尔值，表示删除是否成功
has(value)      // 返回一个布尔值，表示该值是否为Map的成员
clear()         // 清除所有成员，没有返回值
size 属性，      // 返回成员总数

- `keys()`		       返回键名的遍历器
- `values()` 		   返回键值的遍历器
- `entries()` 		   返回键值对的遍历器
- `forEach()`/`for-of` 使用回调函数遍历每个成员
```

- 创建

  ```js
  直接通过数组创建：
  	const map = new Map([ ['name', '张三'], ['title', 'Author'] ]);
  先实例再添加：
  	const map = new Map();
  ```

#### 6 哈希表/散列表

#### 7 Tree

#### 8 Trie 字典树

#### 9 图



---

### 排序算法

#### 1 冒泡排序

> 冒泡，判断两个相邻元素
>
> 冒泡的本质: 减少了循环，元素还是在一次次的移动。
>
> 最坏情况便是  O(n^2)
>
>  ⭐ 一个完全与我相反的排序为 (n * n - 1) /  2 这不是指循环次数，而是指循环内的 逻辑执行次数

```js
function bubbleSort(arr) {
  const len = arr.length;
  let temp = null;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i; j++) {
      if ( arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  
  }
  return arr;
}
```



#### 2 选择排序

> 复杂度：  O(n²)
>
>  我每次选择最值来进行交换位置。每次在循环中交换极小值

```js
function fastSort(arr) {
  let minIndex, temp;
  for (let i = 0; i < arr.length; i++) {
    minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
  return arr;
}
```

#### 3 插入排序

> **复杂度**：O(n^2) 有序程度越高，越快。数据规模很小即可插入排序即可。
>
> 边插入排序，这是`有序排列`

```js
function insertSort(arr) {
  let len = arr.length;
  let prev, cur;
  // 每一次的插入
  for (let i = 1; i < len; i++) {
    prev = i  - 1
    cur = arr[i];
    // 从小到大
    while ( prev >= 0 && arr[prev] > cur) {
      console.log(arr)
      arr[prev + 1] = arr[prev];
      prev--;
     
    }
    arr[prev + 1] = cur;
  }
  return arr;
}
```



#### 4 希尔排序

> 中等规模的数据10万+
>
> 将数组拆分成不同的间隔，对每个间隔进行插入排序，最后将全部进行一次插入排序
>
> O(n^1.5) 突破了O²的限制！插入排序的改进【分组的插入排序】

```js
function shellSort(arr) {
  let len = arr.length;
  // 10 5 2 1
  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    console.log(gap)
    // 分几组
    for (let i = gap; i < len; i++) {
      let j = i;
      let current = arr[i];
      while(j - gap >= 0 && current < arr[j - gap]) {
        arr[j] = arr[j - gap];
        j = j - gap;
      }
      arr[j] = current;
    }
  }
  return arr;
}
```

#### 5 归并排序

> 将数组拆分成最小单元，进行比较插入
>
> - **复杂度**：O(nlogn)
>
> - **例子**：
>
>   [ 2 4 5 3 1] > [2] [4] [5] [3] [1] > [2 4] [5] [3] [1] > [2 4 5] [3] [1] > [2 3 4 5] [1] > [1 2 3 4 5]



#### 6 快速排序



```js

```

#### 7 计数排序



#### 8 堆排序

#### 9 二分排序法
