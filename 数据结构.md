> 算法面试是什么？
>
> 算法优秀 不等同于 技术优秀
>
> ⭐ 算法面试： 并不是要给出一个正确答案， 而是展示探讨一个问题的解决方案
>
> - 分类练习
>
> - ### 定期回顾和总结
>
> - `数据结构`与`算法` => 明白数据结构才可算法

### 关于ES6

1. 声明展开 与 剩余参数

   - 剩余参数 other 是一个数组，相当于arguments
   -  ES5中我们可以使用apply 为此ES2015便有了扩展运算符

   ```js
   function fn(a, ...other) {
     console.log(other);
   }
   fn(1, 'hello', 'me', {a: 1});
   ```

2. 解构的妙用

   - 你可以利用数组解构去声明多个变量
   - 你可以利用数组形式更便捷的进行变量交换

   ```js
   let [x, y, z] = ['xxxx', 'yyyy', 'zzzz']; // 相当于 let x = 'xxxx'
   [x, y, z] = [z, y, x];
   
   #属性与变量key值相同时的简写也是属于对象解构
   let o  ={ x };
   
   # 简写方法名
   这种方式是声明式的，但由于总是以对象形式去调用故this总会如我们所愿。
   const me = {
       print() {}
   }
   ```

3. 类的属性存取器 => 实际的实现应该是definePeoperty的语法糖吧

   ```js
   class Person {
       constructor (name) {
           this._name = name;
       }
       get name() { return this._name};
       set name(val) { this._name = val; }
   }
   ```

4. 数组方法

   ```js
   # from
   let arr = [1, 2, 3];
   arr2 = Array.from(arr); 等价 arr2 = [...arr]; 
   
   # @@iterator
   返回一个包含数组键值对的迭代器对象
   
   # fill
   你可以用静态值填充数组
   
   # entries、keys、values 获取迭代器
   	# 数组的迭代器 等同values
   	let iterator = arr[ Symbol.iterator ]();
   	# 获取迭代器的值
   	iterator.next.value();
   
   1. entries 获取键与值的迭代器 => 其value为 键与值组成的长度为2的数组
   2. keys     获取键   的迭代器
   3. values   获取值   的迭代器
   ```

   



### 时间复杂度

- 常数操作

  1. 常数操作： 跟数据量无关系，每次都是固定时间完成的操作，称呼常数操作。

     比如 从数组从取值。进行加减乘除便是常数操作

  2. 非 常数操作： 获取链表的某一个值， 只能从前往后，跟数据量有关系。

- 时间复杂度

  1. 比如 有 aN²  + bN + C， 仅取高阶项，且不需要系数， 可称呼为其 O(N²)的复杂度。
  2. 评价算法好坏，先看【时间复杂度】再看【常数项时间】
  
- n 表示数据规模

  O ( f(n) ) 即表示 所表示的执行次数。

  

### 数据结构

#### 1 栈

> 先进后出, 可将数组的尾巴视作栈顶。
>
> 用数组模拟栈，我们仅对栈顶进行操作。故如此如此。

```js
class Stack {
    constructor() {
        this._items = [];
    }
    push(item) {
        this._items.push(item);
    }
    pop(item) {
        return this._items.pop(item)
    }
    peek () { return this._item[this._item.length - 1] }
    size () { return this._item.length }
    clear() { this._item = [] }
}
```

#### 2 队列

> 先进先出 FIFO

```js
class Queue {
    constructor {
        this._items = []
    }
	enqueue (item) {
        this._items.push(item)
    }
	dequeue () {
        return this._items.shift();
    }
	peek () {
        return this._items[0]
    }
	tail() {
        return this._items[this._items.length - 1]
    }
	
}
```

##### 双端队列

> 同时从前端和后端添加与移除的队列
>
> 即 同时遵守 先进先出与 后进先出。
>
> 双端队列： 队列 + 栈

```js
# 用数组实现更简单，不过书上给与的对象实现
class Deque {
    constructor () {
        // 控制队列的大小
        this.count = 0;
        // 追踪第一个元素
        this.lowestCount = 0;
        this.items = {};
    }
    addFront( element ) {
        if (this.isEmpty() ) this.addBack(element);
        else if (this.lowestCount > 0) {
            this.lowestCount--;
            this.items[this.lowestCount] = element;
        }
        // lowestCount为0 我们必须腾出第一位的位置
        else {
            for (let i = this.count; i > 0; i--) {
                this.items[i] = this.items[i - 1]
            }
            this.count++;
            this.lowerCount = 0;
            this._items[0] = element;
        }
    }
    // 向后加
    addBack(element) {
        this.items[this.count] = element;
        this.count++;
    }
    removeFront() {
        let result =  this.items[this.lowestCount];
        delete this.items[this.lowestCount]
        this.lowestCount++;
        return result;
    }
    removeBack() {}
}
```



#### 3 链表

链表的好处: 添加与移动不需要移动其他元素



节点基类

```js
class Node {
    constructor (data) {
        this.data = data;
        this.next = null;
    }
}
```

单链表一般有以下方法

- `append` 在链表尾部添加一个元素
- `insert` 在指定位置插入元素
- `removeAt` 在指定位置删除元素
- `getNode` 获取指定位置的元素
- `print` 打印整个链表
- `indexOf` 查找链表中是否有某个元素，有则返回索引，没有则返回-1

```js
class LinkedList {
    constructor {
        this._head = null;
        this._tail = null;
        this._length = 0;
    }
}
```

此外我们要实现链表的方法

1. append

   - 若链表空节点，则head、tail皆是此节点
   - 若其已由，则更新tail即可

   ```js
   append (data) {
       const newNode = new Node(data);
       // 
       if (this._length === 0) {
           this._head = newNode;
       	this._tail = newNode;
       }
       else {
           this._tail.next = newNode;
           this._tail = newNode;
       }
       this._length += 1;
   }
   ```

2. insert

   - 插入首部
   - 插入尾部
   - 插入中间

   ```js
   insert(index, data) {
       
       if (index === 0) {
           const newNode = new Node(data);
           newNode.next = this._head; 
       	this._head = newNode;
       }
       else if (index === this_.length - 1) {
           this.append(data);
       }
       else {
           const newNode = new Node(data);
           let preTargetNode = this.getNode(index - 1);
           let target = preTargetNode.next;
           preTargetNode.next = newNode;
           newNode.next = target;
       }
       
       this._length++;
   }
   ```

3. getNode

   - 根据指定位置获取节点

   ```js
   getNode (index) {
       let i = 0;
   	let node = this._head;
       while ( i++ < index ) {
      		node = node.next();
       }
       return node;
   }
   ```

4. removeAt

   - 删除头部
   - 删除尾部
   - 其他

   ```js
   removeAt (index) {
       this._head.next;
       if (index === 0) {
           this.head = this._head.next;
       }
       else if (index === this._length - 1) {
       	let preNode = this.getNode(index - 1);
           preNode.next = null;
           this._tail = preNode.next.;
       }
       else {
           let preNode = this.getNode(index - 1);
           let nextNode = this.preNode.next.next;
           if (!nextNode) this._tail = nextNode;
           preNode.next = nextNode;
       }
       this._length -= 1;
   }
   ```

5. indexOf

   - 判断数据是否存在链表中

     ```js
     indexOf (data) {
         let i = 0;
         let node = this._head;
         while (node) {
             if (node.data === data) {
                 return index;
             }
             index+=1;
             node = node.next;
         }
     }
     ```


##### 3.1 双向链表

- 普通的链表其一个节点只有链向下一个节点的链接

- 而双向链表，如图所示

- head的prev 与 tail的next都是一个 null 或者 undefined 之类的

  <img src="images/image-20211023201729226.png" alt="image-20211023201729226" style="zoom:67%;" />

  <img src="images/image-20211023210749168.png" alt="image-20211023210749168" style="zoom: 80%;" />

```js
class DoubleNode extends Node {
    constructor(element, next, prev) {
        super(element, next);
        this.prev = prev;
    }
}
class DoubleLinkedList extends LinkedList {
    constructor () {
        // tail 是最后一个节点的next
        this.tail = undefined;
    }
    # 重写插入
    insert( element, index ) {
        if (index < 0 || index > this.count) return false;
        const node = new DoubleNode(element);
        // 首
        if (index === 0) {
            // 若为空链表
            if (this.head === null) {
                this.head = node;
                this.tail = node;
            }
            else {
                node.next = this.head;
                this.head.prev = node;
                this.head = node;
                
            }
        }
        // 尾
        else if ( index === this.count ){
            this.tail.next = node;
            node.prev = this.tail;
            this.tail = node;
        }
        // 中间
        else {
            const prevNode = this.getElementAt( index - 1);
            const nextNode = prev.next;
            node.next = nextNode;
            node.prev = prevNode;
            prevNode.next = node;
            nextNode.prev = node;            
        }
        this.count++;
        return true;
    }
	# 双向链表删除 => 与单向链表很相似
    removeAt (index) {
        if (index < 0 || index > count) return false;
        // 标识要删除的元素以返回
        let curNode;
        if (index === 0) {
            curNode = this.head;
            this.head = this.head.next;
            // 如果只有一项 更新tail 双链表额外处理此步
            if (this.count === 1) {
                this.tail = undefined; 
            }
            else {
                this.head.prev = undefined; // 双链表额外处理此步
            }
        }
        else if (index === count - 1) {
            curNode = this.tail;
            this.tail = this.tail.prev;
            this.tail.next = undefined;
        }
        else {
            curNode = this.getElementAt (index);
            const preNode = curNode.prev();
            preNode.next = curNode.next.next();
            preNode.next.prev = preNode; 
        }
        this.count--;
        return curNode.element;
    }
}
```



#### 4 集合 Set

> 1. 是无序
> 2. 项唯一
> 3. 你可以视作其 有数学中 有限集合的 概念

```js
class Set {
    constructor {
        this._items = {};
        this._length = 0;
    }
	add (value) {
      if ( this.has(value) ) return false;
      this._items[value] = value;
      this._length += 1;
      return true;
    }
	remove (value) {
        if ( !this.has(value) ) return false;
        delete this._items[value];
        this._length -= 1;
        return true;
    }
	value () { return Object.values(this._items) }
	has () { return Object.hasOwnProperty(value) }
	clear () { this._items = {}; this._lentgh = 0 }
	size() { return this._length }
}
```

##### 4.1 并集

将两个集合中的元素依次添加至新的集合中，并返回改集合

```js
union ( Set ) {
  	const unionSet = new Set();
  	const values = this.values();
  	values.forEach(item => unionSet.add(item));
  	const otherValues = otherSet.values();
  	otherValues.forEach(item => unionSet.add(item));
  	return unionSet;
}
```

##### 4.2 交集

- 以集合A作为参考，遍历集合B依次对比成员，B中的成员存在A中则添加至新集合C中，最后返回C

```js
intersection (otherSet) {
    const intersection = new Set();
    const values = otherSet.values;
	values.forEach(item => {
       if ( this.has(item) ) {
           intersection.add(item);
       } 
    });
    return intersection    
}
```

##### 4.3 差集

```js
// 差集
difference(otherSet) {
  const differenceSet = new Set();

  const values = this.values();
  values.forEach(item => {
    if (!otherSet.has(item)) {
      differenceSet.add(item);
    }
  })

  return differenceSet;
}
```

##### 4.4 子集

- 若其元素皆存在于本集合中代表子集

```js
isSubsetOf (Set) {
    const values = Set.values();
    for (let i = 0; i < values.length; i++) {
        if (  !this.has(values[i]) ) return false;
    }
    return true;
}
```

##### 4.5 ES6的Set

- ES6提供了我们Set，其成员值皆是唯一。

  ```js
  add(value) 添加某个值，返回Set结构本身
  delete(value) 删除某个值，返回一个布尔值，表示删除是否成功
  has(value) 返回一个布尔值，表示该值是否为Set的成员
  clear() 清除所有成员，没有返回值
  size 属性，返回成员总数
  ```

- 使用方式

  ```js
  直接通过数组创建：new Set([1,2,3,4])
  先实例再添加：const set = new Set(); set.add(1);
  ```

- 方法

  ```js
  keys() 返回键名的 迭代器
  values() 返回键值的 迭代器
  entries() 返回键值对的 迭代器
  forEach()/for-of 使用回调函数遍历每个成员
  ```
  
- 集合计算

  1. 并集

     ````js
     new Set([...set1, ...set2])
     ````

  2. 交集

     ````js
     new Set([...setA].filter(x => setB.has(x)))
     ````

  3. 差集

     ```js
     new Set([...setA].filter(x => !setB.has(x)))
     ```

  





#### 5 字典 Dictionary

> 1. 在字典中，存储的是`键-值对`，其中键名是用来查询特定元素的
>
> 2. 字典也称作`映射`
>
> 3. 集合 以 【值-值】形式，字典以【键-值】形式
>
> 4. chrome控制台中 memory标签的快照功能你便可以看到其对象的引用地址
>
>    字典往往也是用作与保存对象的引用地址的

##### 5.1 Dictionary

```js
// 虽然很简单，但也要明白基本的封装思想
class Dictionary {
    construtor () {
        this._table = {}
        this._length = 0;
    }
    set(key, value) {
        if ( !this._has(key) ) this._length++;
        this._tabls[key]  = value;
    }
    has(key) { return this._table.hasOwnProperty(key) }
    remove (key) {
       if (this._table.has(key) {
       		delete this._table[key];
        	this._length--;
        	return true;
       })
       return false;
    }
    keys() { return Object.keys(this._table) }
	values() { return Object.values(this._table) }
    get (key) { return  this._table[key]}
	clear () { this._table = {}; this._length = 0 }
	key

}
```

##### 5.2 ES6的Map

若想希望使用对象作为key，建议直接使用Map结构

```js
set(key, value) // set方法设置键名key对应的键值为value，然后返回整个Map结构
get(key) 		// get方法读取key对应的键值，如果找不到key，返回undefined
delete(value)   // 删除某个值，返回一个布尔值，表示删除是否成功
has(value)      // 返回一个布尔值，表示该值是否为Map的成员
clear()         // 清除所有成员，没有返回值
size 属性，      // 返回成员总数

- `keys()`		       返回键名的遍历器
- `values()` 		   返回键值的遍历器
- `entries()` 		   返回键值对的遍历器
- `forEach()`/`for-of` 使用回调函数遍历每个成员
```

- 创建

  ```js
  直接通过数组创建：
  	const map = new Map([ ['name', '张三'], ['title', 'Author'] ]);
  先实例再添加：
  	const map = new Map();
  ```

#### 6 哈希表/散列表

> 散列表 你也可以称呼其为哈希表。 我们也会称呼其为HashTable类、HashMap类
>
> 是Dictionary类的一种散列表实现方式。
>
> 那么什么是【散列表/ 哈希表】 呢？

- 散列算法

  尽可能快地在数据结构之中找到一个值。散列函数便是给定一个键值，从而返回值的表中的地址。

  `js中的对象是基于哈希表结构的`

- defaultToString

  ```js
  function defaultToString(item) {
      if (item === null) return 'NULL'
      else if (item === undefined) return UNDEFINED
      else if (typeof item === 'string' || item instanceof String) return `${item}`
      return item.toString;
  }
  ```

- 散列函数 

  我们应该明白散列函数

  ```js
  loseHashCode (key) {
      if (typeof key === 'number') return key;
      const tableKey = this.toStrFn(key);
      let hash = 0;
      for (let i =0; i < tableKey.length; i++) {
          // charCodeAt返回Unicode编码值
          hash += tableKey[i].charCodeAt(i);
      }
      return hash % 37
  }
  // 我们取得散列表的名字太长 且为了更好的维护我们可以映射一层
  hasCode(key) {
      return this.loseHashCode(key);
  }
  ```

  > 不得不强调的是
  >
  > HashMap与Dicitionary类相似，不同之处在于哈希表/ 散列表中，
  >
  > 我们将key（hash）生成一个数， 并将valuePair保存在hash属性上。

- 创建散列表

  ```js
  # 虽然直接通过对象方式是可以创建的， 但依照封装准则，应该使用节点创建。
  class ValuePair {
      constructor (key, value) {
          this.key = key;
          this.value = value;
      }
      toString () {
          return `[${this.key} :${this.value}]`
      }
  }
  
  class HashTable {
      constructor {
          this.table = {}
      }
  	# 散列函数
  	// 更新散列表 我觉得是可以放置 不存在的值的
  	put (key, value) {
      	this.table[ this.hasCode[key] ] = new ValuePair( key, value );
          return true;
      }
  	get(key) {
         	const valuePair = this.table[ this.hasCode(key) ];
      	return valuePair ? undefined : valuePair.value;
      }
  	remove (key) { 
      	const hash = this.hasCode(key);
          const valuePair = this.table[hash];
          if (!valuePair) return false;
          else {
              delete this.table[hash];
              return true;
          }
      }
  }
  ```

<img src="images/image-20211024114806911.png" alt="image-20211024114806911" style="zoom:80%;" />

> 目前以我们此种方式去创建希望会出现 hash重复的情况，这是本就不该出现的事情。
>
> 例如 【Sue】、【Jamie】其哈希值便是重复的。

##### 6.1 解决冲突 分离链接

- 解决冲突最简单的方法
-  为散列表的每一个位置`创建链表`将元素存储在里面 => 额外的存储空间

​	<img src="images/image-20211024120433337.png" alt="image-20211024120433337" style="zoom: 67%;" />

```js
# 重写put、get、remove
class HashTableSeparateChaining {
    constructor() {
        this.table = {}
    }
}
put (key, value) {
    if (!key || !value) return false;
    const position = this.hasCode(key);
    if ( !this.table[position] ) {
        this.table[position] = new LinkedList();
    }
    this.table[position].push(new ValuePair(key, value));
    return true;
}
// 与链表get同理
get (key) {
	
}
```



##### 6.2 解决冲突-线性探查

##### 6.3 创建更好的散列函数

- 我们实现的并非是一个良好的散列函数，因为易诞生冲突。

- 更好的散列函数. 这并非是性能最好的，但他是社区最喜爱的散列函数！

  ```js
  djb2HashCode(key) {
      const tableKey = this.toStrFn(key);
      let hash = 5381; // 幻数 指 在编程中直接使用的常熟
      for (let i = 0; i < tableKey.length; i++) {
          hash = (hash * 33) + tableKey.charCodeAt(i);
      }
      return hash % 1013;
  }
  ```

  

##### 6.4 ES2015 Map类

> ES2015新增了Map类，可视作Dictionary

#### 7 Tree

##### 7.1 基本概念

1. 根节点
2. 内部节点： 存在至少一个子节点
3. 叶节点（外部节点）： 没有子元素的节点
4. 节点深度： 一个节点具有的属性，取决于它祖先节点的深度
5. 树的高度： 对于树来说，节点深度的最大值。或者你可以认为 根节点位于高度为0的位置。

##### 7.2 二叉搜索树

> 参考：　https://zhuanlan.zhihu.com/p/109535355

- 二叉树： 节点最多只有两个子节点。 二叉树在 计算机科学中应用非常广泛。

- 二叉搜索树（**BST**）

  1. 左侧节点存储值小（比父节点）
  2. 右侧节点存储值大（比父节点）
  3. 使用 指针（引用）表示节点关系。⭐ 在Tree中术语称呼其为【**边**】
  4. 二叉搜索树类似于双向链表。⭐ 在Tree中术语，我们称呼节点为【**键**】

  <img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20211024171735166.png" alt="image-20211024171735166" style="zoom: 67%;" />

##### 7.３实现一个二叉搜索树

1. insert: 从树中插键
2. search: 从树中查键
3. preOrderTraverse: 先序遍历方式 => 根节点 为 【先】
4. inOrderTraverse: 中序遍历方式 => 根节点为 【中】
5. postOrderTraverse: 后序遍历方式 => 根节点 为 【后】
6. min： 返回最小键
7. max： 返回最大键
8. remove： 从树中移除某键

##### 7.4 insert

```ts
class treeNode {
  key: number;
  left: Node | null;
  right: Node | null
  constructor (key: number) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}
class BinarySearchTree {
  root: treeNode;
  constructor() {
    this.root = null;
  }
  insert(key: any) {
    if (!this.root) {
      return this.root = new treeNode(key);
    }else {
      this.insertNode(this.root, key);
    }
  }
  insertNode(node, key) {
    if (key < node.key) {
      if (!node.left) node.left = new treeNode(key);
      else this.insertNode(node.left, key);
    }
    else {
      if (!node.right) node.right = new treeNode(key);
      else this.insertNode(node.right, key);
    }
  }
}
```

##### 7.5 遍历

###### 7.5.1 inOrderTraverse

- 上行顺序访问BST所有节点的遍历方式， 通俗点说从小到大
- 访问者模式 => 一种设计模式
- 你应当使用 【栈】的方式去理解递归

```js
inOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback);
}
inOrderTraverseNode(node, callBack) {
    # 递归实现 => node 作为 递归基线（停止递归继续执行的条件） 
    if (node) {
        // 左
        this.inOrderTraverseNode(node.left, callBack);
        // 中
        callBack(node.key);
        // 右
        this.inOrderTraverseNode(node.right, callBack);
    }
}

# 测试
const printNode = (value) => { console.log(value) }
bst.inOrderTraverse(printNode);
```

###### 7.5.2 preOrderTraverse

- 先序遍历  => 重在结构 =>  中 左 右
- 访问者模式

```js
preOrderTraverse ( callBack ) {
    this.preOrderTraverseNode(this.root, callBack);
}
preOrderTraverseNode(node, callback) {
    callback(node);
    preOrderTraverseNode(node.left, callback);
    preOrderTraverseNode(node.right, callback);
}
```

###### 7.5.3 后序排序

```js
inOrderTraverse ( callBack ) {
    this.preOrderTraverseNode(this.root, callBack);
}
inOrderTraverseNode(node, callback) {
    preOrderTraverseNode(node.left, callback);
    callback(node);
    preOrderTraverseNode(node.right, callback);
}
```

##### 7.6  搜索树的值（search）

- 搜索最小值
- 搜索最大值
- 搜索特定值







#### 8 Trie 字典树





#### 9 图







---

### 排序算法

#### 1 冒泡排序

> 冒泡，判断两个相邻元素
>
> 冒泡的本质: 减少了循环，元素还是在一次次的移动。
>
> 最坏情况便是  O(n^2)
>
>  ⭐ 一个完全与我相反的排序为 (n * n - 1) /  2 这不是指循环次数，而是指循环内的 逻辑执行次数

```js
function bubbleSort(arr) {
  const len = arr.length;
  let temp = null;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i; j++) {
      if ( arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  
  }
  return arr;
}
```



#### 2 选择排序

> 复杂度：  O(n²)
>
>  我每次选择最值来进行交换位置。每次在循环中交换极小值

```js
function fastSort(arr) {
  let minIndex, temp;
  for (let i = 0; i < arr.length; i++) {
    minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
  return arr;
}
```

#### 3 插入排序

> **复杂度**：O(n^2) 有序程度越高，越快。数据规模很小即可插入排序即可。
>
> 边插入排序，这是`有序排列`

```js
function insertSort(arr) {
  let len = arr.length;
  let prev, cur;
  // 每一次的插入
  for (let i = 1; i < len; i++) {
    prev = i  - 1
    cur = arr[i];
    // 从小到大
    while ( prev >= 0 && arr[prev] > cur) {
      console.log(arr)
      arr[prev + 1] = arr[prev];
      prev--;
     
    }
    arr[prev + 1] = cur;
  }
  return arr;
}
```



#### 4 希尔排序

> 中等规模的数据10万+
>
> 将数组拆分成不同的间隔，对每个间隔进行插入排序，最后将全部进行一次插入排序
>
> O(n^1.5) 突破了O²的限制！插入排序的改进【分组的插入排序】

```js
function shellSort(arr) {
  let len = arr.length;
  // 10 5 2 1
  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    console.log(gap)
    // 分几组
    for (let i = gap; i < len; i++) {
      let j = i;
      let current = arr[i];
      while(j - gap >= 0 && current < arr[j - gap]) {
        arr[j] = arr[j - gap];
        j = j - gap;
      }
      arr[j] = current;
    }
  }
  return arr;
}
```

#### 5 归并排序

> 将数组拆分成最小单元，进行比较插入
>
> - **复杂度**：O(nlogn)
>
> - **例子**：
>
>   [ 2 4 5 3 1] > [2] [4] [5] [3] [1] > [2 4] [5] [3] [1] > [2 4 5] [3] [1] > [2 3 4 5] [1] > [1 2 3 4 5]



#### 6 快速排序



```js

```

#### 7 计数排序



#### 8 堆排序

#### 9 二分排序法





### 递归

> 在学习树、图之前，我们需要学会递归。
>
> *要理解递归，首先要理解递归* ——佚名

#### 1 递归

- 调用栈

  ❗ 忘记停止函数递归 将会导致 ` ❌ 栈溢出错误(stack overflow error)`

  我们可以利用控制台观看。 【Source】标签页并打断点。

  1. 当函数被一个算法（函数）调用时函数便会进入【调用栈】的顶部。

     每个函数调用时都会堆叠在调用栈的顶部。

     原因： 每一个调用都可能依赖前一个调用的结果。

     <img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20211024154842612.png" alt="image-20211024154842612" style="zoom: 67%;" />

  2. 当然你可以使用 console.trace去追踪 栈的调用轨迹

<img src="images/image-20211024153203103.png" alt="image-20211024153203103" style="zoom:67%;" />

#### 2 为什么要用递归？

- 那更快吗？ 显然是不如迭代的
- 更易于理解，解决问题更加简单。

### 其他算法

#### 斐波那契数列

> 斐波那契数列 前两项为 0， 1 【我们总是如此约定俗成】,    此后每项便是第一项 与 第二项的值

```ts
let arr: number[] = new Array(20);
arr[0] = 1;
arr[1] = 2;
for (let i = 2; i < arr.length; i++) {
  arr[i] = arr[i - 1] + arr[ i - 2]; 
}

# 递归形式
function fibonacci(n) {
    if (n < 1) return 0;
    if (n < 2) return 1;
    return fibonacci(n - 1) * fibonacci(n - 2)
}
```

#### 数组的unshift的逻辑

```ts
Array.prototype.insertStartPosition = function (value) {
  for (let i = this.length; i > 0; i--) {
    this[i] = this[i - 1];
  }
  this[0] = value;
}
```



