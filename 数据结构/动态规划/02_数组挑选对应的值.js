/* 
  给你一个数组， 从数组中挑选任意个数， 以 组成目标值
  如 [3, 34, 4, 12, 5 ,2] 是否存在N个元素相加为9的情况？
*/

/* 
  subset(i, s);
  i = 5, s = 9的时候如何分配?
  
                        subset(arr[5], 9)
      subset(arr[4], 7)                 subset(arr[4], 9)
  

  出口在哪里？   
    1. subset[arr[2], 0] 时
        s为0的时候 即 返回 true     =>  s === 0
    2. subset[arr[0], 3] 
       即 i === 0 时, arr[0] === 3 =>  arr[0] === s
    3. subset[arr[2], 9]
       arr[2] 为 12, 不可能选 arr[2] => arr[i] > s => return suset(arr, i - 1, s);
      考虑 【不选中arr[2]】的情况
    4. 选 suset(arr, i - 1, s - arr[i])
       不选 suset(arr, i - 1, s)
       return A || B
*/

// ------------------------------
// 递归实现

// ------------------------------

/*           s   0   1   2   3   4   5   6   7   8   9 
 arr   index    
  3      0                   1 
  34     1       1   ->
  4      2       1   ->
  12     3       1   ->
  5      4       1   ->
  2      5       1   ->


  1. 我们称呼这个二维数组 为 subset数组
  2. 举个例子, 二维数组代表了什么
     arr[2][3] => subset(2, 3),      即subset(2) 可不可以凑成3, 4
                                     即subset(1) 可不可以凑成3, 34
                                     即subset(0) 可不可以凑成3, 3
                                     故 subset(2, 3), subset(1, 3) subset(0, 3) 都可以凑成3
     ⭐ 站在二维的角度上看, 这便是代表 i - 1是不是可以的，即往上看
  3. 请记住我们的结论
    i = 0, arr[0] = 3 且 s = 3 时, 为 true 
                                     */
// 非递归 => 二维数组保存中间所有 子问题
