## 01 | 标准引用

### 类型

- ECMAScript 语言类型

  1. ECMAScript 语言类型 是 ECMAScript 程序员使用 ECMAScript 语言直接操作的值对应的类型。

  2. ECMAScript 语言类型包括 未定义 （Undefined）、 空值 （Null）、 布尔值（Boolean）、 字符串 （String）、 数值 （Number）、 对象 （Object）

-  规范类型

  1. 规范类型包括 `引用` 、 列表 、 完结 、 属性描述式 、 属性标示 、

     `词法环境`（Lexical Environment）、 环境纪录（Environment Record）

  2. 这些值不能存成对象的变量或是 ECMAScript 语言变量的值

### 规范类型的引用类型

- 描述 【delete】、【typeof】、【赋值运算符】的行为
- 结构
  1. base
  2. referencedName 引用名称
  3. 严格引用标识  （ use strict）

### 左值与右值

- 左值  【表达式返回一个标准引用】 

  1. delete x， 这类运算符时

  2. typeof x， type运算符时

  3. 属性存取符 obj.x 

  4. 属性赋值符 x = 1

  5. 单值表达式 （一般叫做变量名） 例如 【x】 是一个引用

     例如 delete x中的x 是单值表达式

     x = x 中的左x 是单值表达式

     而 obj.x 中的 x 是标识符， 其不是单值表达式，其通过 . 运算符

     具体应看语句。

- 右值  【表达式返回一个值（GetValue）】

- 例子

  ```js
  x = x; // ref = GetValue(ref)
  
  var x = x // 不涉及 左值与右值。 仅是简单的初始化在内存操作
  
  # 为何会改变this呢 => 因为 右值赋予了 左值
  obj = { f: function() { return this === obj } };
  (a = obj.f)();
  
  # 例子
  
  
  ```

### x = obj.foo

1. 右操作是`obj.foo`，它的引用是obj.foo整体，这包括“obj这个对象”的信息——这称为“引用（规范类型）”；
2. 右侧表达式的值是GetValue(obj.foo)
3. `x = obj.foo` 其结果是`x`变成了函数foo，那么它就是右侧操作数的“值”，而不是右操作数“obj.foo”的全部信息
4. (obj.foo) 此时强行运算得到的是 其 引用

````js
obj = {
    foo() {
        console.log(this === obj)
    }
}
# 分组运算得到了操作数的“引用（全部的信息） [这一对括号称为“分组运算符（也有称着强制运算符的）”]
(obj.foo)(); // true => 
x = obj.foo; x(); // false
````

### delete

> delete 操作语句 是`删除一个表达式、引用类型的结果`

- 若 x 不存在会怎么样？

  delete x、typeof x 而 左值计算，并不会进行GetValue

  但 console.log(x) 却会报错， 其原因是 右值操作， 进行 GetValue

## 02 | 词法声明

var x = y = 100： 声明语句与语法改变了JavaScript语言核心性质

### 6种声明方式

⭐ 声明的共性： var let const 仅是这三种

> 这些声明方式的意义 => JS的静态语义
>
> - 通过静态分析可以发现那些声明的标识符
> - 标识符的 变量/常量 一定在代码执行前已在作用域

1. let ： 声明变量 x。不可在赋值之前读。

   - 访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为这个标识符被拒绝访问了

2. const

3. var： 

   在赋值之前可读取到 undefined 值。

4. function x

    声明变量 x。该变量指向一个函数。

   函数是按 `varDecls 的规则`声明的

5. class x

   声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的.

   类的内部是处于严格模式中，它的`名字是按 let `来处理的

6. import

   入标识符并作为常量（可以有多种声明标识符的模式和方法）

   import 导入的名字则是按 `const `的规则来处理的

关于 let、const

1. var：

   “变量声明（varDelcs）”

   JavaScript 是允许访问还没有绑定值的var所声明的标识符的。

   - 原因

     JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值.

     

2. let、const

   “词法声明（lexicalDecls）”

   JavaScript 拒绝访问还没有绑定值的let/const标识符而已。

### 环境

- 现在的 JavaScript 环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的

- 变量名列表（varNames）

  1. ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames）
  2. 所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中
  3. 这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除

  ```js
  var a = 100; delete a; 不可删除
  
  x = 200; delete x; 可以删除 => 因为 其没有被 var 声明
  
  eval('var b = 300'); 可以删除 （eval真正实现的特别之处还是可以删除的）
  ```

### var x = y = 100

- y = 100 声明了一个全局变量 y， 
  1. y 可以供删除。
  2. y = 100 其是一个表达式，其返回结果为 100
- x = 100 
  1. 此 【100】是 y = 100 表达式的返回值
  2. 且因为 var x = 100 故是初始绑定， 不涉及左右赋值

### 思考题: 严格来说， 为何声明不是语句?

1. 声明发生编译期
   - 这是js静态化的特性的体现
   - 维护变量表
2. 语句发生在执行期。
3. 若声明的时候全都没有初始化，那 编译器就可以完全执行。

### 别人的疑问

1. 为什么有这种结果

   - 函数创建的时候标识符x和y就被创建了

   - 编译期时无论是let、var 其都被加入了变量名列表中

   - 在前的环境上下文有【y】, 且是用 var 声明的， 故打印为 undefined

     let x 由于缺省值，直接抛出异常（词法环境）

   - 函数实例、函数闭包，都不过是“静态词法解析结果

   ````js
   var y = "outer";
   
   function f() {
   	console.log(y); // undefined
   
   	console.log(x); // throw a Exception
   
   	let x = 100;
   
   	var y = 100;
   	...
   }
   f()
   ````

   

2.  编译阶段

   按道理来说编译阶段 会 发现 b 吗？

   - 如果“创建”是指静态语义中的一个“函数”，那么确实是创建了的。

     ⭐——但它还没有“绑定”到一个闭包的执行上下文中

   ````js
   function a() {
   	function b() {}
   }
   ````

   

## 03 | 表达式的运算

> 我们常说的表达式的运算是从左至右计算的。
>
> 但运算符的顺序并不是从左至右。比如”=“，加减乘除

### 引言

```js
var a = {n:1};
a.x = a = {n:2};
alert(a.x); // --> undefined
```

1. 语法静态分析也不许你这样做

   var a.x 是错误的原因是 若在声明语句， 等于号左边不能是表达式，而此时 a.x反而是一个表达式故报错
   
2.  左侧的 a 仅是一个表达名字、静态语法分析期作为标识符来理解的字面文本

### 表达式 w = x + y * z

> 您需要关注“变量作为表达式是什么，以及这样的表达式如何求值（以得到变量）”

- 第一个计算顺序的例子

  ````js
  w = x + y * z
  ````

  先计算子表达式w 再计算 x、y、z， 之后 y * z 再加 x，再将其值给表达式 w 所指 的 变量或属性

- 第二个计算顺序的例子

  ````js
  b * c
  ````

  1. 将b理解为单值表达式，求值并得到GetValue(evalute('b'))；

  2. 将c理解为单值表达式，求值并得到GetValue(evalute('c'))；

  3. 将上述两个值理解为求积表达式’*'的两个操作数

     ````js
     evalute('*', GetValue(evalute('b')), GetValue(evalute('c')))
     ````
     
  4. 其他解释

     - b和c在表达式计算过程中都并不简单的是“一个变量”而是而是“一个单值表达式的计算结果”
     - 变量作为表达式是什么呢？
     - 进而这样的表达式如何求值（以得到变量） => 即 GetValue的结果

- 第三个计算顺序的例子

  ````js
  var x = y = 100;
  
  a.x = a = { n: 2 }
  ````

  - 表达式

    1. 第一行的 x 是 标识符， y 是 表达式， 100 是表达式。 y = 100 是赋值表达式。
    2. 第二行 a.x 是表达式， a = { n : 2 } 是赋值表达式， a、{ n = 2 } 当然也是表达式

  - 您应该区分出来

    1. 第一行仅一次赋值表达式运算外加一次值绑定操作。
    2. 第二行才是连续两次的赋值表达式。

  - 第二行

    `表达式 总是从左 至 右的` 计算逻辑另说。

    1. a.x 
       - 计算单值表达式a， 获取a的引用
       - ”.“运算的右操作数，遇到右侧的x理解为一个标识符。
       - 计算a.x 的表达式结果。得a.x是引用。

### x = y = 100

> 这是一个连续赋值表达式

1. x 应被看作是一个表达式。它被严格地称为“赋值表达式的左手端（lhs）操作数”

2. 这是一个连续赋值表达式

3.  其他

   ````js
   var x = y = 100;
   ````

   1. 这不是一个连续赋值的表达式， 
      - 因为 有 “var 声明”的左边这是一个被称作初始器（Initializer）”的语法组件
      - var x = xxx 这是被绑定了一个值

### a.x = a = { n: 2 }

> 这是一个连续赋值表达式

````js
var a = { n: 1 }
a.x = a = { n: 2 }
#1
a.x = a 
````

1. 至左到右

   a.x 是一个引用， 其引用保存计算过程的信息，其中就包括 a， 以备后续的this来使用。

   ```js
   a = {
       n: 1
   }
   ```

2. a = { n : 2 }

   - 覆盖原始变量a， 这将导致一个新的变量 a 的出现， 并覆盖掉原有的a
   - 但最左侧的 a.x 是我们最开始的计算，其中有a。
     1. 引用传递的过程中，最左侧计算过程信息的a丢失，同时 a.x 也被丢失
     2. 导致 第二次 a.x 毫无意义。因为变量 a 已被丢失。

   但由于 a.x 表达式结果 result 其是一个引用，且其保存了a。

   故此时这个a。这个结果也非常的符合预期。

   ```js
   # 我们单纯看最左侧的 a.x计算过程信息的 【a】
   a = {
       n: 1,
       x: {
           n: 2
       }
   }
   # 但最终 undefined的原因 是因为 a 在从左至右的计算过程中， a 在引用传递丢失了，故此a被丢弃
   # 这在下一行打印语句便可以体现出来。
   ```

   > “a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。
   >
   > ⭐ a 即便是被废弃掉了也可以执行下去。
   >
   > 在第二次赋值后，因为“变量a过去的值”那个对象已经不再被任何变量持有，所以它已经无法被访问到了，它“跑丢了”。

- 总结

  简单来说 就是ref的a跑丢了，但赋值也不会报错。
  
  

关于一些细节

1. a.x = ...，那么它就是作为“引用”来使用，这样就可以访问到`x`这个属性，并置值；
2. a.x 如果它在后续运算中被作为rhs，例如console.log(a.x)，那么它就会被GetValue()取值（并作为值来使用）
3. a.x整体被作为“一个操作数”，它的用法与它被使用的位置是有关的。但是“得到它（亦即是对a.x这个表达式求Result）”的过程并没有什么不同。

#### 答案

```js
var a = {n:1};
a.x = a = { n: 2}
```

- 有一个新的a产生，它覆盖了原始的变量a，它的值是{n:2}；

- 最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。

  但他们确实曾经存在过。

  1. 第二次赋值操作“a.x = …”实际是无意义的， 因为被丢弃
  2. 但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量a”，那么上面的代码的影响仍然是可见的

  ```js
  {
    x: {n: 2},  // <- 第一次赋值“a = {n:2}”的结果
    n: 1
  }
  ```

- 来持有原始的 a 以至于 让他不丢弃吧

  ```js
  var a = {n:1}, ref = a;
  a.x = a = {n:2};
  
  console.log(a.x); // --> undefined
  console.log(ref.x); // {n:2}
  ```

#### 连续两次赋值有什么作用？

```js
elemData = {}
...
elemData.events = elemData = function(){};
elemData.events  = {};
```

既然 我们知道 这样是毫无意义的事情， 为什么他是还要如此的做？

`意味着给旧的变量添加一个指向新变量的属性`

```js
# 一个链表是可以像下面这样来创建的
var i = 10, root = {index: "NONE"}, node = root;

// 创建链表
while (i > 0) {
  node.next = node = {};
  node.index = i--;  // 这里可以开始给新node添加成员
}

// 测试
node = root;
while (node = node.next) {
  console.log(node.index);
}
```



## 04 | 函数表达式、函数定义

>  export default function() {}：你无法导出一个匿名函数表达式

### export

JavaScript 语言的设计上, export 导出“名字和值”, 名字与值其实也是我们模块的全部内容了

⭐ export 语法其实就分为两大类而已

1. 导出“（声明的）名字”
2. 导出“值” 所谓值即表达式

````js
# 导出名字
export <let/const/var> x ...;
export function x()
export class x
export { x, y, z }
export { x as y, ...};
export { x as default, ... };
// 导出“（其它模块的）名字”
export ... from ...;

# 导出值
export default <express>
````

- 合法的

  ````js
  export default 2; // as state of the module, etc.\
  export default "some messages"; // data or information
  # 由于javascript中对象也是一个单值表达式
  故
  export default {}
  ````

- 提问： export function() {} 导出一个匿名函数是导出值还是导出名字呢?

### export 的处理逻辑

- export如何导出名字？为什么只根据名字就可以导出？

  1. 导出一个名字
  2. 为上述名字绑定一个值

  ⭐ 这个步骤 犹如 var x  = 100； 进行了值的绑定

- 导入的逻辑

  > JavaScript 是依赖 import 来形成依赖树的，与 export 无关

  1. 按照当前语法在当前模块声明名字
  2. 添加一个当前模块被目标模块的依赖项

⭐ 处理 export/import 语句的全程，没有表达式被执行 => 这也是为什么说其静态化的原因

### 导出名字与导出值的差异

- 有个问题出现了， 既然export其并不会执行任何表达式。

  那么当你导出一个匿名函数的时候，这个函数仅有 default 这个特殊的名称

  ```js
  # 导入导出阶段 express完全不执行
  export default <expression>
  ```

- 在静态装配阶段，名字“default”只是被初始化为一个“单次绑定的、未初始化的标识符”

  ```js
  # 假设上便是如此
  export default function() {}
  
  import var default = function() {}
  ```

- 具名函数作为表达式值的时候，名字在块级作用域无意义

  ```js
  var x = function aaa() {}
  # 此时 aaa 不会在当前作用域登记为名称的
  ```

### 总结

1. 函数声明

   fn 是一个由函数声明创建的函数

   ```js
   function fn() {}
   
   function () {} ❌ // function 是一个函数声明， 其声明需要名称
   ```

2. 函数定义

   - my 是一个由函数定义创建的函数

   ````js
   # 此时函数 my.name 为 'fn'
   var my = function fn() {} // 右值作为单值表达式,其函数名无意义
   
   # 此时函数 my.name 为 ‘name’
   var my = function () {}

3. 函数表达式

   ```js
   # 这是一个匿名函数的表达式
   (function() {})
   ```

4. export default

   ````js
   #1 导出匿名函数，default被映射到import的名称， 等同于 匿名函数定义
   export default function (){}
   #2 导出具名函数, named 被映射到import的名称， 等同于具名函数定义
   export default function named() {}
   ````

## 05 | 变量作用域、词法作用域与迭代环境

> for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销

1. 语义： 顺序、分支、循环，其他语句的语义不值一提

###  块级作用域-1

> 除了以下语句，其他所有语句其都没有块级作用域。
>
> ps: 它们自身语句（例如if）不涉及作用域， 而其附带的块语句是作用域

1. `switch语句`被设计为有且仅有一个作用域。 无论它有多少个 case 语句

   - 任意分支的声明都会给该作用域添加这个标识符！
   - 单纯认为就是 是块语句即可。 

   ```js
   var x = null;
   switch (c) {
       case 0: 
           console.log(x);  ❌ refrence error
       	break;
       case 1: 
           let x = 1;
   }
   ```

2. 三个语句 + 一个特例 【for循环】

   - try语句： try、catch、finally也是特别的作用域
   - with语句： with
   - 块语句： {}

   ```js
   try {
   	# 作用域1
   }
   catch (e) {
       # 作用域2
   }
   finally {
       # 作用域3
   }
   
   with(x); /* 作用域1 */; // <- 这里存在一个块级作用域
   
   {}
   ```

3. 一个特例也带着块语句

   - while 和 do..while 语句 是不涉及自己的块语句的 【请务必区分 whle与块语句】

   - 而有一个for 语句自身便有块级作用域， 注意 【var】 声明的 不在此列。

     ````js
     for ( let/const ... of ...) ...
     for ( let/const ... in ...) ...
     for ( let/const x ) ...
     ````


### 块级作用域-2

> 探究此特例的前提我们应该了解什么是语句？

- 语句

  语句存在（组成）的内容只有这四类，这并不重要。

  - 表达式 、其它语句、标识符声明 
  - 一种特殊的语法元素，称为“标签（例如标签化语句，或 break 语句指向的目标位置）

1. 什么是块级作用域

   ⭐ 块级作用域的本质便是一组标识符。

2. 为什么需要块级作用域

   潜在的标识符冲突的时候便需要新的作用域去管理他们。

   举例： 函数每次调用时， 其存在【重新进入之前】的标识符，从而需要作用域管理（这便是闭包）

   - 标识符管理 需要作用域
   - 语法支持多语句时， 比如 try、catch、finally的三处作用域
   - 语句表达的语义就是一个作用域。例如 块级语句 {}

3. 结论

   - 标签、表达式和其它语句 并不是 产生作用域的原因，也不需要作用域管理。

   - 若语句出现了标识符，那么显然是需要作用域管理的。

   - 故 for 为什么会有作用域的答案显然推出。

     ```js
     for (let/const )..
     ```


4. 示范

   - 与【if语句】本身无关

     ````js
     if (x) {
       ...
     }
     // or
     if (x) {
       ...
     }
     else {
       ...
     }
     ````

   - switch

     ````js
     var x = 100, c = 'a';
     # 这就是 let 带来的暂时性索取 [ 预编译时期变量的提前声明 ]
     # 作用域添加这个标识符
     switch (c) {
       case 'a': 
         console.log(x); // ReferenceError
         break;
       case 'b':
         let x = 200;
         break;
     }
     ````

### 特例-循环语句中的块

- 并非所有循环都有属于自己的块级作用域

  如while、do...while语句本身无自己的块级作用域

  ````js
  while ( let i = ) ❌
  ````

- for 语句拥有

  注意： 我们在此处没有列出var， 具体原因将在后续解释出来。

  ```js
  for (let/const i)  // 同理 for in、for of
  ```



#### 01| 为什么要有这个特例

为什么我们要称呼 for 循环是一个特例？

语句中包含了标识符声明”的情况下，需要创建块级作用域来管理这些声明出来的标识符。

- for语句允许标识符的声明

  存在标识符声明因而会出现潜在标识符冲突的问题

- 故 for语句 需要一个“独立作用域”去管理

#### 02| 排除 【var】 声明

- 原因
  1. 最初的js作用域仅存在 【函数内】与【函数外】两种，仅此而已。
  2. 而语句 for 循环中出现了 声明，其是变量提升，在全局中登记名字。

ES6实现的时候依旧遵从了这一点。有两种方案去专门处理。

1. 变量作用域

   所有“var 声明”和函数声明的标识符都登记为 varNames

2. 词法作用域

   其它情况下的标识符 / 变量声明，都作为 lexicalNames 登记，使用“词法作用域”管理。

#### 03| for (let x)

1. 既然语句中有有了作用域，那么循环体是否需要作用域?

   - 这由语言设计决定

     循环体（单个语句）允许支持新的变量声明，

     为了避免它影响到循环变量，就必须为它再提供另一个块级作用域

   - 但 js如何处理呢?

     `单语句不支持词法声明` 这种语法其实普遍存在于JS中，不过很难见到，因为毫无意义。

     ````js
     for (let x = 102; x < 105; x++) let x = 200;
     SyntaxError: Lexical declaration cannot appear in a single-statement context
     ````

2. 循环体是否需要作用域的根本原因

   - 若 for 语句仅有一个块级语句那么显然不可以重复的去执行 声明标识符

      (let 语句的变量不能重复声明的)

   - 解决办法:  为循环体增加一个作用域

     1. 【let  i】 就可以只执行一次
     2. 【i in x】  放在每个迭代中来执行

   ```js
   for (let i in x) ...;
   ```

### for循环的代价

从上得知

1. 循环体增加的作用域称为 loopEnv， for语句作用域可称呼为 forEnv
2. loopEnv 的外部环境指向 【forEnv】

看起来一切都很好，但问题在于 循环体内的复杂

````js
# for迭代结束 => i值可能变为最后一次迭代的值, 那么 forEnv的 i 仅有一个显然不对
for (let i in x) 
    setTimeout(()=>console.log(i), 1000);
````

故想让上述符合预期

1. loopEnv 就必须是“随每次迭代变化的”
   - 也就是说，需要为每次迭代都创建一个新的作用域副本，这称为`迭代环境（iterationEnv)`
2. 因此，每次迭代在实际上都并不是运行在 loopEnv 中，而是运行在该次迭代自有的 iterationEnv 中。

故答案

- 语法上这里只需要两个“块级作用域”
- 而实际运行时却需要为其中的第二个块级作用域创建无数个副本（迭代环境）。

### 思考题

````js
# ReferenceError: condition is not defined
while (condition) var i = 0;

# 单语句不许词法声明
while (condition) let i = 0;
````

为什么单语句 不许词法声明?

1. 单语句没有块级作用域 。

2. 而词法声明是不可覆盖的。

3. 答案

   循环体的变量无法拷贝 迭代环境。

## 06 | ？？？

### 为代码语句标示一个位置

1. 20世纪60-70年代，将代码语句标识位置，因为难以维护、正确性的难以验证进而迸发了【结构化代码】

2. 【用位置标识代码】的目的是 `实现go to`的跳转，以转移流程

3. 现在 JS中不存在GOTO语句了，仅是分块代码（基于代码分块的流程控制技术）

   - 分块代码

     代码分块中想要实现GOTO，那它应该自己设计一个自己的GOTO。

     即“自己的设计自己实现，自己知情的情况下使用GOTO”

4. 现在实际编写代码中，我们已接触不到【程序地址】【标号】，这个GO能去哪里呢?

### 第一种中断

> 所谓中断，你可以这么理解： 
>
> 1. 什么是GOTO？  GOTO某个语句，可以【代表】中断某个语句的执行。
> 2. 中断某个语句的执行，可以【代表】我们到达此语句的结束位置。
> 3. 我们到达此语句的结束位置， 可使用【break】作为子句来实现。

故我们可以使用

- js中已存在的`【所有循环语句】`都可以使用 break， 中断当前语句执行。将执行逻辑将于下一语句
- `switch语句`

### 第二种中断

> 中断【任意标签化的语句】

由于我没使用过【标签化语句】故在此演示，当然显然标签化语句是被人唾弃的？

#### 标签化语句 | 位置

1. 标签化语句示范

   ````js
   # break 跳出的不是一重循环， 而是outermost这个标签语句
   <script>
     var iNum = 0;
     outermost:
     for (var i = 0; i < 10; i++) {
       for (var j = 0; j < 10; j++) {
         if (i == 5 && j == 5) {
           break outermost;
         }
         iNum++;
       }
     }
     console.log(iNum); // 55
   </script>
   ````

2. 提出疑问

   ````js
   aaa: {  }
   bbb: if (true) { }
   ````

   - 上述代码的疑问

     1. aaa 无疑问， aaa 作用域必然是指 后面的块语句

     2. 而 bbb呢？

        首先 if 语句并没有作用域， 故  不可以 if （var a ）这种写法

        那bbb 到底是指 这个 【if】 语句呢？还是其后的 块语句 呢？

     3. 标签【bbb】到底指什么？

3. 关于 标签语句

   - ⭐标签 bbb 在语义上只是要“`标识其后的一行语句`”， 标签化语句理解的是`“位置”`
   -  标签语句 与 语句在执行代码的范围无关（与词法环境无关、块级作用域无关）

示范

- 在if语句的两个分支中都可以使用break； 包括双重循环也可以使用 break aaa、
-  在try...catch...finally中也可以使用break;

````js
aaa: if (true) {
   break aaa;
}
else {
  break aaa;
}
 
bbb: try {
  ...
}
finally {
  break bbb;
}
````

#### 对try-catch的特别示范

- console.log("Hi");

- return i++; 

- finally {  break bbb }

- console.log("Here");

- return i

  > 来解释一下原因
  >
  > 为什么遇到了 return i++ 也确实执行了 i++， 为何又没有跳出 foo这个函数？而是直接跳进了 finally 中的break
  >
  > 1. js设计如此，当你妄图再try中去跳出，那必然会走到finally，因为这是位置的跳出
  >    - 遵循try 无论如何怎么跳出都会执行 finally 这里
  >    - 这恰是证明 标签语句 与 【语句在执行代码的范围无关】， 与【位置】的概念有关
  >    - 第一个return 无效的原因是因为设计的故此如此， 令这个return失效 但依旧执行

````js
  var i = 100;
  function foo() {
    bbb: try {
      console.log("Hi");
      return i++; //  <-位置1：i++表达式将被执行
    }
    finally {
      break bbb;
    }
    console.log("Here");
    return i; //  <-位置2
  }
  console.log(
    foo()
  );
````

> break语句本质上就是作用于其后的“一个语句”，而与它“有多少个块级作用域”无关 **

### 执行现场的回收

⭐ 单对于 【break】而言，其将【代码块】理解为【位置】， 而非作用域 / 环境。请牢记。

你可以将其称做`执行现场的回收`，这种事情只会出现在【使用标签的代码上下文】中。

- 执行现场
  1. JS执行机制包括【执行权】与【数据资源】两部分，代表【逻辑】与【数据】
  
  2. 块级作用域（词法作用域）本质便是保存执行现场的【瞬时状态】（快照）
  
  3. JS的运行环境为栈，而`栈顶`永远都是当前拥有【执行权】所有者的所持有的【快照数据】，
  
     即代码活动现场\执行现场。

再比如说

- JavaScript 的运行环境

  通过函数的 CALL/RETURN 来模拟上述“数据帧”在栈上的入栈与出栈过程

  1. 函数的调用， 相当于压入该函数的上下文环境

  2. 【全局或模块全局中执行的代码】、【Promise 中执行调度的那些内部处理】、

     所有的这些 JavaScript 内部过程或外部程序都统一地被`封装成函数`, 

     通过 CALL/RETURN 来激活、挂起

- “作用域”

  故 “作用域”就是在上述过程中被操作的一个对象。

  - 作用域退出，便是 函数RETURN
  - 作用域挂起，执行权转移
  - 作用域创建，闭包的初始化
  - ........

- 关于之前的【break labelName】这一语法

  1. 语法独立【执行过程】的体系，它表达式是一个`位置的跳转`，而不是数据栈的进出。

     labelName 独立于标识符体系（也就是词法环境）所带来的附加收益

  2. 这种特别之处令JavaScript设计了一种新的方法去清除此跳转带来的影响【即回收资源】

### 语句执行的意义

#### 【离开语句】代表清除语句所持有的一切资源，

⭐ JavaScript 是一门混合了函数式与命令式范型的语言，而这里对函数和语句的不同处理，正是两种语言范型根本上的不同抽象模型带来的差异

- 函数退出时回收闭包

  函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）

- 语句是命令

  语句执行的返回结果是该命令得以完成的状态

#### 站在ECMAScript上看问题

JavaScript 的执行都是语句执行。故执行的描述都称为“运行期语义“

1. 运行期语义：

   描述一个 JavaScript 内部的行为或者用户逻辑的行为的过程与结果， 换句话来说，

2. 运行期语义都最终会以一个完成状态（Completion）来返回。

   - 函数的调用

     调用函数——执行函数体（EvaluateBody）并得到它的“完成”结果（result）

   - 块语句的执行

     执行块中的每行语句，得到它们的“完成”结果（result）

3. 结果（result）包括的状态

   有五种，称为完成的类型：normal、break、continue、return、throw。

   任何语句的行为，要么是包含了有效的、可用于计算的数据值（Value）。

   故

   - 语句正常完成（normal）
   - 一个函数调用的返回（return）

   而若是不可用于计算或传递的纯粹状态：

   - 循环过程中的继续下次迭代（continue）
   - 中断（break）
   - 异常（throw）

4. `break`

   break作为 结果的五种状态之一。代表中断含义。

   而JavaScript会寻 此 break的目标位置，即【result.Target】，并于当前标签语句对比（若有）。

   - 若一样，取 break 源位置的语句执行结果为值（Value）并以正常完成状态返回；
   - 如果不一样，则继续返回 【break 状态】

   示范

   ```js
   console.log( 
       eval(` 
   		aaa: { 
   			1+2; 
   			bbb: { 
   				3+4; 
   				break aaa;
   			} 
   		}
   	`)
   ); // 输出值：7
   ```

   我们来解析这个问题， 来证明 ⭐·`语句执行总是返回它的完成状态`

   1. break触发时，标签化语句bbb首先捕获到此语句的完成状态，并携带标签 aaa
   2.  bbb触发时候检测到此标签中断目标（Target）为 自己标签不同，故所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa
   3. 语句aaa获得上述状态。对比标签成功。返回结果为语句3+4的值。（作为完成状态传出）

   > 所以，语句执行总是返回它的完成状态.
   >
   > 且如果这个完成状态是包含值（Value）的话，那么它是可以作为 JavaScript 代码可访问的数据来使用的。
   >
   > 例如，如果该语句被作为eval()来执行，那么它就是 eval() 函数返回的值。

### 中断语句的特殊性

【x: break x; 】回归标题这行代码有什么特别之处呢？

1. 最小化的 break 语句的用法。

   - 标签化语句”必须作用于“一个”语句，而【语句】理论上最小化形式便是【空语句】。

   - 为什么 

     【空语句】又不可作为break的目标标签语句（因为标签语句范围内你需要进行中断，若你不中断这便不是【中断语句】，因此最小化的示例就只能是对 break 语句自身的中断）

2. 不会对其他任何代码构成任何影响”的语句， 是JavaScript 中的特有设计

   - 【语句】与【函数】返回具有相似性。可不返回时出口信息为 undefined

   - 而虽然

     1. “break labelName”的中止过程是可以传出“最后执行语句”的状态的， 
     2. 但是⭐ 任何被 break 的代码上下文中，最后执行语句必然会是“break 语句”本身

   - 即若想实现【语句执行状态】的传递，则需确保

     1. “break 语句”不返回任何值（ECMAScript 内部约定用“Empty”值来表示）；
     2. 上述“不返回任何值”的语句，也不会影响任何语句的既有返回值

   - 而当前

     1. 它的类型必然是“break”；
     2. 它的返回值必然是“空（Empty）”。

   - 因此

     对于 Empty 值，在 ECMAScript 中约定：在多行语句执行时它可以被其他非 Empty 值更新（UpdateEmpty），而 Empty 不可以覆盖其他任何值。

   - 再因此

     这就是空语句等也同样“不会对其他任何代码构成任何影响”的原因了。

3. 在顺序执行时，当语句返回 Empty 的时候，不会改写既有的其他语句的返回值

4. 语句有返回值。

5. 标题中的代码，是一个“最小化的 break 语句示例

6. 有两种中断语句，它们的语义和应用场景都不相同。



## 07 | 

- 详解JavaScript中特殊的可执行结构

  ````js
  `${1}
  ````

### 01 | 何为模板

1. JavaScript 中，有语句和表达式两种基本的可执行元素。

   但不代表 JavaScript 中只有语句和表达式是可执行

   - 语句 => console.log()
   - 表达式 => window
   - 什么是可执行？

2. 模板是一种特殊的可执行结构

   既然是特殊的可执行结构，即这是一种固定的、确定的逻辑

