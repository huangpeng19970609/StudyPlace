> var x = y = 100： 声明语句与语法改变了JavaScript语言核心性质

### 6种声明方式

⭐ 声明的共性： var let const 仅是这三种

> 这些声明方式的意义 => JS的静态语义

1. let ： 声明变量 x。不可在赋值之前读。

   - 访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为这个标识符被拒绝访问了

2. const

3. var： 

   在赋值之前可读取到 undefined 值。

4. function x

   声明变量 x。该变量指向一个函数。

   函数是按 `varDecls 的规则`声明的

5. class x

   声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的.

   类的内部是处于严格模式中，它的`名字是按 let `来处理的

6. import

   入标识符并作为常量（可以有多种声明标识符的模式和方法）

   import 导入的名字则是按 `const `的规则来处理的

关于 let、const

1. var：

   “变量声明（varDelcs）”

   JavaScript 是允许访问还没有绑定值的var所声明的标识符的。

   - 原因

     JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值.

2. let、const

   “词法声明（lexicalDecls）”

   JavaScript 拒绝访问还没有绑定值的let/const标识符而已。

除此之外，潜在的声明符号

1. for (var|let|const x …) …

   for 语句有多种语法来声明一个或多个标识符，用作循环变量。

2. try … catch (x) …

   catch 子句可以声明一个或多个标识符，用作异常对象变量。

### 读值

- 现在的 JavaScript 环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的

- 变量名列表（varNames）

  1. ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames）

  2. 声明是在语法分析阶段就处理的

     即 所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中。

     故 读值的时候， 它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符

     - 强调： 由于使用let【词法声明】，故其被拒绝访问了。

       ​			 而 【变量声明】的var 打印结果是undefined，

       ​			【词法声明】、【变量声明】若从标识符的访问上其皆有 标识符提升的特点的！

     ````js
     var y = "outer";
     # 在函数 f() 创建（创建它自己的闭包）时就已经存在，
     # 所以才阻止了console.log(y)访问全局环境中的y
     # ps: 一个函数其实就是闭包，毕竟闭包的本质含义就是作用域暂留。
     # 不过我们总是喜欢以 闭包不出栈这一特殊闭包情况叫之为闭包。
     function f() {
       console.log(y); // undefined
       console.log(x); // throw a Exception
       let x = 100;
       var y = 100;
       ...
     }
     ````
     
     


### 赋值

简而言之： 在 JavaScript 中，一个赋值表达式的左边和右边其实“都是”表达式！

````js
lRef = rValue
````

特殊情况： 向一个不存在的变量赋值

1. JavaScript 的全局环境是引擎使用一个称为“全局对象”东西管理起来的，即“全局对象闭包”来获取Javascript的全局环境
2. 向一个不存在的变量赋值的时候， 全局对象的属性表是可以动态添加的， 因此 JavaScript 将变量名作为属性名添加给全局对象

ES6后的JavaScript 的全局环境

1. 全局对象 

2. 变量名列表： 所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中

   这个变量名列表中的变量是“`直接`声明的变量”，不能使用delete删除

   ```js
   var a = 100; delete a; 不可删除
   
   x = 200; delete x; 可以删除 => 因为 其没有被 var 直接声明
   
   eval('var b = 300'); 可以删除 （eval真正实现的特别之处还是可以删除的）
   ```

### var x = y = 100

- y = 100 

  1. y 被间接的声明在全局环境下，故可以被删除
  2. y = 100 其是一个语句的表达式（Result），是一个完成状态，其返回value为 100

- x = 100

  1. 此 【100】是 y = 100 语句表达式的返回值， 而并且是 【100】这个数字单值表达式

  2. 且因为 var x = 100 故是初始绑定， 故是变量“x”的初始绑定。

     初始绑定， var x；变量提升，先有了一个x的标识符，在进行了赋值的操作。

     ⭐ 这是静态语义的特性，发生在语法分析期。

### 思考题: 严格来说， 为何声明不是语句?

1. 声明发生编译期
   - 这是js静态化的特性的体现
   - 维护变量表
2. 语句发生在执行期。
   1. 若声明的时候全都没有初始化，那 编译器就可以完全执行。

### 结论

1. 通过静态分析可以发现那些声明的标识符

   故标识符的 变量/常量 一定在代码执行前已在作用域中！

   ```js
   # VM139:1 Uncaught ReferenceError: y is not defined
   console.log(x); 
   var x = y = 100;
   ```

2. 全局变量的管理方式决定了“向一个不存在的变量赋值”所导致的变量泄漏是不可避免的。

   如 var x = y = 100 这样子

   ````js
   var x = y = 100;
   window.y // 100
   ````

3. 动态添加的“var 声明”是可以删除的，这是唯一能操作 varNames 列表的方式

   - 不过它并不存在多少实用意义
   - 若你是间接的，则无法删除。

4. 变量声明在引擎的处理上被分成两个部分：

   一部分是静态的、基于标识符的词法分析和管理，它总是在相应上下文的环境构建时作为名字创建的；

   ````js
   # x被z创建 
   var x = 100; 
   ````

   另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定。

   ````js
   # = 100 的过程
   var x = 100; 
   ````

   

   

### 别人的疑问

1. 为什么有这种结果

   - 函数创建的时候标识符x和y就被创建了

   - 编译期时无论是let、var 其都被加入了变量名列表中

   - 在前的环境上下文有【y】, 且是用 var 声明的， 故打印为 undefined

     let x 由于缺省值，直接抛出异常（词法环境）

   - 函数实例、函数闭包，都不过是“静态词法解析结果

   ````js
   var y = "outer";
   
   function f() {
   	console.log(y); // undefined
   
   	console.log(x); // throw a Exception
   
   	let x = 100;
   
   	var y = 100;
   	...
   }
   f()
   ````

   

2. 编译阶段

   按道理来说编译阶段 会 发现 b 吗？

   - 如果“创建”是指静态语义中的一个“函数”，那么确实是创建了的。

     ⭐——但它还没有“绑定”到一个闭包的执行上下文中

   ````js
   function a() {
   	function b() {}
   }
   ````

   

