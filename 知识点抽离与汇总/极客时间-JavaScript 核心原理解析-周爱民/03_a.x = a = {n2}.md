### 引言

1. var x = 100

   “x”只是一个表达名字的、静态语法分析期作为标识符来理解的字面文本，而不是一个表达式

   ⭐ 语法分析期阶段可以被识别到

   ⭐ 运行期间，使用【初始器】为这些名字绑定值。

2. x = 100

   x” 是一个表达式，它被严格地称为“赋值表达式的左手端（lhs）操作数”

故 我们再来看看这段代码

```js
var a = {n:1};
a.x = a = {n:2};
alert(a.x); // --> undefined
```

1. 声明语句的语法限制。

   var a.x 是错误的原因是 若在声明语句， 等于号左边不能是表达式，而此时 a.x反而是一个表达式故报错

2. 左侧的 a 仅是一个静态语法分析期作为标识符来理解的字面文本

### 表达式 w = x + y * z

> 您需要关注“变量作为表达式是什么，以及这样的表达式如何求值（以得到变量）”
>
> 1. 表达式的运算，是从左至右计算的。
> 2. 运算符的顺序，并不是从左至右。比如加减乘除

- 第一个计算顺序的例子

  ````js
  w = x + y * z
  ````

  先计算子表达式w 再计算 x、y、z， 之后 y * z 再加 x，再将其值给表达式 w 所指 的 变量或属性

- 第二个计算顺序的例子

  ````js
  b * c
  ````

  1. 将b理解为单值表达式，求值并得到GetValue(evalute('b'))；

  2. 将c理解为单值表达式，求值并得到GetValue(evalute('c'))；

  3. 将上述两个值理解为求积表达式’*'的两个操作数

     ````js
     evalute('*', GetValue(evalute('b')), GetValue(evalute('c')))
     ````

  4. 其他解释

     - b和c在表达式计算过程中都并不简单的是“一个变量”而是而是“一个单值表达式的计算结果”
     - 变量作为表达式是什么呢？
     - 进而这样的表达式如何求值（以得到变量） => 即 GetValue的结果

- 第三个计算顺序的例子

  ````js
  var x = y = 100;
  
  a.x = a = { n: 2 }
  ````

  - 表达式

    1. 第一行的 x 是 标识符， y 是 表达式， 100 是表达式。 y = 100 是赋值表达式。
    2. 第二行 a.x 是表达式， a = { n : 2 } 是赋值表达式， a、{ n = 2 } 当然也是表达式

  - 您应该区分出来

    1. 第一行仅一次赋值表达式运算外加一次值绑定操作。
    2. 第二行才是连续两次的赋值表达式。


### x = y = 100

> 这是一个连续赋值表达式

1. x 应被看作是一个表达式。它被严格地称为“赋值表达式的左手端（lhs）操作数”

2. 这是一个连续赋值表达式

3. 其他

   ````js
   var x = y = 100;
   ````

   1. 这不是一个连续赋值的表达式， 
      - 因为 有 “var 声明”的左边这是一个被称作初始器（Initializer）”的语法组件
      - var x = xxx 这是被绑定了一个值

### a.x = a = { n: 2 }

> 这是一个连续赋值表达式

````js
var a = { n: 1 }

a.x = a = { n: 2 }
````

1. 至左到右

   【a.x】 =>  【a】 => 【n: 2】

   a.x 是一个引用， 其引用保存计算过程的信息，其中就包括 a， 以备后续的this来使用。

   简而言之，在内部语法实现中，“a”是作为一个引用被暂存下来了的

   ```js
   a = {
       n: 1
   }
   ```

2. a = { n : 2 }

   ```js
   a.x = a = { n: 2 }
   ```

   - a 作为一个引用被覆盖，

     1. 最初那个 （a.x ）的result 中暂存的 引用a 会更新吗

        不会更新，（a.x）的result只有引擎对象可以理解，JavaScript 用户代码层面只能取值、赋值。

   -  a.x 表达式结果 result 其是一个引用，且其保存了a。

   如正常语法一样，这个被赋值的引用“a.x”是一个未创建的属性，赋值操作将使得那个“原始的变量a”具有一个新属性，于是它变成了下面这样：

   形如 a.x = { n: 2 }

   ```js
   # 我们单纯看最左侧的 a.x计算过程信息的 【a】
   a = {
       n: 1,
       x: {
           n: 2
       }
   }
   # 但最终 undefined的原因 是因为 a 在从左至右的计算过程中， a 在引用传递丢失了，故此a被丢弃
   # 这在下一行打印语句便可以体现出来。
   ```

   > “a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。
   >
   > ⭐ a 即便是被废弃掉了也可以执行下去。
   >
   > 在第二次赋值后，因为“变量a过去的值”那个对象已经不再被任何变量持有，所以它已经无法被访问到了，它“跑丢了”。

- 总结

  简单来说 就是ref的a跑丢了，但赋值也不会报错。

  (最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。)

- 故

  所以，第二次赋值操作“a.x = …”实际是无意义的。因为它所操作的对象，也就是“原始的变量a”被废弃了。但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量a”，那么上面的代码的影响仍然是可见的。

  ```js
  var a = {n:1}, ref = a;a.x = a = {n:2};console.log(a.x); // --> undefinedconsole.log(ref.x); // {n:2}
  ```

  

关于一些细节

1. a.x = ...，那么它就是作为“引用”来使用，这样就可以访问到`x`这个属性，并置值；
2. a.x 如果它在后续运算中被作为rhs，例如console.log(a.x)，那么它就会被GetValue()取值（并作为值来使用）
3. a.x整体被作为“一个操作数”，它的用法与它被使用的位置是有关的。但是“得到它（亦即是对a.x这个表达式求Result）”的过程并没有什么不同。

#### 答案

```js
var a = {n:1};
a.x = a = { n: 2}
```

- 有一个新的a产生，它覆盖了原始的变量a，它的值是{n:2}；

- 最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。

  但他们确实曾经存在过。

  1. 第二次赋值操作“a.x = …”实际是无意义的， 因为被丢弃
  2. 但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量a”，那么上面的代码的影响仍然是可见的

  ```js
  {
    x: {n: 2},  // <- 第一次赋值“a = {n:2}”的结果
    n: 1
  }
  ```

- 来持有原始的 a 以至于 让他不丢弃吧

  ```js
  var a = {n:1}, ref = a;
  a.x = a = {n:2};
  
  console.log(a.x); // --> undefined
  console.log(ref.x); // {n:2}
  ```

#### 连续两次赋值有什么作用？

```js
elemData = {}
...
elemData.events = elemData = function(){};
elemData.events  = {};
```

既然 我们知道 这样是毫无意义的事情， 为什么他是还要如此的做？

`意味着给旧的变量添加一个指向新变量的属性`

```js
# 一个链表是可以像下面这样来创建的
var i = 10, root = {index: "NONE"}, node = root;

// 创建链表
while (i > 0) {
  node.next = node = {};
  node.index = i--;  // 这里可以开始给新node添加成员
}

// 测试
node = root;
while (node = node.next) {
  console.log(node.index);
}
```

### 复习题

复习题下面有几道复习题，希望你尝试解答一下：

- 试解析with ({x:100}) delete x; 将发生什么。

  ```js
  with({x: 100}) {
      delete x;
  }
  ```

  delete 删除的是对象的成员，即 property x

- 试说明 (eval)() 与(0, eval)()的不同。

  一个是引用求值，一个是表达式求值

- 设“a.x === 0”，试说明“(a.x) = 1”为什么可行。

  表达式 (a.x) 的计算结果是 a 对象的属性 x 这个引用，所以可行；

- 为什么with (obj={}) x = 100; 不会给 obj 添加一个属性’x’？

  因为 with语句总是将对象插入进函数的作用域中， 此时的x并非是对象的x，而是此函数的x

