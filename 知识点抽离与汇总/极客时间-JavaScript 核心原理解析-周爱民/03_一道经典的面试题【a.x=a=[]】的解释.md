

### 0 前言

> 这是一道很多人都解释过的面试题，今天我们再来讨论他
>
> ```js
> let a = {}
> a.x = a = {n: 2} 
> ```
>
> 令人出乎意料的是 => a的x属性其为undefined

### 1 关于赋值比较

#### var x = y = 100; 

这显然是一个常见的连续赋值语句。

````js
var x = y = 100; 
````

在这里，您需要注意的是

1. “var”关键字所声明的，事实上有且仅有“x”一个变量名
2. 变量“y”会因为赋值操作而导致 JavaScript 引擎“意外”创建一个全局变量

#### var x = 100;

我们单纯的来看此项。

````js
var x = 100;
````

你需要注意的是:

1. “= 100”是向 x 绑定值
2. var x”就是单纯的标识符声明

故

- 其 x 仅是一个表达名字、静态语法分析期作为标识符来理解的字面文本， x绝不是一个表达式。

#### x = y = 100;

去除掉“var”关键字之后

```js
x = y = 100;
```

1. 此时并非是语法声明， x 应被看作是一个表达式。它被严格地称为“赋值表达式的左手端（lhs）操作数”

2. 再次重申之前强调的内容 

   - 赋值表达式左侧的）操作数可以是另一个表达式

   - “var 声明”的左边，绝不可能是一个表达式， 而是一个被称作初始器（Initializer）”的语法组件

     如果它用在声明语句中，那么就“不是”， 即便你是es6的模板赋值。

     不过模板赋值没有 声明语句 其左侧显然是一个表达式。

3. 模板赋值

   如果这里是赋值模板，那么“var/let/const”语句也事实上只会解析那些用来声明的变量名，

   并在运行期使用“初始器（Initializer）”来为这些名字绑定值

### 2 来自《JavaScript 权威指南》的解释而延展

> JavaScript 总是严格按照从左至右的顺序来计算表达式。

例如，在表达式w = x + y * z中，

1. 将首先计算子表达式 w，然后计算 x、y 和 z；

2. 然后，y 的值和 z 的值相乘，再加上 x 的值；

3. 最后将其赋值给表达式 w 所指代的变量或属性。

这个解释没有问题，关于 此x + y*z。 你需要明白以下事情:

1. 任何运算的操作数都是严格以左向右执行的 （故x会被先处理）
2. 但我们今天要讨论的 x `是一个特异的事情`， 这个解释并不适用。

#### 一切都是表达式，一切都是运算

> x此处被先处理，是一个特异的现象。
>
> - 这一现象在语言中是函数式的特性，
>
>   类似“一切被操作的对象都是函数求值的结果，一切操作都是函数”。

1. 传统模式中

   `标识符` 与`对象`其可能便`直接`的表达某个变量的地址、指针等。我们将其理解为【操作对象】即可。

   不需要额外的、附件的知识概念。

   ```js
   a = 100;
   b * c;
   ```

   如此理解即可。引擎具体如何做不需我们操心。

   - a 有了值 100
   - b 与 c相乘

2. 但在JavaScript中

   ```js
   a = 100;
   b * c;
   ```

   涉及6个操作。我们仅以第二行作为一个示范。

   - b是单值表达式， 求值并得到GetValue（evalute（‘b’））

   - c是单值表达式， 求值并得到GetValue（evalute（‘c’））

   - 相乘

     ```js
     // 第一个操作数
     evalute('*', GetValue(evalute('b')), 
     // 第二个操作数
     GetValue(evalute('c')))
     ```

#### 我想告诉你什么?

1. b和c在表达式计算过程中都并不简单的是“一个变量”

   而是“一个单值表达式的计算结果”

2. 这样的意义在于面对 JavaScript 这样的语言时，你需要关注如下

   - 变量作为表达式是什么
   - 进而这样的表达式如何求值（以得到变量）

#### 回溯【赋值比较】

```js
#1
var x = y = 100;
#2
x.a = x = {n:2}
```

#1 对于 var x = y = 100中

1. x 仅是标识符（并非是表达式）， y 和 100都是表达式。 且 y = 100 是一个赋值表达式。

#2 对于 x.a = x = { n: 2 }中

1. a.x 是一个表达式，
2. a = {n:2} 也是一个表达式
3. 并且后者的每一个操作数（本质上）也都是表达式

这又代表了什么呢？

1. “var x”从来都不进行计算求值，所以也就不能写成“var a.x …”

2. 在代码var x = y = 100;中实际只存在一个赋值运算，那就是“y = 100

   `并不存在连续赋值运算`  因为“var x = …”是值绑定操作，而不是“将…赋值给 x” 

   【可以联想例一中的 y = 100 是一个赋值表达式 y是表达式 100 也是一个表达式】

### 3 真正的连续赋值表达式

> var x = y = 100;并不是连续赋值表达式， 它只是进行了一次赋值表达式， 接着进行了 值绑定
>
> 而a.x = x = [] 才是真正的、两个连续赋值表达式

#### 3.1 执行

这条语句执行的过程

1. JS严格的从左至右的顺序来计算表达式。

2. a.x被最先执行，由于a.x 是一个表达式故其结果是一个”引用“。
3. a.x计算时，需要先计算其左操作数（a）

故 这个表达式所代表的的含义

1. 计算单值表达式a，得到a的引用
2. a.x 的右侧 x 理解成【标识符】， 并作为`.`运算的右操作数。
3. 计算 【a.x】表达式的结果 (Result)

故 a.x 的计算结果 其仅是一个引用，并通过这个引用保存了计算过程的信息。

比如 它保存了 ”a“ 这个对象。以备后续可能作为this来去使用。

言而总之，` a 是作为一个表达式引用在这里被暂存了起来`

#### 3.2 暂存

我们将其分为三步来看待。 因为此处存在三处表达式。

```js
var a = {n:1};
a.x = a = { n: 2}
#1
a.x = // <- `a` is {n:1} 
    #2
    a = // <- `a` is {n:1} 
        #3
        {n:2}; // 赋值，覆盖当前的左操作数（变量`a`）
```

在第二个赋值表达式中，a 被赋值了，这显然是一句废话。

⭐ 但问题是 当初在 a.x 的表达式计算中， 所暂存在其 结果（Result)中的引用a会更新吗？

答案： 

> - 你可以简单的理解为 这两个 x 毫无关系。
> - 第二次赋值“a.x = ...”中操作的`a`正是原始的变量a

1. 并不会。其 暂存的a 仅是一个运算的结果。它的操作仅涉及

   - 取值GetValue、置值PutValue
   - 作为一个引用而传递给其他

2. 为什么？

   最左侧“空悬”了一个已经求值过的“a.x” 

   如果你继续执行你所作的事情那么会如此。这就是第二次赋值操作的结果。

   ```js
   // a.x中的“原始的变量`a`”
   {
     x: {n: 2},  // <- 第一次赋值“a = {n:2}”的结果
     n: 1
   }
   ```

### 4 最终结果

```js
var a = {n:1};
a.x = a = { n: 2}
```

- 有一个新的a产生，它覆盖了原始的变量a，它的值是{n:2}；

- 最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。

  但他们确实曾经存在过。

  1. 第二次赋值操作“a.x = …”实际是无意义的， 因为被丢弃
  2. 但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量a”，那么上面的代码的影响仍然是可见的

  ```js
  {
    x: {n: 2},  // <- 第一次赋值“a = {n:2}”的结果
    n: 1
  }
  ```

- 来持有原始的 a 以至于 让他不丢弃吧

  ```js
  var a = {n:1}, ref = a;
  a.x = a = {n:2};
  
  console.log(a.x); // --> undefined
  console.log(ref.x); // {n:2}
  ```

### 5 连续两次赋值有什么作用？

```js
elemData = {}
...
elemData.events = elemData = function(){};
elemData.events  = {};
```

既然 我们知道 这样是毫无意义的事情， 为什么他是还要如此的做？

`意味着给旧的变量添加一个指向新变量的属性`

```js
# 一个链表是可以像下面这样来创建的
var i = 10, root = {index: "NONE"}, node = root;

// 创建链表
while (i > 0) {
  node.next = node = {};
  node.index = i--;  // 这里可以开始给新node添加成员
}

// 测试
node = root;
while (node = node.next) {
  console.log(node.index);
}
```

