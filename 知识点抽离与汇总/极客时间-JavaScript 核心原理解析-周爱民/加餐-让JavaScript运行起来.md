我们在讲述总是这两条线索贯穿着全部

1. 引用和执行过程
2. “JavaScript是什么？”

### 1 文本到脚本

底层的线索： 所谓的【JS脚本代码】无非便是【文本】（这似乎是废话），而JavaScript核心原理便是文本如何变成脚本，即“记号”。

1. 字符序列

   从引擎层面，无论是eval执行一段字符串还是装载执行js代码实际是没有区别的，我们称呼其执行对象（这文本）叫做【字符序列】、

2. 正向遍历（逐字符处理）

   假设可以回归保持代码，这便代表解析器需要暂存旧数据（2G代码需要2G的环境存储）。故大部分语言的实现都是正向遍历的。显然JavaScript也是【正向遍历】【字符序列】。

3. 记号

   对【字符序列】进行【正向遍历】中得到的、可以被理解的对象，称呼为【记号】。

4. 文本到脚本

   而记号便是【文本】到【脚本】，故记号是语言的创世原点。

   - 记号既可以是语言能识别的，如预先定义的那些关键字
   - 记号也可以是语言不能识别的，如所谓的“语法错误”

### 2 引用与静态语言的处理

ECMAScript永远仅是在描述【引擎】如何去实现，而不是描述语言是什么。、

1. 表达式： JavaScript语言的最核心的预设便是 【表达式】

   - 比如： 语句能执行”也是一个或一组表达式计算过程

     比如： 引擎的核心是一个表达式计算的、连续的执行过程。

2. 计算

   计算的实现：即计算求解的过程。更著名的说法为： 算法 + 数据结构 = 程序。

   - 语句执行是表达式计算、函数调用也是表达式计算，各种特殊执行结果还是表达式计算
   - 而计算必然会有结果的产生

3. “计算”总会有一个返回值

   讲到此处似乎还是没有提到 引用与静态语言的处理，继续看下去吧。

#### 2.1 引用

> ❓ 表达式的结果一定是一个引用类型吗？一定要通过GetValue获取吗？
>
> ​	    不一定， 表达式执行会返回两个东西：它要么直接返回一个“上面的完成结果所理解的值（即值类型，即typeof可识别的类型，js可识别的类型）”，要么返回一个 包含这样的值的“引用”， 
>
>  		console.log(x)  console.log(1) 其中1也是一个单值表达式，你可以看表达式的总结。
>
> ❓ 语句的result一定是 Completeion Special Type吗？
>
> ​	 必然是。

而这个问题——JavaScript 中最核心的两种执行过程（它们都被称为 evaluating）是如何最终被统一的？

1. 一条语句的result， value最终只能为值，因为若是引用类型，会调用GetValue（ref）

2. 表达式的result

   表达式执行会返回两个东西：它要么直接返回一个“上面的完成结果所理解的值”，要么返回一个包含这样的值的“引用”， 

⭐ result 分为两大类

- statement时， Completion Specification Type

  这是: 一个语句的完成状态

  1. type

  2. value  可为   Primitive values、Object、Empty

  3. target

- expression时， Reference Specification Type

  1. base

  2. name

  3. strict

  4. thisValue

     ⭐ 引用类型的值是通过 GetValue(ref)来获取 ，从而让其一定有可见到的内容

     ⭐ ref 便是ref，引用类型的目的便是 【指针】，指针： 指向这个内容的一个结构

#### 2.2 静态语言的对引用的处理

1. 语句的result一定是可以JS可以理解的类型（typeof可以理解的类型）

   若 语句的【result】的【value】其为 【引用类型】则必“GetValue(x)”替代其vlaue。

   ❗ 只有语句的有 value, ref 的result要通过 getValue（ref）

2. 语句中，可以在“value”域中放上Empty，这表明语句执行“没有值”

3. 此外完整的概念集是：值（value）、引用（Reference）和不可发现的引用（UnresolvableReference）。

   delete x，或者typeof x， 在严格模式中，不可发现的引用，会在语法分析阶段就报异常

### 3 表达式

表达式这里进行了额外的整理与理解。 https://www.zhihu.com/question/39420977?sort=created\

⭐  基本表达式、复杂表达式都是【单值表达式】，未使用运算符，单值表达式的结果是值本身。

而其他表达式结果是根据运算符进行运算的结果值。

- 非单值（复合）表达式：由运算符将多个单值表达式结合而成的表达式

#### 3.1 基本表达式

这类表达式是原子表达式**，是无法再分解的表达式。**

- this、null、arguments等内置关键字
- 变量
- 字面量。仅包括数字字面量、布尔值字面量、字符串字面量、正则字面量
- 分组表达式 

#### 3.2 复杂表达式

这类表达式**需要其它表 达式参与**

1. 对象的初始化表达式、数组的初始化表达式

2. 函数定义表达式

   ````js
   let a = function() {}
   ````

3. 属性访问表达式

   注意： 对象后面的句点或者方括号不是运算符，是属性访问表达式的语法结构的一部分，不是运算符

   ````js
   expression1[expression2]
   expression.identifier
   ````

4. 调用表达式： “方法调用”与“函数调用”

   ```js
   # expression是一个返回值为函数对象的属性访问表达式
   expression0([[expression1[,expression2[,expression3]]]);
   # expression0是函数对象
   expression0([expression1[,expression2[,expression3]]]);
   ```

5. 对象创建表达式

   ```js
   new expression0([expression1[,expression2[,expression3]]])
   ```

### 4 结构与体系的回顾

> 前 11 讲的主题

#### 01 | delete 0

讲述： “规范引用”的概念。

Result 来指代 “【引用状态】还是【值状态】”这种未区分的结果状态。

- 未区分的原因： 同一个标识符，在作为 _lhs_ 和 _rhs_ 的时候意义是不同的
- 在计算没有“推进到”下一步之前，上一步的 Result 是无法确知“将作为”lhs/_rhs_ 的哪一种操作数的

且是存在一部分操作符可以直接操作【规范类型】的

- delete x

#### 02 | var x = y = 100

1. 六种声明： 是“静态分析的结果”，而非“动态执行的结果”

2. 这行代码前者是声明语义”，后者称为“执行语义”。

   声明语义就是静态语言的处理，执行语义就是动态语言的处理。这是两种语言范型的分水岭

3. 这并非是连续赋值表达式。

#### 03 | a.x = a = {n:2}

1. 这是一个连续赋值的表达式
2. 介绍了引用，并讲述了【语句】与【表达式】的差异与区别。

