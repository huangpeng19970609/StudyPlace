## 05 | 变量作用域、词法作用域与迭代环境

> for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销

1. 语义： 顺序、分支、循环，其他语句的语义不值一提

###  块级作用域-1

> 除了以下语句，其他所有语句其都没有块级作用域。
>
> ps: 它们自身语句（例如if）不涉及作用域， 而其附带的块语句是作用域

1. `switch语句`被设计为有且仅有一个作用域。 无论它有多少个 case 语句

   - 任意分支的声明都会给该作用域添加这个标识符！
   - 单纯认为就是 是块语句即可。 

   ```js
   var x = null;
   switch (c) {
       case 0: 
           console.log(x);  ❌ refrence error
       	break;
       case 1: 
           let x = 1;
   }
   ```

2. 三个语句 + 一个特例 【for循环】

   - try语句： try、catch、finally也是特别的作用域
   - with语句： with
   - 块语句： {}

   ```js
   try {
   	# 作用域1
   }
   catch (e) {
       # 作用域2
   }
   finally {
       # 作用域3
   }
   
   with(x); /* 作用域1 */; // <- 这里存在一个块级作用域
   
   {}
   ```

3. 一个特例也带着块语句

   - while 和 do..while 语句 是不涉及自己的块语句的 【请务必区分 whle与块语句】

   - 而有一个for 语句自身便有块级作用域， 注意 【var】 声明的 不在此列。

     ````js
     for ( let/const ... of ...) ...
     for ( let/const ... in ...) ...
     for ( let/const x ) ...
     ````


### 块级作用域-2

> 探究此特例的前提我们应该了解什么是语句？

- 语句

  语句存在（组成）的内容只有这四类，这并不重要。

  - 表达式 、其它语句、标识符声明 
  - 一种特殊的语法元素，称为“标签（例如标签化语句，或 break 语句指向的目标位置）

1. 什么是块级作用域

   ⭐ 块级作用域的本质便是一组标识符。

2. 为什么需要块级作用域

   潜在的标识符冲突的时候便需要新的作用域去管理他们。

   举例： 函数每次调用时， 其存在【重新进入之前】的标识符，从而需要作用域管理（这便是闭包）

   - 标识符管理 需要作用域
   - 语法支持多语句时， 比如 try、catch、finally的三处作用域
   - 语句表达的语义就是一个作用域。例如 块级语句 {}

3. 结论

   - 标签、表达式和其它语句 并不是 产生作用域的原因，也不需要作用域管理。

   - 若语句出现了标识符，那么显然是需要作用域管理的。

   - 故 for 为什么会有作用域的答案显然推出。

     ```js
     for (let/const )..
     ```


4. 示范

   - 与【if语句】本身无关

     ````js
     if (x) {
       ...
     }
     // or
     if (x) {
       ...
     }
     else {
       ...
     }
     ````

   - switch

     ````js
     var x = 100, c = 'a';
     # 这就是 let 带来的暂时性索取 [ 预编译时期变量的提前声明 ]
     # 作用域添加这个标识符
     switch (c) {
       case 'a': 
         console.log(x); // ReferenceError
         break;
       case 'b':
         let x = 200;
         break;
     }
     ````

### 特例-循环语句中的块

- 并非所有循环都有属于自己的块级作用域

  如while、do...while语句本身无自己的块级作用域

  ````js
  while ( let i = ) ❌
  ````

- for 语句拥有

  注意： 我们在此处没有列出var， 具体原因将在后续解释出来。

  ```js
  for (let/const i)  // 同理 for in、for of
  ```



#### 01| 为什么要有这个特例

为什么我们要称呼 for 循环是一个特例？

语句中包含了标识符声明”的情况下，需要创建块级作用域来管理这些声明出来的标识符。

- for语句允许标识符的声明

  存在标识符声明因而会出现潜在标识符冲突的问题

- 故 for语句 需要一个“独立作用域”去管理

#### 02| 排除 【var】 声明

- 原因
  1. 最初的js作用域仅存在 【函数内】与【函数外】两种，仅此而已。
  2. 而语句 for 循环中出现了 声明，其是变量提升，在全局中登记名字。

ES6实现的时候依旧遵从了这一点。有两种方案去专门处理。

1. 变量作用域

   所有“var 声明”和函数声明的标识符都登记为 varNames

2. 词法作用域

   其它情况下的标识符 / 变量声明，都作为 lexicalNames 登记，使用“词法作用域”管理。

#### 03| for (let x)

1. 既然语句中有有了作用域，那么循环体是否需要作用域?

   - 这由语言设计决定

     循环体（单个语句）允许支持新的变量声明，

     为了避免它影响到循环变量，就必须为它再提供另一个块级作用域

   - 但 js如何处理呢?

     `单语句不支持词法声明` 这种语法其实普遍存在于JS中，不过很难见到，因为毫无意义。

     ````js
     for (let x = 102; x < 105; x++) let x = 200;
     SyntaxError: Lexical declaration cannot appear in a single-statement context
     ````

2. 循环体是否需要作用域的根本原因

   - 若 for 语句仅有一个块级语句那么显然不可以重复的去执行 声明标识符

      (let 语句的变量不能重复声明的)

   - 解决办法:  为循环体增加一个作用域

     1. 【let  i】 就可以只执行一次
     2. 【i in x】  放在每个迭代中来执行

   ```js
   for (let i in x) ...;
   ```

### for循环的代价

从上得知

1. 循环体增加的作用域称为 loopEnv， for语句作用域可称呼为 forEnv
2. loopEnv 的外部环境指向 【forEnv】

看起来一切都很好，但问题在于 循环体内的复杂

````js
# for迭代结束 => i值可能变为最后一次迭代的值, 那么 forEnv的 i 仅有一个显然不对
for (let i in x) 
    setTimeout(()=>console.log(i), 1000);
````

故想让上述符合预期

1. loopEnv 就必须是“随每次迭代变化的”
   - 也就是说，需要为每次迭代都创建一个新的作用域副本，这称为`迭代环境（iterationEnv)`
2. 因此，每次迭代在实际上都并不是运行在 loopEnv 中，而是运行在该次迭代自有的 iterationEnv 中。

故答案

- 语法上这里只需要两个“块级作用域”
- 而实际运行时却需要为其中的第二个块级作用域创建无数个副本（迭代环境）。

### 思考题

````js
# ReferenceError: condition is not defined
while (condition) var i = 0;

# 单语句不许词法声明
while (condition) let i = 0;
````

为什么单语句 不许词法声明?

1. 单语句没有块级作用域 。

2. 而词法声明是不可覆盖的。

3. 答案

   循环体的变量无法拷贝 迭代环境。

## 06 | 语句执行

### 为代码语句标示一个位置

1. 20世纪60-70年代，将代码语句标识位置，因为难以维护、正确性的难以验证进而迸发了【结构化代码】

2. 【用位置标识代码】的目的是 `实现go to`的跳转，以转移流程

3. 现在 JS中不存在GOTO语句了，仅是分块代码（基于代码分块的流程控制技术）

   - 分块代码

     代码分块中想要实现GOTO，那它应该自己设计一个自己的GOTO。

     即“自己的设计自己实现，自己知情的情况下使用GOTO”

4. 现在实际编写代码中，我们已接触不到【程序地址】【标号】，这个GO能去哪里呢?

### 第一种中断

> 所谓中断，你可以这么理解： 
>
> 1. 什么是GOTO？  GOTO某个语句，可以【代表】中断某个语句的执行。
> 2. 中断某个语句的执行，可以【代表】我们到达此语句的结束位置。
> 3. 我们到达此语句的结束位置， 可使用【break】作为子句来实现。

故我们可以使用

- js中已存在的`【所有循环语句】`都可以使用 break， 中断当前语句执行。将执行逻辑将于下一语句
- `switch语句`

### 第二种中断

> 中断【任意标签化的语句】

由于我没使用过【标签化语句】故在此演示，当然显然标签化语句是被人唾弃的？

#### 标签化语句 | 位置

1. 标签化语句示范

   ````js
   # break 跳出的不是一重循环， 而是outermost这个标签语句
   <script>
     var iNum = 0;
     outermost:
     for (var i = 0; i < 10; i++) {
       for (var j = 0; j < 10; j++) {
         if (i == 5 && j == 5) {
           break outermost;
         }
         iNum++;
       }
     }
     console.log(iNum); // 55
   </script>
   ````

2. 提出疑问

   ````js
   aaa: {  }
   bbb: if (true) { }
   ````

   - 上述代码的疑问

     1. aaa 无疑问， aaa 作用域必然是指 后面的块语句

     2. 而 bbb呢？

        首先 if 语句并没有作用域， 故  不可以 if （var a ）这种写法

        那bbb 到底是指 这个 【if】 语句呢？还是其后的 块语句 呢？

     3. 标签【bbb】到底指什么？

3. 关于 标签语句

   - ⭐标签 bbb 在语义上只是要“`标识其后的一行语句`”， 标签化语句理解的是`“位置”`
   -  标签语句 与 语句在执行代码的范围无关（与词法环境无关、块级作用域无关）

示范

- 在if语句的两个分支中都可以使用break； 包括双重循环也可以使用 break aaa、
-  在try...catch...finally中也可以使用break;

````js
aaa: if (true) {
   break aaa;
}
else {
  break aaa;
}
 
bbb: try {
  ...
}
finally {
  break bbb;
}
````

#### 对try-catch的特别示范

- console.log("Hi");

- return i++; 

- finally {  break bbb }

- console.log("Here");

- return i

  > 来解释一下原因
  >
  > 为什么遇到了 return i++ 也确实执行了 i++， 为何又没有跳出 foo这个函数？而是直接跳进了 finally 中的break
  >
  > 1. js设计如此，当你妄图再try中去跳出，那必然会走到finally，因为这是位置的跳出
  >    - 遵循try 无论如何怎么跳出都会执行 finally 这里
  >    - 这恰是证明 标签语句 与 【语句在执行代码的范围无关】， 与【位置】的概念有关
  >    - 第一个return 无效的原因是因为设计的故此如此， 令这个return失效 但依旧执行

````js
  var i = 100;
  function foo() {
    bbb: try {
      console.log("Hi");
      return i++; //  <-位置1：i++表达式将被执行
    }
    finally {
      break bbb;
    }
    console.log("Here");
    return i; //  <-位置2
  }
  console.log(
    foo()
  );
````

> break语句本质上就是作用于其后的“一个语句”，而与它“有多少个块级作用域”无关 **

### 执行现场的回收

⭐ 单对于 【break】而言，其将【代码块】理解为【位置】， 而非作用域 / 环境。请牢记。

你可以将其称做`执行现场的回收`，这种事情只会出现在【使用标签的代码上下文】中。

- 执行现场
  1. JS执行机制包括【执行权】与【数据资源】两部分，代表【逻辑】与【数据】
  
  2. 块级作用域（词法作用域）本质便是保存执行现场的【瞬时状态】（快照）
  
  3. JS的运行环境为栈，而`栈顶`永远都是当前拥有【执行权】所有者的所持有的【快照数据】，
  
     即代码活动现场\执行现场。

再比如说

- JavaScript 的运行环境

  通过函数的 CALL/RETURN 来模拟上述“数据帧”在栈上的入栈与出栈过程

  1. 函数的调用， 相当于压入该函数的上下文环境

  2. 【全局或模块全局中执行的代码】、【Promise 中执行调度的那些内部处理】、

     所有的这些 JavaScript 内部过程或外部程序都统一地被`封装成函数`, 

     通过 CALL/RETURN 来激活、挂起

- “作用域”

  故 “作用域”就是在上述过程中被操作的一个对象。

  - 作用域退出，便是 函数RETURN
  - 作用域挂起，执行权转移
  - 作用域创建，闭包的初始化
  - ........

- 关于之前的【break labelName】这一语法

  1. 语法独立【执行过程】的体系，它表达式是一个`位置的跳转`，而不是数据栈的进出。

     labelName 独立于标识符体系（也就是词法环境）所带来的附加收益

  2. 这种特别之处令JavaScript设计了一种新的方法去清除此跳转带来的影响【即回收资源】

### 语句执行的意义

#### 【离开语句】代表清除语句所持有的一切资源，

⭐ JavaScript 是一门混合了函数式与命令式范型的语言，而这里对函数和语句的不同处理，正是两种语言范型根本上的不同抽象模型带来的差异

- 函数退出时回收闭包

  函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）

- 语句是命令

  语句执行的返回结果是该命令得以完成的状态

#### 站在ECMAScript上看问题

JavaScript 的执行都是语句执行。故执行的描述都称为“运行期语义“

1. 运行期语义：

   描述一个 JavaScript 内部的行为或者用户逻辑的行为的过程与结果， 换句话来说，

2. 运行期语义都最终会以一个完成状态（Completion）来返回。

   - 函数的调用

     调用函数——执行函数体（EvaluateBody）并得到它的“完成”结果（result）

   - 块语句的执行

     执行块中的每行语句，得到它们的“完成”结果（result）

3. 结果（result）包括的状态

   有五种，称为完成的类型：normal、break、continue、return、throw。

   任何语句的行为，要么是包含了有效的、可用于计算的数据值（Value）。

   故

   - 语句正常完成（normal）
   - 一个函数调用的返回（return）

   而若是不可用于计算或传递的纯粹状态：

   - 循环过程中的继续下次迭代（continue）
   - 中断（break）
   - 异常（throw）

4. `break`

   break作为 结果的五种状态之一。代表中断含义。

   而JavaScript会寻 此 break的目标位置，即【result.Target】，并于当前标签语句对比（若有）。

   - 若一样，取 break 源位置的语句执行结果为值（Value）并以正常完成状态返回；
   - 如果不一样，则继续返回 【break 状态】

   示范

   ```js
   console.log( 
       eval(` 
   		aaa: { 
   			1+2; 
   			bbb: { 
   				3+4; 
   				break aaa;
   			} 
   		}
   	`)
   ); // 输出值：7
   ```

   我们来解析这个问题， 来证明 ⭐·`语句执行总是返回它的完成状态`

   1. break触发时，标签化语句bbb首先捕获到此语句的完成状态，并携带标签 aaa
   2.  bbb触发时候检测到此标签中断目标（Target）为 自己标签不同，故所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa
   3. 语句aaa获得上述状态。对比标签成功。返回结果为语句3+4的值。（作为完成状态传出）

   > 所以，语句执行总是返回它的完成状态.
   >
   > 且如果这个完成状态是包含值（Value）的话，那么它是可以作为 JavaScript 代码可访问的数据来使用的。
   >
   > 例如，如果该语句被作为eval()来执行，那么它就是 eval() 函数返回的值。

### 中断语句的特殊性

【x: break x; 】回归标题这行代码有什么特别之处呢？

1. 最小化的 break 语句的用法。

   - 标签化语句”必须作用于“一个”语句，而【语句】理论上最小化形式便是【空语句】。

   - 为什么 

     【空语句】又不可作为break的目标标签语句（因为标签语句范围内你需要进行中断，若你不中断这便不是【中断语句】，因此最小化的示例就只能是对 break 语句自身的中断）

2. 不会对其他任何代码构成任何影响”的语句， 是JavaScript 中的特有设计

   - 【语句】与【函数】返回具有相似性。可不返回时出口信息为 undefined

   - 而虽然

     1. “break labelName”的中止过程是可以传出“最后执行语句”的状态的， 
     2. 但是⭐ 任何被 break 的代码上下文中，最后执行语句必然会是“break 语句”本身

   - 即若想实现【语句执行状态】的传递，则需确保

     1. “break 语句”不返回任何值（ECMAScript 内部约定用“Empty”值来表示）；
     2. 上述“不返回任何值”的语句，也不会影响任何语句的既有返回值

   - 而当前

     1. 它的类型必然是“break”；
     2. 它的返回值必然是“空（Empty）”。

   - 因此

     对于 Empty 值，在 ECMAScript 中约定：在多行语句执行时它可以被其他非 Empty 值更新（UpdateEmpty），而 Empty 不可以覆盖其他任何值。

   - 再因此

     这就是空语句等也同样“不会对其他任何代码构成任何影响”的原因了。

3. 在顺序执行时，当语句返回 Empty 的时候，不会改写既有的其他语句的返回值

4. 语句有返回值。

5. 标题中的代码，是一个“最小化的 break 语句示例

6. 有两种中断语句，它们的语义和应用场景都不相同。

### 评论区

1. 这是两个作用域

   - if语句本身，它是个“单语句”, 它没有块级作用域
   - 而后面的一对大括号“{}”，是一个“块语句”

   ````js
   if (true) {}
   ````

   > Real Aaro的见解

1.  JavaScript 的执行都是语句执行（包括函数执行）， 因语句类型而差异，但其结果都返回一个“完成”结果
2. 【函数语句执行】与【普通语句】执行存在区别
   - 函数语句的“完成结果”是值、是引用
   - 普通语句仅是一个完成状态 => Completion

> 桔子

- 函数中return的设计是为了传递函数的状态，break的设计则是为了传递语句的状态。
- break labelName只与“块”相关，与函数没直接关系。
- 许多语句是有“块（块级作用域）”的，而不仅仅是块语句（也就是一对大括号，它称为Block语句）。

## 07 |  模板

- 详解JavaScript中特殊的可执行结构

  ````js
  `${1}
  ````

### 01 | 何为模板

1. JavaScript 中，有语句和表达式两种基本的可执行元素。

   但不代表 JavaScript 中只有语句和表达式是可执行

   - 语句 => console.log()
   - 表达式 => window
   - 什么是可执行？

2. 模板是一种特殊的可执行结构

   既然是特殊的可执行结构，即这是一种固定的、确定的逻辑

