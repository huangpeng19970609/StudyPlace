## JS 与 DOM

### 1 event中target与currentTarget的区别

1. target返回的触发事件的元素 

   ⭐ 我们最常会用target进行 `事件委托`

   我虽然给的是一个 大的父极绑定的元素，

   但是点击哪个子元素时，event.target返回的是点击的元素节点

2. currentTarget返回绑定事件的元素

### 2 instanceof的原理

- 原理是 构造函数的 prototype 属性是否出现在对象的原型链中的任何位置、

  故instanceof总是返回的true与false

### 3 ES5 和 ES6 分别几种方式声明变量

 `let`、`const`、`class`声明的全局变量再也不会和全局对象的属性挂钩

- ES5 有俩种：`var` 和 `function`
- ES6 有六种：增加四种，`let`、`const`、`class` 和 `import`

但其本质都是 let、var、const

### 4 DOM 事件有哪些阶段？谈谈对事件代理的理解

- 事件代理： 

  事件不直接绑定到某元素上，而是绑定到该元素的父元素上， 此后再通过条件判断子元素。

  好处： 代码简洁，且开销更小

- 捕获阶段--目标阶段--冒泡阶段

  1. **捕获阶段** (从根节点开始顺着目标节点构建一条事件路径，`即事件由页面元素接收，逐级向下，到具体的元素`)

  2. **目标阶段** (到达目标节点，`即元素本身`)

  3. **冒泡阶段** (从目标节点顺着捕获阶段构建的路径回去， `即跟捕获相反具体元素本身，逐级向上，到页面元素`)

### 5 requestAnimationFrame

js做动画是以定时器为核心实现，下一次的宏任务可能被上一次的宏任务堵塞。

1. 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成

2. 更加智能。 更加的在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流

3. requestAnimationFrame更像是一个独立的任务队列。 GUI渲染之前执行，但在微服务之后。

   绝对是一个异步任务

### 6 Object.is(val, val2)

> 略微的更合理了一些

1. Object.is(valueA,valueB) 以与严格相等运算符相同的方式检查相等性的参数
2. NaN 等于另一个 NaN 值
3. Object.is() 区分 -0 和 +0

### 7 隐式转换

- 共有

  ````js
  Number()
  String()
  Boolean() // 用 !! 同理
  parseInt()
  parseFloat()
  ````

### 8 如何让 a === 1 & a === 2

```js
var a = {
    value: 0,
    valueOf :function(){
        this.value++;
    	return this.value;
	}
}
```

### 9 函数柯里化（Currying）

一个函数返回一个函数这便是函数柯里化。

### 10 原型链

#### 01 | 概念

````js
Person() 	  prototype  ->			Person.prototype 
        		 	 	  
Person() 	  <- constructor	    Person.prototype 

Person()	  <- constructor		person    	

person		   __proto__ ->			Person.prototype 
````

1. prototype

   废话： 构造函数 有 【prototype】属性， 即 原型对象A.protptype 

   实例对象  `__proto__` 等同于 A.prototype

2. constructor

   【实例对象】和【原型对象】有构造函数

#### 02 | 题目

1. 第一道题目

   a 是 实例对象， 故 a 有 --proto--，显然为false

   a的原型对象， 即 【--proto--】， 故为true

   ```js
   var a = {}
   var b = Object.prototype
   
   # [false, true]
   console.log([a.prototype === b, Object.getPrototypeOf(a) == b]);
   ```

2. 第二道题目

   f 为构造函数， a 为原型对象

   b 获取到 构造函数的原型对象， 故为true

   ```js
   function f() {}
   var a = f.prototype 
   var b = Object.getPrototypeOf(f); 
   
   console.log(a === b); 
   ```

   



## 二 CSS

### 1 BFC

块级格式化上下文 Block Formatting Context

1. margin会发生重叠

2. BFC的区域不会与float box重叠， 即 他不会让浮动流脱离了文档流。

   **可以阻止元素被浮动元素覆盖**

3. BFC独立，不会影响外部元素

创建BFC  满足其一
1. 存在浮动流
2. position是absoluted、fixed
3. 行内块元素、table-cell、flex
4. overflow不是visible
5. html根元素创建bfc元素

### 2 为什么要初始化 CSS 样式

- 不同浏览器对有些标签的默认值是不同的

### 3 CSS3的新特性

1. flex布局

2. :first-of-type,nth-child

3. transition 、transform、动画 @keyframes

4. 媒体查询 @media

5. 其余特性

   ```css
   透明     rgba（255, 0, 0, 0.75）；
   圆角效果  border-radius: 5px;
   渐变色    background:linear-gradient（red, green, blue）；
   阴影     box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；
   超出文字  text-overflow:ellipsis;
   边框背景   border-image:url（bt_blue.png） 0 10
   ```


### 4 flex为1

flex是 flex-grow、flex-shrink、flex-basis三个属性的简写。

它们都是用于 flex的子元素的。

flex默认是 0 1 auto

````css
flex: 1;

flex: 1 1 auto(0%);
````

- flex-grow

  1. flex-grow 属性决定了父元素在空间分配方向上还有剩余空间时，如何分配这些剩余空间。

  2. flex-grow 默认为0，存在剩余的空间也不会放大。

- flex-shrink

  1. flex-shrink 属性定义空间不够时各个元素如何收缩。其值默认为 1。

  2. 每个元素收缩的权重为其 flex-shrink 乘以其宽度。

  3. 例子

     父元素 500，子元素 150、200、300

     flex-shrink为 1、2、3

     - 总共超出 150px
     - 总权重为： 1* 150 + 2 * 200 + 3 * 300 = 1450

     故计算收缩

     总收缩宽度 * flex-shrink * 各自权重宽度 / 总权重宽度

     - 150 * 1 * 150 / 1450  = 15.5
     - 150 * 2 * 400 / 1450 = 41.4
     - 150 * 3 * 900 / 1450 = 93.1

     故最终宽度为

     - 150 - 15.5 = 134.5
     - 200 - 41.4 = 158.6
     - 300 - 93.1 = 206.9

- flex-basis

  指定了flex元素在主轴方向上的初始大小（属性定义了在分配多余空间之前，项目占据的主轴空间（main size））

  浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

### 5 盒模型

- 组成盒模型

  1. content-box
  2. padding-box
  3. border-box
  4. margin-box

  margin-box也是组成盒子模型，但应注意，其决定不了实际盒子模型的宽高，只是表明了占比空间。

- 标准盒模型

  块级元素和inline-block元素

  1. width、height 即 content-box
  2. padding-box
  3. border-box

  注意 margin 并不计入实际的大小，虽然影响本盒子的页面占用空间， 但其影响的仅是外部空间。

- 怪异盒模型（ie盒子模型）

  由标准盒子可知，我们设置宽度其实并非是此盒子的真正宽度，它总要额外的计算。故额外提供了一个盒子来避免这个问题。

  这样 width 就是实际此盒子的width，您不需要再关心 border、padding了

  ````css
  .box {
  	box-sizing: border-box;    
  }
  ````

  1. 可以设置 `box-sizing` 在 `<html>` 元素上，然后设置所有元素继承该属性
  2. 此时margin也视作 外部空间。这无论在何时都是统一的，这也是margin存在的意义。    





## 四、Webpack

### 1 常见 loader 和 plugin

- 常见loader

  1. 样式：style-loader、css-loader、less-loader、sass-loader等

     - post-css： 根据browserlist，解决css在不同浏览器的兼容
     - postcss-preset-env： 解决CSS新特性兼容问题

  2. 文件：

     raw-loader （文件原始内容）

     file-loader (文件夹中，再以相对引用)

     url-loader

  3. 编译：babel-loader、、ts-loader等

  4. 校验测试: eslint-loader等

- 常见plugin

  1. webpack内置`UglifyJsPlugin` 压缩和混淆代码
  2. webpack内置`CommonsChunkPlugin`，提高打包效率，将第三方库和业务代码分开打包
  3. `html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件
  4. `DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。
  5. `HotModuleReplacementPlugin` 热更新
  6. `CleanWebpackPlugin` 自动删除打包资源
  7. ignore-plugin 忽略部分文件
  8. mini-css-extract-plugin 分离样式文件

### 2 为什么loader是反向的？

函数组合编程。

有两种函数组合的方式，一种是pipe，另一种是compose。前者从左向右组合函数，后者方向相反。

Webpack选择了compose方式，而不是pipe的方式而已，在技术上实现从左往右也不会有难度

### 3 webpack配置优化

### 4 若postcss打包less的时候 @import的时候要注意什么？

- 按理应该 less-css-loader => post-css-loader => css-loader => style-loader

⭐`@import 的语法是在 js中的（此时负责的模块为 css - loader ）`，

- 故此时 css-loader => style-loader， 不会被解析， 你应该设

  ```js
   {
              loader: "css-loader",
              options: {
                importLoaders: 2 // 回调两层 即 less -> post -> css
              }
            },
  ```

### 5 处理文件的loader有哪几种？

1.  file-loader 
2. url-loader
   - 通过limit设置 url-loader 将较小的文件转为` base64 的URL`
3. webpack5 提供资源模块可以更快速

### 6 loader与plugin

1. loader用于转换模块类型，本质是就是函数、翻译官，并返回对应结果。

2. 插件目的在于解决 [loader](https://webpack.docschina.org/concepts/loaders) 无法实现的**其他事**、拓展webpack功能

3. Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。

   让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，

   Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果

### webpack的热更新原理

Hot Module Replacement 也可以叫做热替换，对应也有这样的插件

- 核心

  客户端 从 【服务器端】拉取更新后的文件。

1. 本地资源变化， WDS（**webpack-dev-server**）检测到，故会向浏览器推送更新，并带上构建时的hash，以此让客户端与上一次的资源进行对比。
2. 客户端对比差异后，会向WDS发起请求以获取要更改的内容。
3. 后续拿到的【增量更新】的具体处理由【HotModulePlugin】来处理。略。

### babel原理

1. 解析 以生成 AST

   词法分析 + 语法分析

2. 转换

   将AST的节点变更为新的AST

3. 生成

   以新的AST为基础生成代码。

### 优化webpack构建速度

这真的很广很广

1. 压缩代码的速度提升

   - 多线程。

     压缩代码转换AST，但我们可以开启多线程的压缩代码。我们使用并行的方案。

     如 一些压缩插件的开启 parallel参数。

   - 开启缓存。 new ParallelUglifyPlugin() 实例化时，你可以

     `cacheDir`：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回

     1. babel-loader 开启缓存
     2. terser-webpack-plugin 开启缓存

2. 忽略一些不需要打包的文件

   - exclude、include
   - noParse 
   - IgnorePlugin 

3. TreeShaking

   打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉.

   但这需要你开发中尽可能使用ES6 Module的模块。

4. 使用 `DllPlugin` 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。

5. 保证webpack的版更新。

6. 减少resolve参数中对文件进行的判断处理，如extensions后缀尝试。

7. 更多的性能优化，请参考官方的webpack构建速度提升

### 问webpack你应该如何回答

- webpack的作用

  1. 模块打包
     - 模块转换
     -  依赖关系树
  2. 编译兼容 （loader）
     - polyfill： 新语法新特性的实现
     - 浏览器兼容
  3. 能力拓展 （plugin）
     - 如按需加载
     - 如代码压缩

- 模块打包的原理

  webpack是如何这些模块合并到一起的？那你应该先了解打包的流程

  - 打包流程

    1. 读取webpack配置参数（webpack文件）
    2. 启动【webpack】，创建【Compiler】对象，并开始来解析项目。
    3. 解析项目： 从入口文件开始，找寻其依赖模块、递归遍历分析，以形成依赖树
       - 遇到不同文件类型的依赖模块文件使用对应【loader】编译，转换文件
       - 过程中，webpack会【发布订阅】，以此达到【hooks】，从而让【plugin】监听关键的事件节点，让其插件任务执行，以达到能力拓展。

  - compiler对象

    是全局单例，把控webpack打包的构建流程。

  - 【compilation】是每一次构建上下文对象，它包含了本次构建的所有信息。而每次【热更新、重新部署】又会生成新的【compilation】，以负责更新构建过程。

  原理

  ​	为每个模块创造了一个可以导出和导入的环境。以另一种形式如预期一样被加载进来。

- sourcemap

  它是生产代码（编译压缩、打包后的代码）映射回源代码的技术。

  浏览器必须支持 sourcemap技术： 浏览器就会通过`sourceURL`去获取这份映射文件。

- 是否写过loader？

  webpack默认只处理js模块，遇到非js文件时，便需要loader。

## N 笔试

### 0 题目汇总⭐

1. 节流与防抖 答案: 略
2. 深拷贝 考虑的情况很多， 答案是一个非常完美的示范
3. 数组去重
4. 数组乱序
5. 手写 call、apply与bind
6. 继承 （ES5、ES6）
7. sleep函数
8. 实现promise、

### 2 深拷贝

- 关于正则拷贝的疑问

  ````js
  var regexp = new RegExp('xyz', 'gim'); => var regexp = /xyz/gim;
  
  									  xyz			gim
  const result = new target.constructor(target.source, reFlags.exec(target));
  ````

  

答案

````js
//判断数据是不是引用类型
function isObject(target) {
  return (
    target !== null &&
    (typeof target === "object" || typeof target === "function" || typeof target === 'symbol')
  );
}
// symbol、reg、function
function cloneType(type, target) {
  if (type === 'symbol') {
    return Object(Symbol.prototype.valueOf.call(target))
  }
  if (type === 'reg') {
    // 匹配字母、数字、下划线
    const reFlags = /\w*$/;
    // source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠			以及任何的标志字符。
    // JavaScript 正则表达式 constructor 属性返回 function RegExp() { [native code] }
    const result = new target.constructor(target.source, reFlags.exec(target));
    result.lastIndex = target.lastIndex;
    return result;  
  }
  if (type === 'function') {
    return function () {
      targe.call(this, ...arguments);
    };
  }

}

function init(type) {
  let result = null;
  switch (type) {
    case "[object Array]":
      result = [];
      break;
    case "[object Object]":
      result = {};
      break;
    case "[object Map]":
      result = new Map();
      break;
    case "[object Set]":
      result = new Set();
      break;
  }
  return result;
}

function deepClone(target) {
  let map = {};
  const result = clone(target, map);
  map = null;
  return result;
  function clone(target, map) {
    const isObj = isObject(target);
    const type = Object.prototype.toString.call(target);
    if (isObj) {
      let result = null;
      // 初始化
      result = init(type);
      if (type === "[object Object]") {
        const keys = Object.keys(target);
        keys.map(key => {
          //解决循环引用
          if (map[key]) return map[target];
          else {
            result[key] = clone(target[key], map);
            map[key] = result;
          }
        });
      }
      else if (type === "[object Array]") {
        const len = target.length;
        let i = -1;
        while (i++ < len - 1) {
          result[i] = clone(target[i], map);
        }
      }
      else {
        switch (type) {
          case "[object Date]":
            result = new Date(target);
            break;
          case "[object RegExp]":
            result = cloneType('reg', target);
            break;
          case "[object Function]":
            result = cloneType('function', target);
            break;
          case "[object Set]":
            target.forEach((value) => {
              result.add(clone(value, map));
            });
          case "[object Map]":
            target.forEach((value, key) => {
              result.set(key, clone(value, map));
            });
            break;
          case "[object Symbol]":
            result = cloneType('symbol', target);
        }
      }
      return result;
    }
    // 非对象 基本类型
    if (!isObj) {
      return target;
    }
  }
}
````

### 3 数组去重

> 1. 利用语法自身或键不可重复的特性使用重复
> 2. 循环比较去除重复

1. Set助我！

   - Set本身不可重复

   ```js
   Array.from (new Set(arr))
   ```

2. Map助我

   - Map的键名不可重复

   ````js
   // 你当然可以通过myMap.has(key)来优化
   arr.map(item => {myMap.set(item, null)});
   myMap.forEach((item, key) => {
       myArr.push(key);
   })
   ````

3. 双重循环去除重复

   > 实现方法大同小异

   ```js
   for (let i = 0; i <= arr.length - 1; i++) {
     let j = arr.length;
     while (--j > i) {
       console.log(j);
       if (arr[i] === arr[j]) {
         arr.splice(j, 1)
       }
     }
   }
   ```

4. `indexOf` 去除重复

   `includes` 同理 略

   你也可以用filter过滤， 但没必要吧，以上四种已经很简便了

   ```js
   let array = []
   for (var i = 0; i < arr.length; i++) {
     if (array.indexOf(arr[i]) === -1) {
       array.push(arr[i])
     }
   }
   console.log(array);
   ```

### 4 数组乱序

> 数组进行乱序处理 不过这是虚伪的随机

````js
arr.sort(function () {
   return .5 * Math.random(); 
});
````

- 更好的实现

  ```js
  function shuffle(array) {
      var m = array.length,
          t, i;
      while (m) {
          i = Math.floor(Math.random() * m--);
          t = array[m];
          array[m] = array[i];
          array[i] = t;
      }
      return array;
  }
  ```

  

> 题目升级: **有一个长度为 100 的数组，如何从中随机挑选 50 个元素，组成一个新的数组？**

洗牌算法

````js
function getRandomArrElement(arr, count) {
    let shuffled = arr.slice(0), 
        i = arr.length, 
        min = i - count, 
        temp, 
        index;
    while (i > min) {
        index = Math.floor((i--) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}
````

### 5 call、apply与bind

此外： https://segmentfault.com/a/1190000020871501

1. call

   - 将函数设为对象的属性

   ````js
   Function.prototype.myCall = function(_this = window) {
     _this.fn = this;
     let args = [...arguments].slice(1);
     let result = _this.fn(...args);
     delete _this.fn;
     return result;
   }
   ````

   

2. apply

   ````js
   Function.prototype.myApply = function(context = window, args = []) {
     context = context || window; // 参数默认值并不会排除null，所以重新赋值
     context.fn = this; // this是调用call的函数
     const result = context.fn(...args);
     delete context.fn;
     return result;
   }
   ````

3. bind

   ```js
   Function.prototype.myBind = function(context, ...args) {
     const _this = this;
     return function Bind(...newArgs) {
       // 考虑是否此函数被继承
       if (this instanceof Bind) {
         return _this.myApply(this, [...args, ...newArgs])
       }
       return _this.myApply(context, [...args, ...newArgs])
     }
   }
   ```

### 6 继承 （ES5、ES6）

#### 1 寄生组合式继承

- `组合式继承`: 原型链+构造函数

  1. 独享【属性】或【方法】用`构造`

  2. 共享【属性】或【方法】用`原型`！

     ````js
     function Father(name) {}
     Father.prototpe.say = function() {}
     
     function Son() {
         Super.call(this); # 继承属性
     }
     #1 继承方法 当然此处也会继承属性，不过由于存在相同的实例属性故会被拦截
     Son.prototype = new Father();
     ````

- `寄生式继承的`

  1. 首先要明白 `原型式继承`

     - 相当于又一个person的拷贝， 若其有引用类型，则是共有属性！在你不覆盖的前提下！

       不通过prototype便可以实现了一个共有属性！

     - 你可以`增强`这份`拷贝`

     ````js
     var person2 = Object.create(person, {
        name: {
         	value: 'Greg',  
        },
     });
     ````

  2. 寄生继承

     寄生继承 面对的是 对象这种类型，故给他起名字为寄生。 原理其实与原型式继承几乎相同。

     我只要返回一个新的对象给你，那么其实就是可以称呼其为寄生继承

     ```js
     function inheritProtoType(son, father) {
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

- `寄生组合式继承`

  1. 组合式继承

     独享【属性】或【方法】用`构造`

     共享【属性】或【方法】用`原型`

  2. 寄生继承解决继承的时候问题

     > 由于既需要继承 父类的 公有属性与方法， 也需要继承私有属性与方法， 那便会导致多余的一次构造被调用。

     ```js
     function Sub(age) {				# 构造函数继承（实例化父属性）
         Super.call(this);            
     	this.age = age;
     }
     								# 原型继承
     Sub.prototype = new SuperType();
     ```

     > 故有什么好办法，让原型继承不执行构造函数呢？ => 寄生继承``

     本质就是将原型改为对象，再指下。很好理解！确实如此！

     ```js
     function inheritProtoType(son, father) {
         
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

#### 2 ES6继承

> 1. `extends`实现原型继承
>
>    ```js
>    class A extends B{}
>    
>    Student.__proto__= Person
>    Student.prototype.__proto__ = Person.prototype;
>    ```
>
> 2. `super`实现父类实例继承
>
>    ⭐ 子类必须在constructor方法中调用super方法
>
>    ​       是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象
>
>    ````js
>     1 class Colorpoint extends Point {
>     2     constructor(x,y,color){
>     3         super(x,y); //调用父类的constructor(x,y)
>     4         this.color = color
>     5     }
>     6	}
>    ````
>
>    

示范

````js
class super{
    constructor(name,color){
        this.name=name;
        this.color=["red","blue","green"];
    }
    sayName(){
        alert(this.name);
    }
}
````

### 7 sleep函数

> sleep函数作用是让线程休眠，等到指定时间在重新唤起。js单线程是`不能实现休眠的`

1. 无线循环， 直至时间结束，虽然毫无意义，但是实现sleep, 但极消耗CPU

   ```js
   function sleep(time) {
     let t = Date.now();
     while (Date.now() - t < time) {
     };
   }
   ```

2. 通过回调，但是其作为另外的任务，并不对杜塞这个进程的其他代码继续执行

   故使用 async await吧， 虽然本质也是Promise， 将后续杜塞的代码都应是在Promise的回调中吧!

   ```js
   function sleep(time) {
       return new Promise((resolve) => {
       	setTimeout(resolve, time)
       })
   }
   sleep(1000).then( () => {})
   ```

   

### 8 实现promise与其附属函数

#### Promise

https://segmentfault.com/a/1190000023690122?utm_source=sf-similar-article

````js

const PENDDING = 'pendding';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';
// 定义MyPromise
function MyPromise(executor) {
  const self = this;
  self.status = PENDDING;
  self.data = undefined;
  self.callbacks = [];

  function resolve(value) {
    if (self.status !== PENDDING) return;
    self.status = FULFILLED;
    self.data = value;
    // 立即执行异步回调函数，即他肯定是在then加入事件后再去执行他们，也考虑了同步问题
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onResolved(value);
      })
    })
  }

  function reject(reason) {
    if (self.status !== PENDDING) return;
    self.status = REJECTED;
    self.data = reason;
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onRejected(reason);
      })
    })
  }
  executor(resolve, reject)
}

// MyPromise原型链上存在then方法
MyPromise.prototype.then = function (onResolved, onRejected) {
  const self = this;
  return new MyPromise((resolve, reject) => { // 每次都返回一个新的Promise对象
    // 首先判断当前状态
    if (self.status === FULFILLED) {
      /* 
          1、返回的Promise的结果是由onResolved/onrejected决定的
          2、返回的是Promise对象 (根据执结果决定Promise的返回结果)
          3、返回的不是Promise对象 (该值就是Promise的返回结果)
          4、抛出异常 异常的值为返回的结果
      */
      setTimeout(() => {
        try {
          const result = onResolved(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === REJECTED) {
      setTimeout(() => {
        try {
          const result = onRejected(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === PENDDING) {
      self.callbacks.push({
        onResolved() {
          try {
            const result = onResolved(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        },
        onRejected() {
          try {
            const result = onRejected(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        }
      })
    }
  })
}
````

#### Promise.all / Promise.race

````js
//MyPromise实例对象上存在all方法
MyPromise.all = function (promises) {
    let promisesCount = 0
    let values = new Array(promises.length);
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(value => {
          promisesCount++;
          values[index] = value;
          if (promisesCount === promises.length) {
            resolve(values);
          }
        }, reason => {
          reject(reason);
        })
      })
    })
}

//MyPromise实例对象上存在race方法
  MyPromise.race = function (promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(value => {
          resolve(value);
        }, reason => {
          reject(reason)
        })
      })
    })
  }
````

####   Promise.resolve  / Promise.reject

````js

MyPromise.resolve = function (value) {
    if (value instanceof MyPromise) return value;
    // 返回一个resolved状态的Promise对象
    return new MyPromise(resolve => resolve(value))             
}

//MyPromise实例对象上存在reject方法
MyPromise.reject = function (reason) {
    return new MyPromise((resolve,reject) => reject(reason));  // 返回一个reject状态Promise对象
}
````

### 9 并发请求的限制

> 请实现如下函数，
>
> 可以批量请求数据，所有 URL 地址在`urls`参数中，同时可以通过`max`参数控制请求的并发度，
>
> 当所有请求执行结束后需要执行`callback`回调函数，请求函数用 fetch 即可(不做请求失败处理)。



#### 思路一

- 利用async + await 与 promise.all 来进行， 每次以max来进行请求

````js
// 根据max将一维数组切成二维数组
const group = (list = [], max = 0) => {
  if (!list.length) {
    return list
  }
  let results = []
  for (let i = 0, len = list.length; i < len; i += max) {
    results.push(list.slice(i, i + max))
  }
  return results
}

const requestHandler = async (
  groupedUrl = [],
  callback = () => { }
) => {
  if (!groupedUrl.length) {
    callback()
    return groupedUrl
  }
  const newGroupedUrl = groupedUrl.map(fn => fn())
  const resultsMapper = (results) => results.map(callback)
  const data = await Promise.allSettled(newGroupedUrl).then(resultsMapper)
  return data;
}

// 单纯的请求入口
const sendRequest = async (
  urls = [],
  max = 0,
  callback = () => { }
) => {
  if (!urls.length) {
    return urls
  }
  const groupedUrls = group(urls, max)
  const results = []
  console.log('start !')
  for (let groupedUrl of groupedUrls) {
    try {
      const result = await requestHandler(groupedUrl, callback)
      results.push(result)
      console.log('go')
    } catch { }
  }
  console.log('done !')
  return results
}

// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p1'))
const p2 = () => Promise.resolve(2)
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p3'))
const p4 = () => Promise.resolve(4)
const p5 = () => new Promise((resolve, reject) => setTimeout(reject, 2000, 'p5'))
const p6 = () => Promise.resolve(6)
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))
const p8 = () => Promise.resolve(8)
const p9 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p9'))
const p10 = () => Promise.resolve(10)
const p11 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p10'))
const p12 = () => Promise.resolve(12)
const p13 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p11'))
const p14 = () => Promise.resolve(14)

const ps = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]
sendRequest(ps, 3, ({ reason, value }) => {
  console.log(reason || value)
})

````

#### 思路二

```js
function requestData(promiseList = [], max = 1, callback) {
  let requestArr = [],
    i = 0;
  // 我们将请求的promise一项一项丢入到其中（递归实现），执行完毕就删除掉
  // requestArr到达上限那么我们等待请求执行，有空位在继续添加
  // 
  toFetch().then(() => Promise.all(requestArr)).then(() => {
    callback('进程结束！');
  })

  function toFetch() {
    // 递归结束
    if (i === promiseList.length) return Promise.resolve();
    let _item = promiseList[i++]();
    console.log('进程进行中');
    requestArr.push(_item);
    // 宏任务执行结束后, 微任务执行，删除对应的那个微任务
    _item.then(() => { 
      requestArr.splice(requestArr.indexOf(_item), 1)
     });
    let result = Promise.resolve();
    // 是否需要进行并发处理?
    if (requestArr.length === max) {
      result = Promise.race(requestArr);
    }
    // 若有空位继续， 若无空位等待 => then
    return result.then(() => toFetch());
  }

}



// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p1'))
const p2 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p2'))
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p3'))
const p4 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p4'))
const p5 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p5'))
const p6 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p6'))
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))

const ps = [p1, p2, p3, p4, p5, p6, p7]

requestData(ps, 4, (reason, value) => {
  console.log(reason || value)
})


```

### 使用reduce实现累加

- 答案

  ⭐ 上次执行函数时的结果保存在了pre中!

  ````js
  // 4.使用reduce方法
  var numbers = [1, 2, 3, 4]
  var total = numbers.reduce(function (pre, cur) {
      return pre + cur
  })
  alert(total)
  ````

- s





