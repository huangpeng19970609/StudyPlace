## JS 与 DOM

### 1 event中target与currentTarget的区别

1. target返回的触发事件的元素 

   ⭐ 我们最常会用target进行 `事件委托`

   我虽然给的是一个 大的父极绑定的元素，

   但是点击哪个子元素时，event.target返回的是点击的元素节点

2. currentTarget返回绑定事件的元素

### 2 instanceof的原理

- 原理是 构造函数的 prototype 属性是否出现在对象的原型链中的任何位置、

  故instanceof总是返回的true与false

### 3 ES5 和 ES6 分别几种方式声明变量

 `let`、`const`、`class`声明的全局变量再也不会和全局对象的属性挂钩

- ES5 有俩种：`var` 和 `function`
- ES6 有六种：增加四种，`let`、`const`、`class` 和 `import`

但其本质都是 let、var、const

### 4 DOM 事件有哪些阶段？谈谈对事件代理的理解

- 事件代理： 

  事件不直接绑定到某元素上，而是绑定到该元素的父元素上， 此后再通过条件判断子元素。

  好处： 代码简洁，且开销更小

- 捕获阶段--目标阶段--冒泡阶段

  1. **捕获阶段** (从根节点开始顺着目标节点构建一条事件路径，`即事件由页面元素接收，逐级向下，到具体的元素`)

  2. **目标阶段** (到达目标节点，`即元素本身`)

  3. **冒泡阶段** (从目标节点顺着捕获阶段构建的路径回去， `即跟捕获相反具体元素本身，逐级向上，到页面元素`)

### 5 requestAnimationFrame

js做动画是以定时器为核心实现，下一次的宏任务可能被上一次的宏任务堵塞。

1. 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成

2. 更加智能。 更加的在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流

3. requestAnimationFrame更像是一个独立的任务队列。 GUI渲染之前执行，但在微服务之后。

   绝对是一个异步任务

### 6 Object.is(val, val2)

> 略微的更合理了一些

1. Object.is(valueA,valueB) 以与严格相等运算符相同的方式检查相等性的参数
2. NaN 等于另一个 NaN 值
3. Object.is() 区分 -0 和 +0

### 7 隐式转换

- 共有

  ````js
  Number()
  String()
  Boolean() // 用 !! 同理
  parseInt()
  parseFloat()
  ````

### 8 如何让 a === 1 & a === 2

```js
var a = {
    value: 0,
    valueOf :function(){
        this.value++;
    	return this.value;
	}
}
```

### 9 函数柯里化（Currying）

一个函数返回一个函数这便是函数柯里化。

### 10 原型链

#### 01 | 概念

````js
Person() 	  prototype  ->			Person.prototype 
        		 	 	  
Person() 	  <- constructor	    Person.prototype 

Person()	  <- constructor		person    	

person		   __proto__ ->			Person.prototype 
````

1. prototype

   废话： 构造函数 有 【prototype】属性， 即 原型对象A.protptype 

   实例对象  `__proto__` 等同于 A.prototype

2. constructor

   【实例对象】和【原型对象】有构造函数

#### 02 | 题目

1. 第一道题目

   a 是 实例对象， 故 a 有 --proto--，显然为false

   a的原型对象， 即 【--proto--】， 故为true

   ```js
   var a = {}
   var b = Object.prototype
   
   # [false, true]
   console.log([a.prototype === b, Object.getPrototypeOf(a) == b]);
   ```

2. 第二道题目

   f 为构造函数， a 为原型对象

   b 获取到 构造函数的原型对象， 故为true

   ```js
   function f() {}
   var a = f.prototype 
   var b = Object.getPrototypeOf(f); 
   
   console.log(a === b); 
   ```


### 11  作用域与作用域链

#### 作用域

- 作用域

  定义变量的区域。作用域规定了如何查找变量。

- JavaScript的作用域 是 【静态作用域】

  JavaScript 使用【词法作用域】， 即【静态作用域】，即 【词法作用域】实现了JavaSCript的作用域

  ⭐ 函数的作用域在函数定义的时候就决定了！

  ````js
  var value = 1;
  
  function foo() {
      console.log(value);
  }
  
  function bar() {
      var value = 2;
      foo();
  }
  # 若是 动态 答案便是 2
  # 若是 静态 答案便是 1
  bar();
  ````

- 块级作用域

   使用let、const声明的才会有【块级作用域】

  - 为什么 let 、const 有块级作用域呢？  

    因为 作用域 的意义 就在于 服务于【变量】的访问权限的。

    目的是：  ES6的 let、const的特性的实现。

  - ES5之前只存在【全局作用域】与【函数作用域】

#### 执行上下文（栈）

> 此外这里要讲述一件事情
>
> 1. JavaScript的【解释阶段】 （JavaScript属于解释型语言）
>
>    - 词法分析
>    - 语法分析
>    - 作用域分析   （ ⭐  **作用域在定义时就确定，并且不会改变**  ）
>
> 2. JavaScript的【执行阶段】
>
>    - 创建执行上下文  （ ⭐**执行上下文在运行时确定，随时可能改变** ）
>
>      【变量对象（变量提升）】、【this】、`【作用域链】`（闭包）
>
>    - 执行函数代码
>
>    - 垃圾回收

⭐ 当遇到【可执行代码】时，便会进行【执行上下文】

- 可执行代码

  1. 类型： 【全局代码】【函数代码】【eval代码】。

  2. 执行上下文

     当遇到【可执行代码】时，便会进行【准备工作】，我们称呼其为【执行上下文】

- 执行上下文栈

  JS引擎中负责管理【执行上下文】的stack， 便是【执行上下文栈】

  1. 底栈总是【全局执行上下文】
  2. 函数的执行的开始与结束，就是入栈与出栈

- 示范

  这个概念指的是【函数提升】

  ⭐ 当开始执行， 全局【执行】上下文，这个准备工作，便包括了变量提升

  ```js
  function foo() {
      console.log('foo1');
  }
  
  foo();  // foo2
  
  function foo() {
  
      console.log('foo2');
  
  }
  
  foo(); // foo2
  ```

#### 作用域链

https://github.com/mqyqingfeng/Blog/issues/6

- 查找变量时

  1. 先从当前上下文的变量对象中查找
  2. 从上一级的执行上一份的变量对象查找，直至全局上下文。

  这种查找方式，多个执行上下文的变量对象构成的链表， 便是作用域链了



## 二 CSS

### 1 BFC

块级格式化上下文 Block Formatting Context

**用于决定`块级盒的布局`及`浮动相互影响范围`的`一个区域`**

1. margin会发生重叠,

   你可以用 BFC的隔离性 （  一个元素不能同时存在于两个 BFC 中 ）再其子元素外再创建BFC

2. BFC的区域不会与float box重叠（因为计算过程需要计算浮动流）

   即 它认得出 【浮动流】！这真是太好了！

3. BFC独立，不会影响外部元素

创建BFC  满足其一
1. 浮动元素、绝对定位 （absoluted、fixed）

2. 表格的标题和单元格（display:  table）、行内块元素、弹性元素 ( flex )、网格元素 （grid）

   display`  为 table-caption，table-cell

3. overflow不是visible

4. html根元素创建bfc元素

注意事项

1. BFC中若再有BFC，这便是两个BFC （即**一个元素不能同时存在于两个 BFC 中**）

### 2 为什么要初始化 CSS 样式

- 不同浏览器对有些标签的默认值是不同的

### 3 CSS3的新特性

1. flex布局

2. :first-of-type,nth-child

3. transition 、transform、动画 @keyframes

4. 媒体查询 @media

5. 其余特性

   ```css
   透明     rgba（255, 0, 0, 0.75）；
   圆角效果  border-radius: 5px;
   渐变色    background:linear-gradient（red, green, blue）；
   阴影     box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；
   超出文字  text-overflow:ellipsis;
   边框背景   border-image:url（bt_blue.png） 0 10
   ```


### 4 flex为1

flex是 flex-grow、flex-shrink、flex-basis三个属性的简写。

它们都是用于 flex的子元素的。

flex默认是 0 1 auto

````css
flex: 1;

flex: 1 1 auto(0%);
````

- flex-grow

  1. flex-grow 属性决定了父元素在空间分配方向上还有剩余空间时，如何分配这些剩余空间。

  2. flex-grow 默认为0，存在剩余的空间也不会放大。

- flex-shrink

  1. flex-shrink 属性定义空间不够时各个元素如何收缩。其值默认为 1。

  2. 每个元素收缩的权重为其 flex-shrink 乘以其宽度。

  3. 例子

     父元素 500，子元素 150、200、300

     flex-shrink为 1、2、3

     - 总共超出 150px
     - 总权重为： 1* 150 + 2 * 200 + 3 * 300 = 1450

     故计算收缩

     总收缩宽度 * flex-shrink * 各自权重宽度 / 总权重宽度

     - 150 * 1 * 150 / 1450  = 15.5
     - 150 * 2 * 400 / 1450 = 41.4
     - 150 * 3 * 900 / 1450 = 93.1

     故最终宽度为

     - 150 - 15.5 = 134.5
     - 200 - 41.4 = 158.6
     - 300 - 93.1 = 206.9

- flex-basis

  指定了flex元素在主轴方向上的初始大小（属性定义了在分配多余空间之前，项目占据的主轴空间（main size））

  浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

### 5 盒模型

- 组成盒模型

  1. content-box
  2. padding-box
  3. border-box
  4. margin-box

  margin-box也是组成盒子模型，但应注意，其决定不了实际盒子模型的宽高，只是表明了占比空间。

- 标准盒模型

  块级元素和inline-block元素

  1. width、height 即 content-box
  2. padding-box
  3. border-box

  注意 margin 并不计入实际的大小，虽然影响本盒子的页面占用空间， 但其影响的仅是外部空间。

- 怪异盒模型（ie盒子模型）

  由标准盒子可知，我们设置宽度其实并非是此盒子的真正宽度，它总要额外的计算。故额外提供了一个盒子来避免这个问题。

  这样 width 就是实际此盒子的width，您不需要再关心 border、padding了

  ````css
  .box {
  	box-sizing: border-box;    
  }
  ````

  1. 可以设置 `box-sizing` 在 `<html>` 元素上，然后设置所有元素继承该属性
  2. 此时margin也视作 外部空间。这无论在何时都是统一的，这也是margin存在的意义。    

### 6 实现一些常见布局

1. 实现双栏布局 （一）

   - 左栏浮动流， 宽度固定
   - 右栏 设置 margin-left对应宽度， 使得其宽度正确

2. 实现双栏布局 （二）

   - 左侧浮动
   - 右侧 overflow： hidden 触发 BFC

3. 实现三栏布局之 圣杯布局

   - 使用 `float` 布局。
   - 两侧使用 `margin` 负值，以便和中间内容横向重叠。
   - 防止中间内容被两侧覆盖，圣杯布局用 `padding` ，双飞翼布局用 `margin` 。

   ````js
   <div id="container">
     <p class="center">我是中间</p>
     <p class="left">我是左边</p>
     <p class="right">我是右边</p>
   </div>
   ````

   CSS

   ````css
   #container {
     padding-left: 200px;
     padding-right: 150px;
     overflow: auto;
   }
   #container p {
     float: left;
   }
   .center {
     width: 100%;
     background-color: lightcoral;
   }
   .left {
     width: 200px;
     position: relative;
     left: -200px;
     margin-left: -100%;
     background-color: lightcyan;
   }
   .right {
     width: 150px;
     margin-right: -150px;
     background-color: lightgreen;
   }
   ````

   

   

4. 

### 7 清除浮动

1. 何为CSS的浮动

   容器高度为 auto， 且容器中有浮动流时候，容器的高度计算无法识别浮动流

   - height： auto

     即 顾名思义 height可以自行调整。

     这代表： 【普通流中的父元素需要依赖子元素来进行计算】

2. 如何清除浮动流

   - clear属性

     规定在元素的哪一侧不允许出现浮动元素。

     此外： 或许使用伪类元素是一个更好的方案。

     ````html
     <style>
     .clear {
         clear: both;
     }
     </style>
     
     <div class = "wraper">
         <div class = "floatL">box1 </div>
         <div class = "floatR">box2 </div>
         <br class = "clear" />
     </div>
     ````

   - 触发浮动元素父元素的 BFC 

     方法很多，略。

### 8 行内块的幽灵节点



### 9 margin负值

- margin

  margin的上、左 是根据【左侧元素】【右侧元素】作为基准

  margin的下、右 是根据【元素自身】的【对应border】作为基准

- 故 margin为负值的时候

  margin-top、margin-left的负值， 会让其 自身向左移动、向上移动

  而

  margin-bottom、margin-right的负值会使用【下元素】移动。【右元素】移动。

举例子吧。

```html
    <div class="one">one</div>
    <div class="two">two</div>
```

- 给【two】设置margin-top: -50px

  【two】的margin-top的参考线为 【one】的底部。

  ​	故 【two】向上移动 50px

- 给【one】设置 margin-right: -50

  由于 right是参考自身的， 故自身整体元素都会向左移动 50px

## N 笔试

### 0 题目汇总⭐

1. 节流与防抖 答案: 略
2. 深拷贝 考虑的情况很多， 答案是一个非常完美的示范
3. 数组去重
4. 数组乱序
5. 手写 call、apply与bind
6. 继承 （ES5、ES6）
7. sleep函数
8. 实现promise、

### 2 深拷贝

- 关于正则拷贝的疑问

  ````js
  var regexp = new RegExp('xyz', 'gim'); => var regexp = /xyz/gim;
  
  									  xyz			gim
  const result = new target.constructor(target.source, reFlags.exec(target));
  ````

  

答案

````js
//判断数据是不是引用类型
function isObject(target) {
  return (
    target !== null &&
    (typeof target === "object" || typeof target === "function" || typeof target === 'symbol')
  );
}
// symbol、reg、function
function cloneType(type, target) {
  if (type === 'symbol') {
    return Object(Symbol.prototype.valueOf.call(target))
  }
  if (type === 'reg') {
    // 匹配字母、数字、下划线
    const reFlags = /\w*$/;
    // source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠			以及任何的标志字符。
    // JavaScript 正则表达式 constructor 属性返回 function RegExp() { [native code] }
    const result = new target.constructor(target.source, reFlags.exec(target));
    result.lastIndex = target.lastIndex;
    return result;  
  }
  if (type === 'function') {
    return function () {
      targe.call(this, ...arguments);
    };
  }

}

function init(type) {
  let result = null;
  switch (type) {
    case "[object Array]":
      result = [];
      break;
    case "[object Object]":
      result = {};
      break;
    case "[object Map]":
      result = new Map();
      break;
    case "[object Set]":
      result = new Set();
      break;
  }
  return result;
}

function deepClone(target) {
  let map = {};
  const result = clone(target, map);
  map = null;
  return result;
  function clone(target, map) {
    const isObj = isObject(target);
    const type = Object.prototype.toString.call(target);
    if (isObj) {
      let result = null;
      // 初始化
      result = init(type);
      if (type === "[object Object]") {
        const keys = Object.keys(target);
        keys.map(key => {
          //解决循环引用
          if (map[key]) return map[target];
          else {
            result[key] = clone(target[key], map);
            map[key] = result;
          }
        });
      }
      else if (type === "[object Array]") {
        const len = target.length;
        let i = -1;
        while (i++ < len - 1) {
          result[i] = clone(target[i], map);
        }
      }
      else {
        switch (type) {
          case "[object Date]":
            result = new Date(target);
            break;
          case "[object RegExp]":
            result = cloneType('reg', target);
            break;
          case "[object Function]":
            result = cloneType('function', target);
            break;
          case "[object Set]":
            target.forEach((value) => {
              result.add(clone(value, map));
            });
          case "[object Map]":
            target.forEach((value, key) => {
              result.set(key, clone(value, map));
            });
            break;
          case "[object Symbol]":
            result = cloneType('symbol', target);
        }
      }
      return result;
    }
    // 非对象 基本类型
    if (!isObj) {
      return target;
    }
  }
}
````

### 3 数组去重

> 1. 利用语法自身或键不可重复的特性使用重复
> 2. 循环比较去除重复

1. Set助我！

   - Set本身不可重复

   ```js
   Array.from (new Set(arr))
   ```

2. Map助我

   - Map的键名不可重复

   ````js
   // 你当然可以通过myMap.has(key)来优化
   arr.map(item => {myMap.set(item, null)});
   myMap.forEach((item, key) => {
       myArr.push(key);
   })
   ````

3. 双重循环去除重复

   > 实现方法大同小异

   ```js
   for (let i = 0; i <= arr.length - 1; i++) {
     let j = arr.length;
     while (--j > i) {
       console.log(j);
       if (arr[i] === arr[j]) {
         arr.splice(j, 1)
       }
     }
   }
   ```

4. `indexOf` 去除重复

   `includes` 同理 略

   你也可以用filter过滤， 但没必要吧，以上四种已经很简便了

   ```js
   let array = []
   for (var i = 0; i < arr.length; i++) {
     if (array.indexOf(arr[i]) === -1) {
       array.push(arr[i])
     }
   }
   console.log(array);
   ```

### 4 数组乱序

> 数组进行乱序处理 不过这是虚伪的随机

````js
arr.sort(function () {
   return .5 * Math.random(); 
});
````

- 更好的实现

  ```js
  function shuffle(array) {
      var m = array.length,
          t, i;
      while (m) {
          i = Math.floor(Math.random() * m--);
          t = array[m];
          array[m] = array[i];
          array[i] = t;
      }
      return array;
  }
  ```

  

> 题目升级: **有一个长度为 100 的数组，如何从中随机挑选 50 个元素，组成一个新的数组？**

洗牌算法

````js
function getRandomArrElement(arr, count) {
    let shuffled = arr.slice(0), 
        i = arr.length, 
        min = i - count, 
        temp, 
        index;
    while (i > min) {
        index = Math.floor((i--) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}
````

### 5 call、apply与bind

此外： https://segmentfault.com/a/1190000020871501

1. call

   - 将函数设为对象的属性

   ````js
   Function.prototype.myCall = function(_this = window) {
     _this.fn = this;
     let args = [...arguments].slice(1);
     let result = _this.fn(...args);
     delete _this.fn;
     return result;
   }
   ````

2. apply

   ````js
   Function.prototype.myApply = function(context = window, args = []) {
     context = context || window; // 参数默认值并不会排除null，所以重新赋值
     context.fn = this; // this是调用call的函数
     const result = context.fn(...args);
     delete context.fn;
     return result;
   }
   ````

3. bind

   ```js
   Function.prototype.myBind = function(context, ...args) {
     const _this = this;
     return function Bind(...newArgs) {
       // 考虑是否此函数被继承
       if (this instanceof Bind) {
         return _this.myApply(this, [...args, ...newArgs])
       }
       return _this.myApply(context, [...args, ...newArgs])
     }
   }
   ```

### 6 继承 （ES5、ES6）

#### 1 寄生组合式继承

- `组合式继承`: 原型链+构造函数

  1. 独享【属性】或【方法】用`构造`

  2. 共享【属性】或【方法】用`原型`！

     ````js
     function Father(name) {}
     Father.prototpe.say = function() {}
     
     function Son() {
         Super.call(this); # 继承属性
     }
     #1 继承方法 当然此处也会继承属性，不过由于存在相同的实例属性故会被拦截
     Son.prototype = new Father();
     ````

- `寄生式继承的`

  1. 首先要明白 `原型式继承`

     - 相当于又一个person的拷贝， 若其有引用类型，则是共有属性！在你不覆盖的前提下！

       不通过prototype便可以实现了一个共有属性！

     - 你可以`增强`这份`拷贝`

     ````js
     var person2 = Object.create(person, {
        name: {
         	value: 'Greg',  
        },
     });
     ````

  2. 寄生继承

     寄生继承 面对的是 对象这种类型，故给他起名字为寄生。 原理其实与原型式继承几乎相同。

     我只要返回一个新的对象给你，那么其实就是可以称呼其为寄生继承

     ```js
     function inheritProtoType(son, father) {
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

- `寄生组合式继承`

  1. 组合式继承

     独享【属性】或【方法】用`构造`

     共享【属性】或【方法】用`原型`

  2. 寄生继承解决继承的时候问题

     > 由于既需要继承 父类的 公有属性与方法， 也需要继承私有属性与方法， 那便会导致多余的一次构造被调用。

     ```js
     function Sub(age) {				# 构造函数继承（实例化父属性）
         Super.call(this);            
     	this.age = age;
     }
     								# 原型继承
     Sub.prototype = new SuperType();
     ```

     > 故有什么好办法，让原型继承不执行构造函数呢？ => 寄生继承``

     本质就是将原型改为对象，再指下。很好理解！确实如此！

     ```js
     function inheritProtoType(son, father) {
         
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

#### 2 ES6继承

> 1. `extends`实现原型继承
>
>    ```js
>    class A extends B{}
>    
>    Student.__proto__= Person
>    Student.prototype.__proto__ = Person.prototype;
>    ```
>
> 2. `super`实现父类实例继承
>
>    ⭐ 子类必须在constructor方法中调用super方法
>
>    ​       是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象
>
>    ````js
>     1 class Colorpoint extends Point {
>     2     constructor(x,y,color){
>     3         super(x,y); //调用父类的constructor(x,y)
>     4         this.color = color
>     5     }
>     6	}
>    ````
>
>    

示范

````js
class super{
    constructor(name,color){
        this.name=name;
        this.color=["red","blue","green"];
    }
    sayName(){
        alert(this.name);
    }
}
````

### 7 sleep函数

> sleep函数作用是让线程休眠，等到指定时间在重新唤起。js单线程是`不能实现休眠的`

1. 无线循环， 直至时间结束，虽然毫无意义，但是实现sleep, 但极消耗CPU

   ```js
   function sleep(time) {
     let t = Date.now();
     while (Date.now() - t < time) {
     };
   }
   ```

2. 通过回调，但是其作为另外的任务，并不对杜塞这个进程的其他代码继续执行

   故使用 async await吧， 虽然本质也是Promise， 将后续杜塞的代码都应是在Promise的回调中吧!

   ```js
   function sleep(time) {
       return new Promise((resolve) => {
       	setTimeout(resolve, time)
       })
   }
   sleep(1000).then( () => {})
   ```

   

### 8 实现promise与其附属函数

#### Promise

https://segmentfault.com/a/1190000023690122?utm_source=sf-similar-article

https://juejin.cn/post/6945319439772434469#heading-0	

https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide

````js

const PENDDING = 'pendding';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';
// 定义MyPromise
function MyPromise(executor) {
  const self = this;
  self.status = PENDDING;
  self.data = undefined;
  self.callbacks = [];

  function resolve(value) {
    if (self.status !== PENDDING) return;
    self.status = FULFILLED;
    self.data = value;
    // 立即执行异步回调函数，即他肯定是在then加入事件后再去执行他们，也考虑了同步问题
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onResolved(value);
      })
    })
  }

  function reject(reason) {
    if (self.status !== PENDDING) return;
    self.status = REJECTED;
    self.data = reason;
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onRejected(reason);
      })
    })
  }
  executor(resolve, reject)
}

// MyPromise原型链上存在then方法
MyPromise.prototype.then = function (onResolved, onRejected) {
  const self = this;
  return new MyPromise((resolve, reject) => { // 每次都返回一个新的Promise对象
    // 首先判断当前状态
    if (self.status === FULFILLED) {
      /* 
          1、返回的Promise的结果是由onResolved/onrejected决定的
          2、返回的是Promise对象 (根据执结果决定Promise的返回结果)
          3、返回的不是Promise对象 (该值就是Promise的返回结果)
          4、抛出异常 异常的值为返回的结果
      */
      setTimeout(() => {
        try {
          const result = onResolved(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === REJECTED) {
      setTimeout(() => {
        try {
          const result = onRejected(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === PENDDING) {
      self.callbacks.push({
        onResolved() {
          try {
            const result = onResolved(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        },
        onRejected() {
          try {
            const result = onRejected(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        }
      })
    }
  })
}
````

#### Promise.all / Promise.race

````js
//MyPromise实例对象上存在all方法
MyPromise.all = function (promises) {
    let promisesCount = 0
    let values = new Array(promises.length);
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(value => {
          promisesCount++;
          values[index] = value;
          if (promisesCount === promises.length) {
            resolve(values);
          }
        }, reason => {
          reject(reason);
        })
      })
    })
}

//MyPromise实例对象上存在race方法
  MyPromise.race = function (promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(value => {
          resolve(value);
        }, reason => {
          reject(reason)
        })
      })
    })
  }
````

####   Promise.resolve  / Promise.reject

````js

MyPromise.resolve = function (value) {
    if (value instanceof MyPromise) return value;
    // 返回一个resolved状态的Promise对象
    return new MyPromise(resolve => resolve(value))             
}

//MyPromise实例对象上存在reject方法
MyPromise.reject = function (reason) {
    return new MyPromise((resolve,reject) => reject(reason));  // 返回一个reject状态Promise对象
}
````



### 9 并发请求的限制

> 请实现如下函数，
>
> 可以批量请求数据，所有 URL 地址在`urls`参数中，同时可以通过`max`参数控制请求的并发度，
>
> 当所有请求执行结束后需要执行`callback`回调函数，请求函数用 fetch 即可(不做请求失败处理)。



#### 思路一

- 利用async + await 与 promise.all 来进行， 每次以max来进行请求

````js
// 根据max将一维数组切成二维数组
const group = (list = [], max = 0) => {
  if (!list.length) {
    return list
  }
  let results = []
  for (let i = 0, len = list.length; i < len; i += max) {
    results.push(list.slice(i, i + max))
  }
  return results
}

const requestHandler = async (
  groupedUrl = [],
  callback = () => { }
) => {
  if (!groupedUrl.length) {
    callback()
    return groupedUrl
  }
  const newGroupedUrl = groupedUrl.map(fn => fn())
  const resultsMapper = (results) => results.map(callback)
  const data = await Promise.allSettled(newGroupedUrl).then(resultsMapper)
  return data;
}

// 单纯的请求入口
const sendRequest = async (
  urls = [],
  max = 0,
  callback = () => { }
) => {
  if (!urls.length) {
    return urls
  }
  const groupedUrls = group(urls, max)
  const results = []
  console.log('start !')
  for (let groupedUrl of groupedUrls) {
    try {
      const result = await requestHandler(groupedUrl, callback)
      results.push(result)
      console.log('go')
    } catch { }
  }
  console.log('done !')
  return results
}

// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p1'))
const p2 = () => Promise.resolve(2)
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p3'))
const p4 = () => Promise.resolve(4)
const p5 = () => new Promise((resolve, reject) => setTimeout(reject, 2000, 'p5'))
const p6 = () => Promise.resolve(6)
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))
const p8 = () => Promise.resolve(8)
const p9 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p9'))
const p10 = () => Promise.resolve(10)
const p11 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p10'))
const p12 = () => Promise.resolve(12)
const p13 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p11'))
const p14 = () => Promise.resolve(14)

const ps = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]
sendRequest(ps, 3, ({ reason, value }) => {
  console.log(reason || value)
})

````

#### 思路二

```js
function requestData(promiseList = [], max = 1, callback) {
  let requestArr = [],
    i = 0;
  // 我们将请求的promise一项一项丢入到其中（递归实现），执行完毕就删除掉
  // requestArr到达上限那么我们等待请求执行，有空位在继续添加
  // 
  toFetch().then(() => Promise.all(requestArr)).then(() => {
    callback('进程结束！');
  })

  function toFetch() {
    // 递归结束
    if (i === promiseList.length) return Promise.resolve();
    let _item = promiseList[i++]();
    console.log('进程进行中');
    requestArr.push(_item);
    // 宏任务执行结束后, 微任务执行，删除对应的那个微任务
    _item.then(() => { 
      requestArr.splice(requestArr.indexOf(_item), 1)
     });
    let result = Promise.resolve();
    // 是否需要进行并发处理?
    if (requestArr.length === max) {
      result = Promise.race(requestArr);
    }
    // 若有空位继续， 若无空位等待 => then
    return result.then(() => toFetch());
  }

}



// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p1'))
const p2 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p2'))
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p3'))
const p4 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p4'))
const p5 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p5'))
const p6 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p6'))
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))

const ps = [p1, p2, p3, p4, p5, p6, p7]

requestData(ps, 4, (reason, value) => {
  console.log(reason || value)
})


```

### 使用reduce实现累加

- 答案

  ⭐ 上次执行函数时的结果保存在了pre中!

  ````js
  // 4.使用reduce方法
  var numbers = [1, 2, 3, 4]
  var total = numbers.reduce(function (pre, cur) {
      return pre + cur
  })
  alert(total)
  ````

- s





