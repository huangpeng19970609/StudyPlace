### 一 面试题汇总

1. 状态码304
2. 宏任务与微任务
3. http缓存的方法有哪些，它们的优先级是怎样的 ？
   - 文章： https://segmentfault.com/a/1190000018802578、
4. 浏览器缓存 老生常谈的问题
5. 都说要减少 https 的请求，https 为什么慢 ？
6. http 1.0 与 http 2.0

### 3 关于浏览器缓存资源

>  浏览器缓存只存在于每个单独的客户端，因此它是私有缓存，而非共享缓存（多用户）如何启用缓存?

#### 1 启用缓存

- 浏览器根据 response Headers 字段决定是否缓存资源

  1. Cache-Control

     ```js
     Cache-Control: private/public
     Cache-Control: max-age=300
     Cache-Control: no-cache
     ```

     - `private` ：表示该资源只能被浏览器缓存。
     - `public` ：该资源既能被浏览器缓存，也能被任何中间人（比如代理服务器、CDN 等）缓存。
     - `max-age` ：够被缓存的最大时间。`为0` 该资源仍然会被浏览器缓存，只不过立刻就过期了。
     - `no-cache` ：该资源会被缓存，但是立刻就过期了，因此需要先和服务器确认资源是否发生变化，只有当资源没有变化时，该缓存才会被使用，否则需要从服务器下载。相当于 `max-age=0`

  2. Expries

     也可以通过此参数来控制缓存

     `Expires` 标识了缓存的`具体过期时间`，来控制资源何时过期

     ```typescript
     Expires: Fri, 08 Mar 2029 08:05:59 GMT
     Expires: 0 // Expires: 0 仍然会启用缓存，只不过缓存立刻过期。
     ```

#### 2 优先级

- 哪一个会成功呢？

  1. Cache-Control: max-age=600
  2. Expires: 0

  Cache-Control 的优先级高于 Expires

#### 3 浏览器的默认行为

即便你不设置 cache-control 与 expries， 浏览器也会缓存一些内容。

- Response Header 中有 Last-Modified 但是没有 Cache-Control 和 Expires 时，

  浏览器会用一套自己的算法来决定这个资源会被缓存多长时间

#### 4 禁止缓存

给 `Cache-Control` 设置 `no-store` 会禁止浏览器和中间人缓存该资源。

在处理包含个人隐私数据或银行业务数据的资源时很有用。

#### 5 缓存位置

以 `billbill`网站为例，便可看到其存在三种不同的size。 这便是缓存位置的不同。

![image-20210925144909241](../images/image-20210925144909241.png)

> 1. Service Worker: 浏览器缓存资源的一个网络代理，具体略。
> 2. Memory Cache: 内存缓存
> 3. Disk Cache : 硬盘缓存
> 4. Push Cache： 只在会话（Session）中存在， chrome仅存在5分钟
>
> 若以上依次都没有命中，则发起`网络请求`

#### 6 缓存分类

> 普通刷新会启用协商缓存，忽略强缓存.
>
> 只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存

1. 强缓存    （也称本地缓存）
2. 协商缓存（也称弱缓存）

> 浏览器缓存机制

1. 会先去缓存里面查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器

2. 当强缓存没有命中时，浏览器一定会向服务器发起请求。

   - 服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。

   - 如果命中协商缓存，服务器会返回响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从缓存中获取这个资源。

   - 否则，进入下一步。

3. 如果前两步都没有命中，则直接从服务器加载资源

### 4 浏览器缓存数据

> 1.  cookie
> 2. **session**
> 3. **localStorage**

#### 1 cookie

- 细节

  1. document.cookie `查看`当前cookie
  2. `每次网络请求` Request headers 中都会带上cookie, 故cookie 太多太大
  3. 一般`浏览器存储cookie` 最大容量为4k，所以大量数据不要存到cookie
  4. cookie只能保存`字符串`类型，以文本的方式

- 是否设置时间

  1. 会话cookie: 不设置过期时间，cookie被保存在`内存`中，生命周期`随浏览器的关闭`而`结束`

  2. `设置`了cookie的过期时间, 

     cookie被保存在`硬盘`中，关闭浏览器后，cookie数据仍然存在，`直到过期时间结束`才消失

- 场景：用于记录不敏感信息
  1. 用户是否登陆过网站,
  2. 保存上次查看的页面、浏览计数这类信息

#### 2  session

> session 是如何诞生的?
>
> - cookie的致命性缺点:
>   1. cookie 是存在客户户端，而且它本身存储的尺寸大小也有限,但这不致命
>   2. `致命的缺点`: 用户可以是可见的，并可以随意的修改，很不安全. cookie存储于客户端

- session的运行机制
  1. 用户第一次的登录 => 浏览器会将用户信息发送给服务器 
  2. 服务器创建SessionId， 响应内容（Cookie）中将该SessionId一并返回给浏览器， 
  3. 浏览将其以特定key值存储于cookie 【如SessionId】
  4. 下一次服务器接收到请求信息，便可获取Session，可根据SessionId获知用户的Session并返回给浏览器
- 应用场景
  1. 与cookie大同小异

#### 3 WebStorage

> 即便是 session也无非是借助了cookie, 将任务转移到了服务器端以保证安全性。
>
> 有没有更好的的方案？
>
> 但其实 cookie还是不可获取的，因为我们确实要与服务器端进行交互
>
> Web Storage仅仅是为了在本地“存储”数据而生。

- WebStorage目标
  1. 摆脱cookie
  2. 希望数据量更大
  3. 跨会话

- 共性:

  1. 不与服务器通信。
  2. 可以存储5MB
  3. 字符串类型， 故建议是json字符串

- `改革之处`

  1. 不再需要向服务器发送cookie了！不仅更加安全而且更快速了！

  

#### 3.1 localStorage

1. 除非主动删除。 否则即便是关闭了页面、关闭了浏览器也不销毁。

2. 场景: 

   常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据 

3. 应用场景:

   常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据

#### 3.2 sessionStorage

1. 当前会话！

   sessionStorage是不可以非同源跨标签访问的！除非其是同源， 故很适合SPA页面开发

   而传统的 cookie是目标是当前浏览器进程！

2. 应用场景:

   敏感账号一次性登录；

### 5 https

> 什么叫https?
>
> http: HyperText Transfer Protocol 超文本传输协议
>
> `S` Secure Socket Layer => 即 SSL

- 为什么要有https？ 为什么需要 SSL加密?

  传统的http是如此的： 客户端与服务器之间`没有任何身份确认的过程`，且是明文

  故存在风险

  1. 窃听, 黑客可获知通信的内容
  2. 篡改: 黑客可修改通信的内容
  3. 劫持: 黑客可冒充客户端与服务端的某一身份

#### 1 解决窃听问题

`使用加密`    对称加密+非对称加密

1. 对称加密： 加密和解密同用一个密钥, 即**任何人只要持有密钥就能解密了**
   - 以对称加密方式加密时必须将密钥也发给对方

   但这样被窃听以后，显然可以获取到密钥，毫无意义。因为是明文!
   
   - 缺点： 数据安全！
   
2. 非对称加密：

   公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥

   发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

   这样即使被劫持到了公钥也是无所谓的事情。

   - 缺点： 解密效率问题！

3.  对称加密+非对称加密

   使用 非对称加密 将 【对称加密的密钥】进行加密。

   对方使用 私钥进行 解密， 获得 【对称密钥】

   - **可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**
   - 且效率良好！

#### 2 篡改问题

解决： 使用数字签名 => 但与劫持问题有相同问题， 你如何解密我的数字签名? 

> **证书颁发机构 **  故需要第三方机构

#### 3 劫持问题

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

> 第三方机构

1. 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
2. CA给与服务器方
   - 申请者公钥
   - 数字签名的密文
   - 证书信息
3. 客户端发送请求 => 服务器返回证书文件
4. 客户端读明文信息， 使用CA公钥解密，对比第三方的证书信息，确定合法性。

#### 4 与http区别、https更慢

- https 建立于 SSL加密通道【加密数据】， http是明文传输
- HTTPS需要用到SSL证书，而HTTP不用;

其次 https被认为性能慢于 http

1. 性能消耗要大于HTTP, 因为并非是纯文本传输数据，**加密通信会消耗更多的CPU及内存资源**	

### 6 http1.x与http2.0

文档: https://segmentfault.com/a/1190000015316332

文档-2： https://segmentfault.com/a/1190000012975173?utm_source=sf-similar-article

> 历史的进程已然走到了今天，不知道未来又如何？
>
> 1. 1987年发布http协议1.0版本
>
> 2. 1997年发布http1.1协议 => tcp的复用方案 => 即熟知的 connection: keep-alive特性
>
> 3. 伴随移动端的 的越来越普及，图片与视频的加载越来越多，故 google提出 spdy协议。
>
>    http2即基于spdy协议，目前仍在提案。同期，quic协议提出，基于udp模拟tcp的面向连接。

#### 1. http1.x

> ❗ http 1.x 有一个致命的问题

- **缺陷**：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被`阻塞`
- 这更像是安全机制： `并发限制`
- 所以真的存在大量的图片， 建议使用两个域名来分别处理。

#### 2 http1.0

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

  服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；

  而问题在于 tcp 需要三次 客户端与服务器端的握手才可以，其每次tcp连接的成本很高

- 解决： 添加 `Connction:  keep-alive`

#### 3 http1.1

是改进版本

1. **持久连接**

   - 即默认的Tcp连接便不关闭，且可复用。

     在1.1之后Connection的默认值就是Keep-Alive

2. 管道机制

   - 同一个tcp连接，客户端可以发送多个请求

     多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应

     显然这样管道传输也会带来对应的缺点！

     - 注意： 但是pipelining并不能彻底解决holb的问题，比如只有GET，HEAD才能使用，POST不能使用，

     <img src="C:/Users/HuangPeng/AppData/Roaming/Typora/typora-user-images/image-20210927002719225.png" alt="image-20210927002719225" style="zoom:50%;" />

3. 分块传输编码

   服务器一旦有数据就传输，以【流模式】代替【缓存模式】。 相当于分块

4. 更多的请求方式

   RESTful方式 => put、delete、options等

5. 缺点

   - 用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行**的。

     `服务器只有处理完一个请求，才会接着处理下一个请求`

   - 解决方案

     减少请求数、或同时多开持久连接

#### 4 http2

1. 二进制

   http2的头信息现在是 二进制！ 即 帧

   HTTP消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序

2. **完全多路复用**

   客户端和浏览器都可以同时发送多个请求或回应， 而且不用按照顺序一一对应

   - 实现： 

     一个request对应一个id，这样一个连接上可以有多个request。

     每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面

3. **报头压缩**

   - 对于相同的头部，不必再通过请求发送，只需发送一次。

     比如每次都发送cookie这件事情！

     客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号

   - 头信息压缩机制， gzip或compress压缩后再发送

4.  **服务器推送**

   HTTP/2 允许服务器未经请求，主动向客户端发送资源

#### 4 关于https

https不关心你是htpp1还是http2

HTTP协议通常承载于TCP协议之上， 在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.

