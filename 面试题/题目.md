### 一 面试题汇总

1. 状态码304
2. 宏任务与微任务
3. http缓存的方法有哪些，它们的优先级是怎样的 ？
   - 文章： https://segmentfault.com/a/1190000018802578、
4. 浏览器缓存 老生常谈的问题

5. 都说要减少 https 的请求，https 为什么慢 ？

### 3 关于浏览器缓存资源

>  浏览器缓存只存在于每个单独的客户端，因此它是私有缓存，而非共享缓存（多用户）如何启用缓存?

#### 1 启用缓存

- 浏览器根据 response Headers 字段决定是否缓存资源

  1. Cache-Control

     ```js
     Cache-Control: private/public
     Cache-Control: max-age=300
     Cache-Control: no-cache
     ```

     - `private` ：表示该资源只能被浏览器缓存。
     - `public` ：该资源既能被浏览器缓存，也能被任何中间人（比如代理服务器、CDN 等）缓存。
     - `max-age` ：够被缓存的最大时间。`为0` 该资源仍然会被浏览器缓存，只不过立刻就过期了。
     - `no-cache` ：该资源会被缓存，但是立刻就过期了，因此需要先和服务器确认资源是否发生变化，只有当资源没有变化时，该缓存才会被使用，否则需要从服务器下载。相当于 `max-age=0`

  2. Expries

     也可以通过此参数来控制缓存

     `Expires` 标识了缓存的`具体过期时间`，来控制资源何时过期

     ```typescript
     Expires: Fri, 08 Mar 2029 08:05:59 GMT
     Expires: 0 // Expires: 0 仍然会启用缓存，只不过缓存立刻过期。
     ```

#### 2 优先级

- 哪一个会成功呢？

  1. Cache-Control: max-age=600
  2. Expires: 0

  Cache-Control 的优先级高于 Expires

#### 3 浏览器的默认行为

即便你不设置 cache-control 与 expries， 浏览器也会缓存一些内容。

- Response Header 中有 Last-Modified 但是没有 Cache-Control 和 Expires 时，

  浏览器会用一套自己的算法来决定这个资源会被缓存多长时间

#### 4 禁止缓存

给 `Cache-Control` 设置 `no-store` 会禁止浏览器和中间人缓存该资源。

在处理包含个人隐私数据或银行业务数据的资源时很有用。

#### 5 缓存位置

以 `billbill`网站为例，便可看到其存在三种不同的size。 这便是缓存位置的不同。

![image-20210925144909241](../images/image-20210925144909241.png)

> 1. Service Worker: 浏览器缓存资源的一个网络代理，具体略。
> 2. Memory Cache: 内存缓存
> 3. Disk Cache : 硬盘缓存
> 4. Push Cache： 只在会话（Session）中存在， chrome仅存在5分钟
>
> 若以上依次都没有命中，则发起`网络请求`

#### 6 缓存分类

> 普通刷新会启用协商缓存，忽略强缓存.
>
> 只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存

1. 强缓存    （也称本地缓存）
2. 协商缓存（也称弱缓存）

> 浏览器缓存机制

1. 会先去缓存里面查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器

2. 当强缓存没有命中时，浏览器一定会向服务器发起请求。

   - 服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。

   - 如果命中协商缓存，服务器会返回响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从缓存中获取这个资源。

   - 否则，进入下一步。

3. 如果前两步都没有命中，则直接从服务器加载资源

### 4 浏览器缓存数据

> 1.  cookie
> 2. **session**
> 3. **localStorage**

#### 1 cookie

- 细节

  1. document.cookie `查看`当前cookie
  2. `每次网络请求` Request headers 中都会带上cookie, 故cookie 太多太大
  3. 一般`浏览器存储cookie` 最大容量为4k，所以大量数据不要存到cookie
  4. cookie只能保存`字符串`类型，以文本的方式

- 是否设置时间

  1. 会话cookie: 不设置过期时间，cookie被保存在`内存`中，生命周期`随浏览器的关闭`而`结束`

  2. `设置`了cookie的过期时间, 

     cookie被保存在`硬盘`中，关闭浏览器后，cookie数据仍然存在，`直到过期时间结束`才消失

- 场景：用于记录不敏感信息
  1. 用户是否登陆过网站,
  2. 保存上次查看的页面、浏览计数这类信息

#### 2  session

> session 是如何诞生的?
>
> - cookie的致命性缺点:
>   1. cookie 是存在客户户端，而且它本身存储的尺寸大小也有限,但这不致命
>   2. `致命的缺点`: 用户可以是可见的，并可以随意的修改，很不安全. cookie存储于客户端

- session的运行机制
  1. 用户第一次的登录 => 浏览器会将用户信息发送给服务器 
  2. 服务器创建SessionId， 响应内容（Cookie）中将该SessionId一并返回给浏览器， 
  3. 浏览将其以特定key值存储于cookie 【如SessionId】
  4. 下一次服务器接收到请求信息，便可获取Session，可根据SessionId获知用户的Session并返回给浏览器
- 应用场景
  1. 与cookie大同小异

#### 3 WebStorage

> 即便是 session也无非是借助了cookie, 将任务转移到了服务器端以保证安全性。
>
> 有没有更好的的方案？
>
> 但其实 cookie还是不可获取的，因为我们确实要与服务器端进行交互
>
> Web Storage仅仅是为了在本地“存储”数据而生。

- WebStorage目标
  1. 摆脱cookie
  2. 希望数据量更大
  3. 跨会话

- 共性:

  1. 不与服务器通信。
  2. 可以存储5MB
  3. 字符串类型， 故建议是json字符串

- `改革之处`

  1. 不再需要向服务器发送cookie了！不仅更加安全而且更快速了！

  

#### 3.1 localStorage

1. 除非主动删除。 否则即便是关闭了页面、关闭了浏览器也不销毁。

2. 场景: 

   常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据 

3. 应用场景:

   常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据

#### 3.2 sessionStorage

1. 当前会话！

   sessionStorage是不可以非同源跨标签访问的！除非其是同源， 故很适合SPA页面开发

   而传统的 cookie是目标是当前浏览器进程！

2. 应用场景:

   敏感账号一次性登录；

### 5 https

> 什么叫https?
>
> http: HyperText Transfer Protocol 超文本传输协议
>
> `S` Secure Socket Layer => 即 SSL

- 为什么要有https？ 为什么需要 SSL加密?

  传统的http是如此的： 客户端与服务器之间`没有任何身份确认的过程`，且是明文

  故存在风险

  1. 窃听, 黑客可获知通信的内容
  2. 篡改: 黑客可修改通信的内容
  3. 劫持: 黑客可冒充客户端与服务端的某一身份

#### 1 解决窃听问题

`使用加密`    对称加密+非对称加密

1. 对称加密： 加密和解密同用一个密钥, 即**任何人只要持有密钥就能解密了**
   - 以对称加密方式加密时必须将密钥也发给对方

   但这样被窃听以后，显然可以获取到密钥，毫无意义。因为是明文!
   
   - 缺点： 数据安全！
   
2. 非对称加密：

   公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥

   发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

   这样即使被劫持到了公钥也是无所谓的事情。

   - 缺点： 解密效率问题！

3.  对称加密+非对称加密

   使用 非对称加密 将 【对称加密的密钥】进行加密。

   对方使用 私钥进行 解密， 获得 【对称密钥】

   - **可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**
   - 且效率良好！

#### 2 篡改问题

解决： 使用数字签名 => 但与劫持问题有相同问题， 你如何解密我的数字签名? 

> **证书颁发机构 **  故需要第三方机构

#### 3 劫持问题

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

> 第三方机构

1. 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
2. CA给与服务器方
   - 申请者公钥
   - 数字签名的密文
   - 证书信息
3. 客户端发送请求 => 服务器返回证书文件
4. 客户端读明文信息， 使用CA公钥解密，对比第三方的证书信息，确定合法性。

#### 4 与http区别、https更慢

- https 建立于 SSL加密通道【加密数据】， http是明文传输
- HTTPS需要用到SSL证书，而HTTP不用;

其次 https被认为性能慢于 http

1. 性能消耗要大于HTTP, 因为并非是纯文本传输数据，**加密通信会消耗更多的CPU及内存资源**	

